const micro = @import("microzig");
const mmio = micro.mmio;

pub const devices = struct {
    ///  STM32H7x3
    pub const stm32h7 = struct {
        pub const properties = struct {
            pub const @"cpu.endian" = "little";
            pub const @"cpu.mpuPresent" = "true";
            pub const @"cpu.revision" = "r0p1";
            pub const @"cpu.name" = "CM7";
            pub const @"cpu.nvicPrioBits" = "4";
            pub const @"cpu.vendorSystickConfig" = "false";
            pub const @"cpu.fpuPresent" = "true";
        };

        pub const VectorTable = extern struct {
            const Handler = micro.interrupt.Handler;
            const unhandled = micro.interrupt.unhandled;

            initial_stack_pointer: u32,
            Reset: Handler = unhandled,
            NMI: Handler = unhandled,
            HardFault: Handler = unhandled,
            MemManageFault: Handler = unhandled,
            BusFault: Handler = unhandled,
            UsageFault: Handler = unhandled,
            reserved5: [4]u32 = undefined,
            SVCall: Handler = unhandled,
            reserved10: [2]u32 = undefined,
            PendSV: Handler = unhandled,
            SysTick: Handler = unhandled,
            ///  Window Watchdog interrupt
            WWDG1: Handler = unhandled,
            ///  PVD through EXTI line
            PVD_PVM: Handler = unhandled,
            ///  RTC tamper, timestamp
            RTC_TAMP_STAMP_CSS_LSE: Handler = unhandled,
            ///  RTC Wakeup interrupt
            RTC_WKUP: Handler = unhandled,
            ///  Flash memory
            FLASH: Handler = unhandled,
            ///  RCC global interrupt
            RCC: Handler = unhandled,
            ///  EXTI Line 0 interrupt
            EXTI0: Handler = unhandled,
            ///  EXTI Line 1 interrupt
            EXTI1: Handler = unhandled,
            ///  EXTI Line 2 interrupt
            EXTI2: Handler = unhandled,
            ///  EXTI Line 3interrupt
            EXTI3: Handler = unhandled,
            ///  EXTI Line 4interrupt
            EXTI4: Handler = unhandled,
            ///  DMA1 Stream0
            DMA_STR0: Handler = unhandled,
            ///  DMA1 Stream1
            DMA_STR1: Handler = unhandled,
            ///  DMA1 Stream2
            DMA_STR2: Handler = unhandled,
            ///  DMA1 Stream3
            DMA_STR3: Handler = unhandled,
            ///  DMA1 Stream4
            DMA_STR4: Handler = unhandled,
            ///  DMA1 Stream5
            DMA_STR5: Handler = unhandled,
            ///  DMA1 Stream6
            DMA_STR6: Handler = unhandled,
            ///  ADC1 and ADC2
            ADC1_2: Handler = unhandled,
            ///  FDCAN1 Interrupt 0
            FDCAN1_IT0: Handler = unhandled,
            ///  FDCAN2 Interrupt 0
            FDCAN2_IT0: Handler = unhandled,
            ///  FDCAN1 Interrupt 1
            FDCAN1_IT1: Handler = unhandled,
            ///  FDCAN2 Interrupt 1
            FDCAN2_IT1: Handler = unhandled,
            ///  EXTI Line[9:5] interrupts
            EXTI9_5: Handler = unhandled,
            ///  TIM1 break interrupt
            TIM1_BRK: Handler = unhandled,
            ///  TIM1 update interrupt
            TIM1_UP: Handler = unhandled,
            ///  TIM1 trigger and commutation
            TIM1_TRG_COM: Handler = unhandled,
            ///  TIM1 capture / compare
            TIM_CC: Handler = unhandled,
            ///  TIM2 global interrupt
            TIM2: Handler = unhandled,
            ///  TIM3 global interrupt
            TIM3: Handler = unhandled,
            ///  TIM4 global interrupt
            TIM4: Handler = unhandled,
            ///  I2C1 event interrupt
            I2C1_EV: Handler = unhandled,
            ///  I2C1 error interrupt
            I2C1_ER: Handler = unhandled,
            ///  I2C2 event interrupt
            I2C2_EV: Handler = unhandled,
            ///  I2C2 error interrupt
            I2C2_ER: Handler = unhandled,
            ///  SPI1 global interrupt
            SPI1: Handler = unhandled,
            ///  SPI2 global interrupt
            SPI2: Handler = unhandled,
            ///  USART1 global interrupt
            USART1: Handler = unhandled,
            ///  USART2 global interrupt
            USART2: Handler = unhandled,
            ///  USART3 global interrupt
            USART3: Handler = unhandled,
            ///  EXTI Line[15:10] interrupts
            EXTI15_10: Handler = unhandled,
            ///  RTC alarms (A and B)
            RTC_ALARM: Handler = unhandled,
            reserved56: [1]u32 = undefined,
            ///  TIM8 and 12 break global
            TIM8_BRK_TIM12: Handler = unhandled,
            ///  TIM8 and 13 update global
            TIM8_UP_TIM13: Handler = unhandled,
            ///  TIM8 and 14 trigger /commutation and global
            TIM8_TRG_COM_TIM14: Handler = unhandled,
            ///  TIM8 capture / compare
            TIM8_CC: Handler = unhandled,
            ///  DMA1 Stream7
            DMA1_STR7: Handler = unhandled,
            ///  FMC global interrupt
            FMC: Handler = unhandled,
            ///  SDMMC global interrupt
            SDMMC1: Handler = unhandled,
            ///  TIM5 global interrupt
            TIM5: Handler = unhandled,
            ///  SPI3 global interrupt
            SPI3: Handler = unhandled,
            ///  UART4 global interrupt
            UART4: Handler = unhandled,
            ///  UART5 global interrupt
            UART5: Handler = unhandled,
            ///  TIM6 global interrupt
            TIM6_DAC: Handler = unhandled,
            ///  TIM7 global interrupt
            TIM7: Handler = unhandled,
            ///  DMA2 Stream0 interrupt
            DMA2_STR0: Handler = unhandled,
            ///  DMA2 Stream1 interrupt
            DMA2_STR1: Handler = unhandled,
            ///  DMA2 Stream2 interrupt
            DMA2_STR2: Handler = unhandled,
            ///  DMA2 Stream3 interrupt
            DMA2_STR3: Handler = unhandled,
            ///  DMA2 Stream4 interrupt
            DMA2_STR4: Handler = unhandled,
            ///  Ethernet global interrupt
            ETH: Handler = unhandled,
            ///  Ethernet wakeup through EXTI
            ETH_WKUP: Handler = unhandled,
            ///  CAN2TX interrupts
            FDCAN_CAL: Handler = unhandled,
            reserved78: [4]u32 = undefined,
            ///  DMA2 Stream5 interrupt
            DMA2_STR5: Handler = unhandled,
            ///  DMA2 Stream6 interrupt
            DMA2_STR6: Handler = unhandled,
            ///  DMA2 Stream7 interrupt
            DMA2_STR7: Handler = unhandled,
            ///  USART6 global interrupt
            USART6: Handler = unhandled,
            ///  I2C3 event interrupt
            I2C3_EV: Handler = unhandled,
            ///  I2C3 error interrupt
            I2C3_ER: Handler = unhandled,
            ///  OTG_HS out global interrupt
            OTG_HS_EP1_OUT: Handler = unhandled,
            ///  OTG_HS in global interrupt
            OTG_HS_EP1_IN: Handler = unhandled,
            ///  OTG_HS wakeup interrupt
            OTG_HS_WKUP: Handler = unhandled,
            ///  OTG_HS global interrupt
            OTG_HS: Handler = unhandled,
            ///  DCMI global interrupt
            DCMI: Handler = unhandled,
            ///  CRYP global interrupt
            CRYP: Handler = unhandled,
            ///  HASH and RNG
            HASH_RNG: Handler = unhandled,
            ///  Floating point unit interrupt
            FPU: Handler = unhandled,
            ///  UART7 global interrupt
            UART7: Handler = unhandled,
            ///  UART8 global interrupt
            UART8: Handler = unhandled,
            ///  SPI4 global interrupt
            SPI4: Handler = unhandled,
            ///  SPI5 global interrupt
            SPI5: Handler = unhandled,
            ///  SPI6 global interrupt
            SPI6: Handler = unhandled,
            ///  SAI1 global interrupt
            SAI1: Handler = unhandled,
            ///  LCD-TFT global interrupt
            LTDC: Handler = unhandled,
            ///  LCD-TFT error interrupt
            LTDC_ER: Handler = unhandled,
            ///  DMA2D global interrupt
            DMA2D: Handler = unhandled,
            ///  SAI2 global interrupt
            SAI2: Handler = unhandled,
            ///  QuadSPI global interrupt
            QUADSPI: Handler = unhandled,
            ///  LPTIM1 global interrupt
            LPTIM1: Handler = unhandled,
            ///  HDMI-CEC global interrupt
            CEC: Handler = unhandled,
            ///  I2C4 event interrupt
            I2C4_EV: Handler = unhandled,
            ///  I2C4 error interrupt
            I2C4_ER: Handler = unhandled,
            ///  SPDIFRX global interrupt
            SPDIF: Handler = unhandled,
            ///  OTG_FS out global interrupt
            OTG_FS_EP1_OUT: Handler = unhandled,
            ///  OTG_FS in global interrupt
            OTG_FS_EP1_IN: Handler = unhandled,
            ///  OTG_FS wakeup
            OTG_FS_WKUP: Handler = unhandled,
            ///  OTG_FS global interrupt
            OTG_FS: Handler = unhandled,
            ///  DMAMUX1 overrun interrupt
            DMAMUX1_OV: Handler = unhandled,
            ///  HRTIM1 master timer interrupt
            HRTIM1_MST: Handler = unhandled,
            ///  HRTIM1 timer A interrupt
            HRTIM1_TIMA: Handler = unhandled,
            ///  HRTIM1 timer B interrupt
            HRTIM_TIMB: Handler = unhandled,
            ///  HRTIM1 timer C interrupt
            HRTIM1_TIMC: Handler = unhandled,
            ///  HRTIM1 timer D interrupt
            HRTIM1_TIMD: Handler = unhandled,
            ///  HRTIM1 timer E interrupt
            HRTIM_TIME: Handler = unhandled,
            ///  HRTIM1 fault interrupt
            HRTIM1_FLT: Handler = unhandled,
            ///  DFSDM1 filter 0 interrupt
            DFSDM1_FLT0: Handler = unhandled,
            ///  DFSDM1 filter 1 interrupt
            DFSDM1_FLT1: Handler = unhandled,
            ///  DFSDM1 filter 2 interrupt
            DFSDM1_FLT2: Handler = unhandled,
            ///  DFSDM1 filter 3 interrupt
            DFSDM1_FLT3: Handler = unhandled,
            ///  SAI3 global interrupt
            SAI3: Handler = unhandled,
            ///  SWPMI global interrupt
            SWPMI1: Handler = unhandled,
            ///  TIM15 global interrupt
            TIM15: Handler = unhandled,
            ///  TIM16 global interrupt
            TIM16: Handler = unhandled,
            ///  TIM17 global interrupt
            TIM17: Handler = unhandled,
            ///  MDIOS wakeup
            MDIOS_WKUP: Handler = unhandled,
            ///  MDIOS global interrupt
            MDIOS: Handler = unhandled,
            ///  JPEG global interrupt
            JPEG: Handler = unhandled,
            ///  MDMA
            MDMA: Handler = unhandled,
            reserved137: [1]u32 = undefined,
            ///  SDMMC global interrupt
            SDMMC: Handler = unhandled,
            ///  HSEM global interrupt 1
            HSEM0: Handler = unhandled,
            reserved140: [1]u32 = undefined,
            ///  ADC3 global interrupt
            ADC3: Handler = unhandled,
            ///  DMAMUX2 overrun interrupt
            DMAMUX2_OVR: Handler = unhandled,
            ///  BDMA channel 1 interrupt
            BDMA_CH1: Handler = unhandled,
            ///  BDMA channel 2 interrupt
            BDMA_CH2: Handler = unhandled,
            ///  BDMA channel 3 interrupt
            BDMA_CH3: Handler = unhandled,
            ///  BDMA channel 4 interrupt
            BDMA_CH4: Handler = unhandled,
            ///  BDMA channel 5 interrupt
            BDMA_CH5: Handler = unhandled,
            ///  BDMA channel 6 interrupt
            BDMA_CH6: Handler = unhandled,
            ///  BDMA channel 7 interrupt
            BDMA_CH7: Handler = unhandled,
            ///  BDMA channel 8 interrupt
            BDMA_CH8: Handler = unhandled,
            ///  COMP1 and COMP2
            COMP: Handler = unhandled,
            ///  LPTIM2 timer interrupt
            LPTIM2: Handler = unhandled,
            ///  LPTIM2 timer interrupt
            LPTIM3: Handler = unhandled,
            ///  LPTIM2 timer interrupt
            LPTIM4: Handler = unhandled,
            ///  LPTIM2 timer interrupt
            LPTIM5: Handler = unhandled,
            ///  LPUART global interrupt
            LPUART: Handler = unhandled,
            ///  Window Watchdog interrupt
            WWDG1_RST: Handler = unhandled,
            ///  Clock Recovery System globa
            CRS: Handler = unhandled,
            reserved159: [1]u32 = undefined,
            ///  SAI4 global interrupt
            SAI4: Handler = unhandled,
            reserved161: [2]u32 = undefined,
            ///  WKUP1 to WKUP6 pins
            WKUP: Handler = unhandled,
        };

        pub const peripherals = struct {
            ///  General purpose timers
            pub const TIM2 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40000000));
            ///  General purpose timers
            pub const TIM3 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40000400));
            ///  General purpose timers
            pub const TIM4 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40000800));
            ///  General purpose timers
            pub const TIM5 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40000c00));
            ///  Basic timers
            pub const TIM6 = @as(*volatile types.peripherals.TIM6, @ptrFromInt(0x40001000));
            ///  Basic timers
            pub const TIM7 = @as(*volatile types.peripherals.TIM6, @ptrFromInt(0x40001400));
            ///  General purpose timers
            pub const TIM12 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40001800));
            ///  General purpose timers
            pub const TIM13 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40001c00));
            ///  General purpose timers
            pub const TIM14 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40002000));
            ///  Low power timer
            pub const LPTIM1 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x40002400));
            ///  Serial peripheral interface
            pub const SPI2 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x40003800));
            ///  Serial peripheral interface
            pub const SPI3 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x40003c00));
            ///  Receiver Interface
            pub const SPDIFRX = @as(*volatile types.peripherals.SPDIFRX, @ptrFromInt(0x40004000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART2 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40004400));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART3 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40004800));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const UART4 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40004c00));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const UART5 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40005000));
            ///  I2C
            pub const I2C1 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40005400));
            ///  I2C
            pub const I2C2 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40005800));
            ///  I2C
            pub const I2C3 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40005c00));
            ///  CEC
            pub const CEC = @as(*volatile types.peripherals.CEC, @ptrFromInt(0x40006c00));
            ///  DAC
            pub const DAC = @as(*volatile types.peripherals.DAC, @ptrFromInt(0x40007400));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const UART7 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40007800));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const UART8 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40007c00));
            ///  CRS
            pub const CRS = @as(*volatile types.peripherals.CRS, @ptrFromInt(0x40008400));
            ///  Single Wire Protocol Master Interface
            pub const SWPMI = @as(*volatile types.peripherals.SWPMI, @ptrFromInt(0x40008800));
            ///  Operational amplifiers
            pub const OPAMP = @as(*volatile types.peripherals.OPAMP, @ptrFromInt(0x40009000));
            ///  Management data input/output slave
            pub const MDIOS = @as(*volatile types.peripherals.MDIOS, @ptrFromInt(0x40009400));
            ///  FDCAN1
            pub const FDCAN1 = @as(*volatile types.peripherals.FDCAN1, @ptrFromInt(0x4000a000));
            ///  FDCAN1
            pub const FDCAN2 = @as(*volatile types.peripherals.FDCAN1, @ptrFromInt(0x4000a400));
            ///  CCU registers
            pub const CAN_CCU = @as(*volatile types.peripherals.CAN_CCU, @ptrFromInt(0x4000a800));
            ///  Advanced-timers
            pub const TIM1 = @as(*volatile types.peripherals.TIM1, @ptrFromInt(0x40010000));
            ///  Advanced-timers
            pub const TIM8 = @as(*volatile types.peripherals.TIM1, @ptrFromInt(0x40010400));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART1 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40011000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART6 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40011400));
            ///  Serial peripheral interface
            pub const SPI1 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x40013000));
            ///  Serial peripheral interface
            pub const SPI4 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x40013400));
            ///  General purpose timers
            pub const TIM15 = @as(*volatile types.peripherals.TIM15, @ptrFromInt(0x40014000));
            ///  General-purpose-timers
            pub const TIM16 = @as(*volatile types.peripherals.TIM16, @ptrFromInt(0x40014400));
            ///  General-purpose-timers
            pub const TIM17 = @as(*volatile types.peripherals.TIM17, @ptrFromInt(0x40014800));
            ///  Serial peripheral interface
            pub const SPI5 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x40015000));
            ///  SAI
            pub const SAI1 = @as(*volatile types.peripherals.SAI4, @ptrFromInt(0x40015800));
            ///  SAI
            pub const SAI2 = @as(*volatile types.peripherals.SAI4, @ptrFromInt(0x40015c00));
            ///  SAI
            pub const SAI3 = @as(*volatile types.peripherals.SAI4, @ptrFromInt(0x40016000));
            ///  Digital filter for sigma delta modulators
            pub const DFSDM = @as(*volatile types.peripherals.DFSDM, @ptrFromInt(0x40017000));
            ///  High Resolution Timer: Master Timers
            pub const HRTIM_Master = @as(*volatile types.peripherals.HRTIM_Master, @ptrFromInt(0x40017400));
            ///  High Resolution Timer: TIMA
            pub const HRTIM_TIMA = @as(*volatile types.peripherals.HRTIM_TIMA, @ptrFromInt(0x40017480));
            ///  High Resolution Timer: TIMB
            pub const HRTIM_TIMB = @as(*volatile types.peripherals.HRTIM_TIMB, @ptrFromInt(0x40017500));
            ///  High Resolution Timer: TIMC
            pub const HRTIM_TIMC = @as(*volatile types.peripherals.HRTIM_TIMC, @ptrFromInt(0x40017580));
            ///  High Resolution Timer: TIMD
            pub const HRTIM_TIMD = @as(*volatile types.peripherals.HRTIM_TIMD, @ptrFromInt(0x40017600));
            ///  High Resolution Timer: TIME
            pub const HRTIM_TIME = @as(*volatile types.peripherals.HRTIM_TIME, @ptrFromInt(0x40017680));
            ///  High Resolution Timer: Common functions
            pub const HRTIM_Common = @as(*volatile types.peripherals.HRTIM_Common, @ptrFromInt(0x40017780));
            ///  DMA controller
            pub const DMA1 = @as(*volatile types.peripherals.DMA1, @ptrFromInt(0x40020000));
            ///  DMA controller
            pub const DMA2 = @as(*volatile types.peripherals.DMA1, @ptrFromInt(0x40020400));
            ///  DMAMUX
            pub const DMAMUX1 = @as(*volatile types.peripherals.DMAMUX1, @ptrFromInt(0x40020800));
            ///  Analog to Digital Converter
            pub const ADC1 = @as(*volatile types.peripherals.ADC3, @ptrFromInt(0x40022000));
            ///  Analog to Digital Converter
            pub const ADC2 = @as(*volatile types.peripherals.ADC3, @ptrFromInt(0x40022100));
            ///  Analog-to-Digital Converter
            pub const ADC12_Common = @as(*volatile types.peripherals.ADC3_Common, @ptrFromInt(0x40022300));
            ///  Ethernet: media access control (MAC)
            pub const Ethernet_MAC = @as(*volatile types.peripherals.Ethernet_MAC, @ptrFromInt(0x40028000));
            ///  Ethernet: MTL mode register (MTL)
            pub const Ethernet_MTL = @as(*volatile types.peripherals.Ethernet_MTL, @ptrFromInt(0x40028c00));
            ///  Ethernet: DMA mode register (DMA)
            pub const Ethernet_DMA = @as(*volatile types.peripherals.Ethernet_DMA, @ptrFromInt(0x40029000));
            ///  USB 1 on the go high speed
            pub const OTG1_HS_GLOBAL = @as(*volatile types.peripherals.OTG1_HS_GLOBAL, @ptrFromInt(0x40040000));
            ///  USB 1 on the go high speed
            pub const OTG1_HS_HOST = @as(*volatile types.peripherals.OTG1_HS_HOST, @ptrFromInt(0x40040400));
            ///  USB 1 on the go high speed
            pub const OTG1_HS_DEVICE = @as(*volatile types.peripherals.OTG1_HS_DEVICE, @ptrFromInt(0x40040800));
            ///  USB 1 on the go high speed
            pub const OTG1_HS_PWRCLK = @as(*volatile types.peripherals.OTG1_HS_PWRCLK, @ptrFromInt(0x40040e00));
            ///  USB 1 on the go high speed
            pub const OTG2_HS_GLOBAL = @as(*volatile types.peripherals.OTG1_HS_GLOBAL, @ptrFromInt(0x40080000));
            ///  USB 1 on the go high speed
            pub const OTG2_HS_HOST = @as(*volatile types.peripherals.OTG1_HS_HOST, @ptrFromInt(0x40080400));
            ///  USB 1 on the go high speed
            pub const OTG2_HS_DEVICE = @as(*volatile types.peripherals.OTG1_HS_DEVICE, @ptrFromInt(0x40080800));
            ///  USB 1 on the go high speed
            pub const OTG2_HS_PWRCLK = @as(*volatile types.peripherals.OTG1_HS_PWRCLK, @ptrFromInt(0x40080e00));
            ///  Digital camera interface
            pub const DCMI = @as(*volatile types.peripherals.DCMI, @ptrFromInt(0x48020000));
            ///  Cryptographic processor
            pub const CRYP = @as(*volatile types.peripherals.CRYP, @ptrFromInt(0x48021000));
            ///  Hash processor
            pub const HASH = @as(*volatile types.peripherals.HASH, @ptrFromInt(0x48021400));
            ///  RNG
            pub const RNG = @as(*volatile types.peripherals.RNG, @ptrFromInt(0x48021800));
            ///  SDMMC1
            pub const SDMMC2 = @as(*volatile types.peripherals.SDMMC1, @ptrFromInt(0x48022400));
            ///  DELAY_Block_SDMMC1
            pub const DELAY_Block_SDMMC2 = @as(*volatile types.peripherals.DELAY_Block_SDMMC1, @ptrFromInt(0x48022800));
            ///  LCD-TFT Controller
            pub const LTDC = @as(*volatile types.peripherals.LTDC, @ptrFromInt(0x50001000));
            ///  WWDG
            pub const WWDG = @as(*volatile types.peripherals.WWDG, @ptrFromInt(0x50003000));
            ///  AXI interconnect registers
            pub const AXI = @as(*volatile types.peripherals.AXI, @ptrFromInt(0x51000000));
            ///  MDMA
            pub const MDMA = @as(*volatile types.peripherals.MDMA, @ptrFromInt(0x52000000));
            ///  DMA2D
            pub const DMA2D = @as(*volatile types.peripherals.DMA2D, @ptrFromInt(0x52001000));
            ///  Flash
            pub const Flash = @as(*volatile types.peripherals.Flash, @ptrFromInt(0x52002000));
            ///  JPEG
            pub const JPEG = @as(*volatile types.peripherals.JPEG, @ptrFromInt(0x52003000));
            ///  FMC
            pub const FMC = @as(*volatile types.peripherals.FMC, @ptrFromInt(0x52004000));
            ///  QUADSPI
            pub const QUADSPI = @as(*volatile types.peripherals.QUADSPI, @ptrFromInt(0x52005000));
            ///  DELAY_Block_SDMMC1
            pub const DELAY_Block_QUADSPI = @as(*volatile types.peripherals.DELAY_Block_SDMMC1, @ptrFromInt(0x52006000));
            ///  SDMMC1
            pub const SDMMC1 = @as(*volatile types.peripherals.SDMMC1, @ptrFromInt(0x52007000));
            ///  DELAY_Block_SDMMC1
            pub const DELAY_Block_SDMMC1 = @as(*volatile types.peripherals.DELAY_Block_SDMMC1, @ptrFromInt(0x52008000));
            ///  External interrupt/event controller
            pub const EXTI = @as(*volatile types.peripherals.EXTI, @ptrFromInt(0x58000000));
            ///  System configuration controller
            pub const SYSCFG = @as(*volatile types.peripherals.SYSCFG, @ptrFromInt(0x58000400));
            ///  LPUART1
            pub const LPUART1 = @as(*volatile types.peripherals.LPUART1, @ptrFromInt(0x58000c00));
            ///  Serial peripheral interface
            pub const SPI6 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x58001400));
            ///  I2C
            pub const I2C4 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x58001c00));
            ///  Low power timer
            pub const LPTIM2 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x58002400));
            ///  Low power timer
            pub const LPTIM3 = @as(*volatile types.peripherals.LPTIM3, @ptrFromInt(0x58002800));
            ///  Low power timer
            pub const LPTIM4 = @as(*volatile types.peripherals.LPTIM3, @ptrFromInt(0x58002c00));
            ///  Low power timer
            pub const LPTIM5 = @as(*volatile types.peripherals.LPTIM3, @ptrFromInt(0x58003000));
            ///  COMP1
            pub const COMP1 = @as(*volatile types.peripherals.COMP1, @ptrFromInt(0x58003800));
            ///  VREFBUF
            pub const VREFBUF = @as(*volatile types.peripherals.VREFBUF, @ptrFromInt(0x58003c00));
            ///  RTC
            pub const RTC = @as(*volatile types.peripherals.RTC, @ptrFromInt(0x58004000));
            ///  IWDG
            pub const IWDG = @as(*volatile types.peripherals.IWDG, @ptrFromInt(0x58004800));
            ///  SAI
            pub const SAI4 = @as(*volatile types.peripherals.SAI4, @ptrFromInt(0x58005400));
            ///  GPIO
            pub const GPIOA = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58020000));
            ///  GPIO
            pub const GPIOB = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58020400));
            ///  GPIO
            pub const GPIOC = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58020800));
            ///  GPIO
            pub const GPIOD = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58020c00));
            ///  GPIO
            pub const GPIOE = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58021000));
            ///  GPIO
            pub const GPIOF = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58021400));
            ///  GPIO
            pub const GPIOG = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58021800));
            ///  GPIO
            pub const GPIOH = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58021c00));
            ///  GPIO
            pub const GPIOI = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58022000));
            ///  GPIO
            pub const GPIOJ = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58022400));
            ///  GPIO
            pub const GPIOK = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x58022800));
            ///  Reset and clock control
            pub const RCC = @as(*volatile types.peripherals.RCC, @ptrFromInt(0x58024400));
            ///  PWR
            pub const PWR = @as(*volatile types.peripherals.PWR, @ptrFromInt(0x58024800));
            ///  Cryptographic processor
            pub const CRC = @as(*volatile types.peripherals.CRC, @ptrFromInt(0x58024c00));
            ///  BDMA
            pub const BDMA = @as(*volatile types.peripherals.BDMA, @ptrFromInt(0x58025400));
            ///  DMAMUX
            pub const DMAMUX2 = @as(*volatile types.peripherals.DMAMUX2, @ptrFromInt(0x58025800));
            ///  Analog to Digital Converter
            pub const ADC3 = @as(*volatile types.peripherals.ADC3, @ptrFromInt(0x58026000));
            ///  Analog-to-Digital Converter
            pub const ADC3_Common = @as(*volatile types.peripherals.ADC3_Common, @ptrFromInt(0x58026300));
            ///  HSEM
            pub const HSEM = @as(*volatile types.peripherals.HSEM, @ptrFromInt(0x58026400));
            ///  System control block ACTLR
            pub const SCB_ACTRL = @as(*volatile types.peripherals.SCB_ACTRL, @ptrFromInt(0xe000e008));
            ///  SysTick timer
            pub const STK = @as(*volatile types.peripherals.STK, @ptrFromInt(0xe000e010));
            ///  Nested Vectored Interrupt Controller
            pub const NVIC = @as(*volatile types.peripherals.NVIC, @ptrFromInt(0xe000e100));
            ///  System control block
            pub const SCB = @as(*volatile types.peripherals.SCB, @ptrFromInt(0xe000ed00));
            ///  Processor features
            pub const PF = @as(*volatile types.peripherals.PF, @ptrFromInt(0xe000ed78));
            ///  Floating point unit CPACR
            pub const FPU_CPACR = @as(*volatile types.peripherals.FPU_CPACR, @ptrFromInt(0xe000ed88));
            ///  Memory protection unit
            pub const MPU = @as(*volatile types.peripherals.MPU, @ptrFromInt(0xe000ed90));
            ///  Nested vectored interrupt controller
            pub const NVIC_STIR = @as(*volatile types.peripherals.NVIC_STIR, @ptrFromInt(0xe000ef00));
            ///  Floting point unit
            pub const FPU = @as(*volatile types.peripherals.FPU, @ptrFromInt(0xe000ef34));
            ///  Access control
            pub const AC = @as(*volatile types.peripherals.AC, @ptrFromInt(0xe000ef90));
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        ///  COMP1
        pub const COMP1 = extern struct {
            ///  Comparator status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  COMP channel 1 output status bit
                C1VAL: u1,
                ///  COMP channel 2 output status bit
                C2VAL: u1,
                reserved16: u14,
                ///  COMP channel 1 Interrupt Flag
                C1IF: u1,
                ///  COMP channel 2 Interrupt Flag
                C2IF: u1,
                padding: u14,
            }),
            ///  Comparator interrupt clear flag register
            ICFR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Clear COMP channel 1 Interrupt Flag
                CC1IF: u1,
                ///  Clear COMP channel 2 Interrupt Flag
                CC2IF: u1,
                padding: u14,
            }),
            ///  Comparator option register
            OR: mmio.Mmio(packed struct(u32) {
                ///  Selection of source for alternate function of output ports
                AFOP: u11,
                ///  Option Register
                OR: u21,
            }),
            ///  Comparator configuration register 1
            CFGR1: mmio.Mmio(packed struct(u32) {
                ///  COMP channel 1 enable bit
                EN: u1,
                ///  Scaler bridge enable
                BRGEN: u1,
                ///  Voltage scaler enable bit
                SCALEN: u1,
                ///  COMP channel 1 polarity selection bit
                POLARITY: u1,
                reserved6: u2,
                ///  COMP channel 1 interrupt enable
                ITEN: u1,
                reserved8: u1,
                ///  COMP channel 1 hysteresis selection bits
                HYST: u2,
                reserved12: u2,
                ///  Power Mode of the COMP channel 1
                PWRMODE: u2,
                reserved16: u2,
                ///  COMP channel 1 inverting input selection field
                INMSEL: u3,
                reserved20: u1,
                ///  COMP channel 1 non-inverting input selection bit
                INPSEL: u1,
                reserved24: u3,
                ///  COMP channel 1 blanking source selection bits
                BLANKING: u4,
                reserved31: u3,
                ///  Lock bit
                LOCK: u1,
            }),
            ///  Comparator configuration register 2
            CFGR2: mmio.Mmio(packed struct(u32) {
                ///  COMP channel 1 enable bit
                EN: u1,
                ///  Scaler bridge enable
                BRGEN: u1,
                ///  Voltage scaler enable bit
                SCALEN: u1,
                ///  COMP channel 1 polarity selection bit
                POLARITY: u1,
                ///  Window comparator mode selection bit
                WINMODE: u1,
                reserved6: u1,
                ///  COMP channel 1 interrupt enable
                ITEN: u1,
                reserved8: u1,
                ///  COMP channel 1 hysteresis selection bits
                HYST: u2,
                reserved12: u2,
                ///  Power Mode of the COMP channel 1
                PWRMODE: u2,
                reserved16: u2,
                ///  COMP channel 1 inverting input selection field
                INMSEL: u3,
                reserved20: u1,
                ///  COMP channel 1 non-inverting input selection bit
                INPSEL: u1,
                reserved24: u3,
                ///  COMP channel 1 blanking source selection bits
                BLANKING: u4,
                reserved31: u3,
                ///  Lock bit
                LOCK: u1,
            }),
        };

        ///  CRS
        pub const CRS = extern struct {
            ///  CRS control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK interrupt enable
                SYNCOKIE: u1,
                ///  SYNC warning interrupt enable
                SYNCWARNIE: u1,
                ///  Synchronization or trimming error interrupt enable
                ERRIE: u1,
                ///  Expected SYNC interrupt enable
                ESYNCIE: u1,
                reserved5: u1,
                ///  Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
                CEN: u1,
                ///  Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
                AUTOTRIMEN: u1,
                ///  Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
                SWSYNC: u1,
                ///  HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
                TRIM: u6,
                padding: u18,
            }),
            ///  This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
                RELOAD: u16,
                ///  Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
                FELIM: u8,
                ///  SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
                SYNCDIV: u3,
                reserved28: u1,
                ///  SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
                SYNCSRC: u2,
                reserved31: u1,
                ///  SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
                SYNCPOL: u1,
            }),
            ///  CRS interrupt and status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
                SYNCOKF: u1,
                ///  SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
                SYNCWARNF: u1,
                ///  Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
                ERRF: u1,
                ///  Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
                ESYNCF: u1,
                reserved8: u4,
                ///  SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                SYNCERR: u1,
                ///  SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                SYNCMISS: u1,
                ///  Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                TRIMOVF: u1,
                reserved15: u4,
                ///  Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
                FEDIR: u1,
                ///  Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
                FECAP: u16,
            }),
            ///  CRS interrupt flag clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
                SYNCOKC: u1,
                ///  SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
                SYNCWARNC: u1,
                ///  Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
                ERRC: u1,
                ///  Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
                ESYNCC: u1,
                padding: u28,
            }),
        };

        ///  DAC
        pub const DAC = extern struct {
            ///  DAC control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
                EN1: u1,
                ///  DAC channel1 trigger enable
                TEN1: u1,
                ///  DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
                TSEL1: u3,
                reserved6: u1,
                ///  DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
                WAVE1: u2,
                ///  DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
                MAMP1: u4,
                ///  DAC channel1 DMA enable This bit is set and cleared by software.
                DMAEN1: u1,
                ///  DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
                DMAUDRIE1: u1,
                ///  DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
                CEN1: u1,
                reserved16: u1,
                ///  DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
                EN2: u1,
                ///  DAC channel2 trigger enable
                TEN2: u1,
                ///  DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
                TSEL2: u3,
                reserved22: u1,
                ///  DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
                WAVE2: u2,
                ///  DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
                MAMP2: u4,
                ///  DAC channel2 DMA enable This bit is set and cleared by software.
                DMAEN2: u1,
                ///  DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
                DMAUDRIE2: u1,
                ///  DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
                CEN2: u1,
                padding: u1,
            }),
            ///  DAC software trigger register
            SWTRGR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
                SWTRIG1: u1,
                ///  DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
                SWTRIG2: u1,
                padding: u30,
            }),
            ///  DAC channel1 12-bit right-aligned data holding register
            DHR12R1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
                DACC1DHR: u12,
                padding: u20,
            }),
            ///  DAC channel1 12-bit left aligned data holding register
            DHR12L1: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
                DACC1DHR: u12,
                padding: u16,
            }),
            ///  DAC channel1 8-bit right aligned data holding register
            DHR8R1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
                DACC1DHR: u8,
                padding: u24,
            }),
            ///  DAC channel2 12-bit right aligned data holding register
            DHR12R2: mmio.Mmio(packed struct(u32) {
                ///  DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
                DACC2DHR: u12,
                padding: u20,
            }),
            ///  DAC channel2 12-bit left aligned data holding register
            DHR12L2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
                DACC2DHR: u12,
                padding: u16,
            }),
            ///  DAC channel2 8-bit right-aligned data holding register
            DHR8R2: mmio.Mmio(packed struct(u32) {
                ///  DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
                DACC2DHR: u8,
                padding: u24,
            }),
            ///  Dual DAC 12-bit right-aligned data holding register
            DHR12RD: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
                DACC1DHR: u12,
                reserved16: u4,
                ///  DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
                DACC2DHR: u12,
                padding: u4,
            }),
            ///  DUAL DAC 12-bit left aligned data holding register
            DHR12LD: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
                DACC1DHR: u12,
                reserved20: u4,
                ///  DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
                DACC2DHR: u12,
            }),
            ///  DUAL DAC 8-bit right aligned data holding register
            DHR8RD: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
                DACC1DHR: u8,
                ///  DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
                DACC2DHR: u8,
                padding: u16,
            }),
            ///  DAC channel1 data output register
            DOR1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
                DACC1DOR: u12,
                padding: u20,
            }),
            ///  DAC channel2 data output register
            DOR2: mmio.Mmio(packed struct(u32) {
                ///  DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
                DACC2DOR: u12,
                padding: u20,
            }),
            ///  DAC status register
            SR: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                ///  DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
                DMAUDR1: u1,
                ///  DAC Channel 1 calibration offset status This bit is set and cleared by hardware
                CAL_FLAG1: u1,
                ///  DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
                BWST1: u1,
                reserved29: u13,
                ///  DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
                DMAUDR2: u1,
                ///  DAC Channel 2 calibration offset status This bit is set and cleared by hardware
                CAL_FLAG2: u1,
                ///  DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
                BWST2: u1,
            }),
            ///  DAC calibration control register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 1 offset trimming value
                OTRIM1: u5,
                reserved16: u11,
                ///  DAC Channel 2 offset trimming value
                OTRIM2: u5,
                padding: u11,
            }),
            ///  DAC mode control register
            MCR: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
                MODE1: u3,
                reserved16: u13,
                ///  DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
                MODE2: u3,
                padding: u13,
            }),
            ///  DAC Sample and Hold sample time register 1
            SHSR1: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
                TSAMPLE1: u10,
                padding: u22,
            }),
            ///  DAC Sample and Hold sample time register 2
            SHSR2: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
                TSAMPLE2: u10,
                padding: u22,
            }),
            ///  DAC Sample and Hold hold time register
            SHHR: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
                THOLD1: u10,
                reserved16: u6,
                ///  DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
                THOLD2: u10,
                padding: u6,
            }),
            ///  DAC Sample and Hold refresh time register
            SHRR: mmio.Mmio(packed struct(u32) {
                ///  DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
                TREFRESH1: u8,
                reserved16: u8,
                ///  DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
                TREFRESH2: u8,
                padding: u8,
            }),
        };

        ///  BDMA
        pub const BDMA = extern struct {
            ///  DMA interrupt status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF1: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF1: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF1: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF1: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF2: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF2: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF2: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF2: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF3: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF3: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF3: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF3: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF4: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF4: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF4: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF4: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF5: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF5: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF5: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF5: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF6: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF6: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF6: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF6: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF7: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF7: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF7: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF7: u1,
                ///  Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                GIF8: u1,
                ///  Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TCIF8: u1,
                ///  Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                HTIF8: u1,
                ///  Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
                TEIF8: u1,
            }),
            ///  DMA interrupt flag clear register
            IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF1: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF1: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF1: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF1: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF2: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF2: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF2: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF2: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF3: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF3: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF3: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF3: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF4: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF4: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF4: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF4: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF5: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF5: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF5: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF5: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF6: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF6: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF6: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF6: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF7: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF7: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF7: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF7: u1,
                ///  Channel x global interrupt clear This bit is set and cleared by software.
                CGIF8: u1,
                ///  Channel x transfer complete clear This bit is set and cleared by software.
                CTCIF8: u1,
                ///  Channel x half transfer clear This bit is set and cleared by software.
                CHTIF8: u1,
                ///  Channel x transfer error clear This bit is set and cleared by software.
                CTEIF8: u1,
            }),
            ///  DMA channel x configuration register
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR1: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR1: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved28: [4]u8,
            ///  DMA channel x configuration register
            CCR2: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR2: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR2: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR2: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved48: [4]u8,
            ///  DMA channel x configuration register
            CCR3: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR3: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR3: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR3: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved68: [4]u8,
            ///  DMA channel x configuration register
            CCR4: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR4: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR4: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR4: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved88: [4]u8,
            ///  DMA channel x configuration register
            CCR5: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR5: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR5: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR5: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved108: [4]u8,
            ///  DMA channel x configuration register
            CCR6: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR6: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR6: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR6: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved128: [4]u8,
            ///  DMA channel x configuration register
            CCR7: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR7: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR7: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR7: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
            reserved148: [4]u8,
            ///  DMA channel x configuration register
            CCR8: mmio.Mmio(packed struct(u32) {
                ///  Channel enable This bit is set and cleared by software.
                EN: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Half transfer interrupt enable This bit is set and cleared by software.
                HTIE: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Data transfer direction This bit is set and cleared by software.
                DIR: u1,
                ///  Circular mode This bit is set and cleared by software.
                CIRC: u1,
                ///  Peripheral increment mode This bit is set and cleared by software.
                PINC: u1,
                ///  Memory increment mode This bit is set and cleared by software.
                MINC: u1,
                ///  Peripheral size These bits are set and cleared by software.
                PSIZE: u2,
                ///  Memory size These bits are set and cleared by software.
                MSIZE: u2,
                ///  Channel priority level These bits are set and cleared by software.
                PL: u2,
                ///  Memory to memory mode This bit is set and cleared by software.
                MEM2MEM: u1,
                padding: u17,
            }),
            ///  DMA channel x number of data register
            CNDTR8: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
                NDT: u16,
                padding: u16,
            }),
            ///  This register must not be written when the channel is enabled.
            CPAR8: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
                PA: u32,
            }),
            ///  This register must not be written when the channel is enabled.
            CMAR8: mmio.Mmio(packed struct(u32) {
                ///  Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
                MA: u32,
            }),
        };

        ///  DMA2D
        pub const DMA2D = extern struct {
            ///  DMA2D control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Start This bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers
                START: u1,
                ///  Suspend This bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset.
                SUSP: u1,
                ///  Abort This bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset.
                ABORT: u1,
                reserved8: u5,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Transfer complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Transfer watermark interrupt enable This bit is set and cleared by software.
                TWIE: u1,
                ///  CLUT access error interrupt enable This bit is set and cleared by software.
                CAEIE: u1,
                ///  CLUT transfer complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Configuration Error Interrupt Enable This bit is set and cleared by software.
                CEIE: u1,
                reserved16: u2,
                ///  DMA2D mode This bit is set and cleared by software. It cannot be modified while a transfer is ongoing.
                MODE: u2,
                padding: u14,
            }),
            ///  DMA2D Interrupt Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Transfer error interrupt flag This bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading).
                TEIF: u1,
                ///  Transfer complete interrupt flag This bit is set when a DMA2D transfer operation is complete (data transfer only).
                TCIF: u1,
                ///  Transfer watermark interrupt flag This bit is set when the last pixel of the watermarked line has been transferred.
                TWIF: u1,
                ///  CLUT access error interrupt flag This bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D.
                CAEIF: u1,
                ///  CLUT transfer complete interrupt flag This bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete.
                CTCIF: u1,
                ///  Configuration error interrupt flag This bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed.
                CEIF: u1,
                padding: u26,
            }),
            ///  DMA2D interrupt flag clear register
            IFCR: mmio.Mmio(packed struct(u32) {
                ///  Clear Transfer error interrupt flag Programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register
                CTEIF: u1,
                ///  Clear transfer complete interrupt flag Programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register
                CTCIF: u1,
                ///  Clear transfer watermark interrupt flag Programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register
                CTWIF: u1,
                ///  Clear CLUT access error interrupt flag Programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register
                CAECIF: u1,
                ///  Clear CLUT transfer complete interrupt flag Programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register
                CCTCIF: u1,
                ///  Clear configuration error interrupt flag Programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register
                CCEIF: u1,
                padding: u26,
            }),
            ///  DMA2D foreground memory address register
            FGMAR: mmio.Mmio(packed struct(u32) {
                ///  Memory address Address of the data used for the foreground image. This register can only be written when data transfers are disabled. Once the data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
                MA: u32,
            }),
            ///  DMA2D foreground offset register
            FGOR: mmio.Mmio(packed struct(u32) {
                ///  Line offset Line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
                LO: u14,
                padding: u18,
            }),
            ///  DMA2D background memory address register
            BGMAR: mmio.Mmio(packed struct(u32) {
                ///  Memory address Address of the data used for the background image. This register can only be written when data transfers are disabled. Once a data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
                MA: u32,
            }),
            ///  DMA2D background offset register
            BGOR: mmio.Mmio(packed struct(u32) {
                ///  Line offset Line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
                LO: u14,
                padding: u18,
            }),
            ///  DMA2D foreground PFC control register
            FGPFCCR: mmio.Mmio(packed struct(u32) {
                ///  Color mode These bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
                CM: u4,
                ///  CLUT color mode This bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
                CCM: u1,
                ///  Start This bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer).
                START: u1,
                reserved8: u2,
                ///  CLUT size These bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
                CS: u8,
                ///  Alpha mode These bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. other configurations are meaningless
                AM: u2,
                ///  Chroma Sub-Sampling These bits define the chroma sub-sampling mode for YCbCr color mode. Once the transfer has started, these bits are read-only. others: meaningless
                CSS: u2,
                ///  Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
                AI: u1,
                ///  Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
                RBS: u1,
                reserved24: u2,
                ///  Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only.
                ALPHA: u8,
            }),
            ///  DMA2D foreground color register
            FGCOLR: mmio.Mmio(packed struct(u32) {
                ///  Blue Value These bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
                BLUE: u8,
                ///  Green Value These bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
                GREEN: u8,
                ///  Red Value These bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                RED: u8,
                padding: u8,
            }),
            ///  DMA2D background PFC control register
            BGPFCCR: mmio.Mmio(packed struct(u32) {
                ///  Color mode These bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
                CM: u4,
                ///  CLUT Color mode These bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
                CCM: u1,
                ///  Start This bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic BackGround CLUT transfer).
                START: u1,
                reserved8: u2,
                ///  CLUT size These bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
                CS: u8,
                ///  Alpha mode These bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
                AM: u2,
                reserved20: u2,
                ///  Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
                AI: u1,
                ///  Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
                RBS: u1,
                reserved24: u2,
                ///  Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                ALPHA: u8,
            }),
            ///  DMA2D background color register
            BGCOLR: mmio.Mmio(packed struct(u32) {
                ///  Blue Value These bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                BLUE: u8,
                ///  Green Value These bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                GREEN: u8,
                ///  Red Value These bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                RED: u8,
                padding: u8,
            }),
            ///  DMA2D foreground CLUT memory address register
            FGCMAR: mmio.Mmio(packed struct(u32) {
                ///  Memory Address Address of the data used for the CLUT address dedicated to the foreground image. This register can only be written when no transfer is ongoing. Once the CLUT transfer has started, this register is read-only. If the foreground CLUT format is 32-bit, the address must be 32-bit aligned.
                MA: u32,
            }),
            ///  DMA2D background CLUT memory address register
            BGCMAR: mmio.Mmio(packed struct(u32) {
                ///  Memory address Address of the data used for the CLUT address dedicated to the background image. This register can only be written when no transfer is on going. Once the CLUT transfer has started, this register is read-only. If the background CLUT format is 32-bit, the address must be 32-bit aligned.
                MA: u32,
            }),
            ///  DMA2D output PFC control register
            OPFCCR: mmio.Mmio(packed struct(u32) {
                ///  Color mode These bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
                CM: u3,
                reserved20: u17,
                ///  Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
                AI: u1,
                ///  Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
                RBS: u1,
                padding: u10,
            }),
            ///  DMA2D output color register
            OCOLR: mmio.Mmio(packed struct(u32) {
                ///  Blue Value These bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                BLUE: u8,
                ///  Green Value These bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                GREEN: u8,
                ///  Red Value These bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                RED: u8,
                ///  Alpha Channel Value These bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                ALPHA: u8,
            }),
            ///  DMA2D output memory address register
            OMAR: mmio.Mmio(packed struct(u32) {
                ///  Memory Address Address of the data used for the output FIFO. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned and a 16-bit per pixel format must be 16-bit aligned.
                MA: u32,
            }),
            ///  DMA2D output offset register
            OOR: mmio.Mmio(packed struct(u32) {
                ///  Line Offset Line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                LO: u14,
                padding: u18,
            }),
            ///  DMA2D number of line register
            NLR: mmio.Mmio(packed struct(u32) {
                ///  Number of lines Number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                NL: u16,
                ///  Pixel per lines Number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even.
                PL: u14,
                padding: u2,
            }),
            ///  DMA2D line watermark register
            LWR: mmio.Mmio(packed struct(u32) {
                ///  Line watermark These bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
                LW: u16,
                padding: u16,
            }),
            ///  DMA2D AXI master timer configuration register
            AMTCR: mmio.Mmio(packed struct(u32) {
                ///  Enable Enables the dead time functionality.
                EN: u1,
                reserved8: u7,
                ///  Dead Time Dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses.
                DT: u8,
                padding: u16,
            }),
        };

        ///  DMAMUX
        pub const DMAMUX2 = extern struct {
            ///  DMAMux - DMA request line multiplexer channel x control register
            C0CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C1CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C2CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C3CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C4CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C5CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C6CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C7CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            reserved128: [96]u8,
            ///  DMAMUX request line multiplexer interrupt channel status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  Synchronization overrun event flag
                SOF: u16,
                padding: u16,
            }),
            ///  DMAMUX request line multiplexer interrupt clear flag register
            CFR: mmio.Mmio(packed struct(u32) {
                ///  Clear synchronization overrun event flag
                CSOF: u16,
                padding: u16,
            }),
            reserved256: [120]u8,
            ///  DMAMux - DMA request generator channel x control register
            RG0CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG1CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG2CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG3CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG4CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG5CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG6CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG7CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            reserved320: [32]u8,
            ///  DMAMux - DMA request generator status register
            RGSR: mmio.Mmio(packed struct(u32) {
                ///  Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
                OF: u8,
                padding: u24,
            }),
            ///  DMAMux - DMA request generator clear flag register
            RGCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
                COF: u8,
                padding: u24,
            }),
        };

        ///  FMC
        pub const FMC = extern struct {
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
            BCR1: mmio.Mmio(packed struct(u32) {
                ///  Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
                MBKEN: u1,
                ///  Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
                MUXEN: u1,
                ///  Memory type These bits define the type of external memory attached to the corresponding memory bank:
                MTYP: u2,
                ///  Memory data bus width Defines the external memory device width, valid for all type of memories.
                MWID: u2,
                ///  Flash access enable This bit enables NOR Flash memory access operations.
                FACCEN: u1,
                reserved8: u1,
                ///  Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
                BURSTEN: u1,
                ///  Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
                WAITPOL: u1,
                reserved11: u1,
                ///  Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
                WAITCFG: u1,
                ///  Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
                WREN: u1,
                ///  Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
                WAITEN: u1,
                ///  Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
                EXTMOD: u1,
                ///  Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
                ASYNCWAIT: u1,
                ///  CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
                CPSIZE: u3,
                ///  Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
                CBURSTRW: u1,
                ///  Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
                CCLKEN: u1,
                ///  Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                WFDIS: u1,
                reserved24: u2,
                ///  FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
                BMAP: u2,
                reserved31: u5,
                ///  FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            BTR1: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
                ADDSET: u4,
                ///  Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
                BUSTURN: u4,
                ///  Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
                CLKDIV: u4,
                ///  Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
                DATLAT: u4,
                ///  Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
            BCR2: mmio.Mmio(packed struct(u32) {
                ///  Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
                MBKEN: u1,
                ///  Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
                MUXEN: u1,
                ///  Memory type These bits define the type of external memory attached to the corresponding memory bank:
                MTYP: u2,
                ///  Memory data bus width Defines the external memory device width, valid for all type of memories.
                MWID: u2,
                ///  Flash access enable This bit enables NOR Flash memory access operations.
                FACCEN: u1,
                reserved8: u1,
                ///  Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
                BURSTEN: u1,
                ///  Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
                WAITPOL: u1,
                reserved11: u1,
                ///  Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
                WAITCFG: u1,
                ///  Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
                WREN: u1,
                ///  Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
                WAITEN: u1,
                ///  Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
                EXTMOD: u1,
                ///  Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
                ASYNCWAIT: u1,
                ///  CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
                CPSIZE: u3,
                ///  Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
                CBURSTRW: u1,
                ///  Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
                CCLKEN: u1,
                ///  Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                WFDIS: u1,
                reserved24: u2,
                ///  FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
                BMAP: u2,
                reserved31: u5,
                ///  FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            BTR2: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
                ADDSET: u4,
                ///  Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ...
                BUSTURN: u4,
                ///  Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
                CLKDIV: u4,
                ///  Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
                DATLAT: u4,
                ///  Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
            BCR3: mmio.Mmio(packed struct(u32) {
                ///  Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
                MBKEN: u1,
                ///  Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
                MUXEN: u1,
                ///  Memory type These bits define the type of external memory attached to the corresponding memory bank:
                MTYP: u2,
                ///  Memory data bus width Defines the external memory device width, valid for all type of memories.
                MWID: u2,
                ///  Flash access enable This bit enables NOR Flash memory access operations.
                FACCEN: u1,
                reserved8: u1,
                ///  Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
                BURSTEN: u1,
                ///  Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
                WAITPOL: u1,
                reserved11: u1,
                ///  Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
                WAITCFG: u1,
                ///  Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
                WREN: u1,
                ///  Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
                WAITEN: u1,
                ///  Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
                EXTMOD: u1,
                ///  Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
                ASYNCWAIT: u1,
                ///  CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
                CPSIZE: u3,
                ///  Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
                CBURSTRW: u1,
                ///  Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
                CCLKEN: u1,
                ///  Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                WFDIS: u1,
                reserved24: u2,
                ///  FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
                BMAP: u2,
                reserved31: u5,
                ///  FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            BTR3: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
                ADDSET: u4,
                ///  Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
                BUSTURN: u4,
                ///  Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
                CLKDIV: u4,
                ///  Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
                DATLAT: u4,
                ///  Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
            BCR4: mmio.Mmio(packed struct(u32) {
                ///  Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
                MBKEN: u1,
                ///  Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
                MUXEN: u1,
                ///  Memory type These bits define the type of external memory attached to the corresponding memory bank:
                MTYP: u2,
                ///  Memory data bus width Defines the external memory device width, valid for all type of memories.
                MWID: u2,
                ///  Flash access enable This bit enables NOR Flash memory access operations.
                FACCEN: u1,
                reserved8: u1,
                ///  Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
                BURSTEN: u1,
                ///  Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
                WAITPOL: u1,
                reserved11: u1,
                ///  Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
                WAITCFG: u1,
                ///  Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
                WREN: u1,
                ///  Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
                WAITEN: u1,
                ///  Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
                EXTMOD: u1,
                ///  Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
                ASYNCWAIT: u1,
                ///  CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
                CPSIZE: u3,
                ///  Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
                CBURSTRW: u1,
                ///  Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
                CCLKEN: u1,
                ///  Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                WFDIS: u1,
                reserved24: u2,
                ///  FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
                BMAP: u2,
                reserved31: u5,
                ///  FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            BTR4: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
                ADDSET: u4,
                ///  Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
                BUSTURN: u4,
                ///  Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
                CLKDIV: u4,
                ///  Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
                DATLAT: u4,
                ///  Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            reserved128: [96]u8,
            ///  NAND Flash control registers
            PCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
                PWAITEN: u1,
                ///  NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
                PBKEN: u1,
                reserved4: u1,
                ///  Data bus width. These bits define the external memory device width.
                PWID: u2,
                ///  ECC computation logic enable bit
                ECCEN: u1,
                reserved9: u2,
                ///  CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
                TCLR: u4,
                ///  ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
                TAR: u4,
                ///  ECC page size. These bits define the page size for the extended ECC:
                ECCPS: u3,
                padding: u12,
            }),
            ///  This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
            SR: mmio.Mmio(packed struct(u32) {
                ///  Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
                IRS: u1,
                ///  Interrupt high-level status The flag is set by hardware and reset by software.
                ILS: u1,
                ///  Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
                IFS: u1,
                ///  Interrupt rising edge detection enable bit
                IREN: u1,
                ///  Interrupt high-level detection enable bit
                ILEN: u1,
                ///  Interrupt falling edge detection enable bit
                IFEN: u1,
                ///  FIFO empty. Read-only bit that provides the status of the FIFO
                FEMPT: u1,
                padding: u25,
            }),
            ///  The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
            PMEM: mmio.Mmio(packed struct(u32) {
                ///  Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
                MEMSET: u8,
                ///  Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
                MEMWAIT: u8,
                ///  Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
                MEMHOLD: u8,
                ///  Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
                MEMHIZ: u8,
            }),
            ///  The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
            PATT: mmio.Mmio(packed struct(u32) {
                ///  Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
                ATTSET: u8,
                ///  Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
                ATTWAIT: u8,
                ///  Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
                ATTHOLD: u8,
                ///  Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
                ATTHIZ: u8,
            }),
            reserved148: [4]u8,
            ///  This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
            ECCR: mmio.Mmio(packed struct(u32) {
                ///  ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
                ECC: u32,
            }),
            reserved260: [108]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            BWTR1: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
                ADDSET: u4,
                ///  Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
                BUSTURN: u4,
                reserved28: u8,
                ///  Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            reserved268: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            BWTR2: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
                ADDSET: u4,
                ///  Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
                BUSTURN: u4,
                reserved28: u8,
                ///  Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            reserved276: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            BWTR3: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
                ADDSET: u4,
                ///  Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
                BUSTURN: u4,
                reserved28: u8,
                ///  Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            reserved284: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            BWTR4: mmio.Mmio(packed struct(u32) {
                ///  Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
                ADDSET: u4,
                ///  Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
                ADDHLD: u4,
                ///  Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
                DATAST: u8,
                ///  Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
                BUSTURN: u4,
                reserved28: u8,
                ///  Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
                ACCMOD: u2,
                padding: u2,
            }),
            reserved320: [32]u8,
            ///  This register contains the control parameters for each SDRAM memory bank
            SDCR1: mmio.Mmio(packed struct(u32) {
                ///  Number of column address bits These bits define the number of bits of a column address.
                NC: u2,
                ///  Number of row address bits These bits define the number of bits of a row address.
                NR: u2,
                ///  Memory data bus width. These bits define the memory device width.
                MWID: u2,
                ///  Number of internal banks This bit sets the number of internal banks.
                NB: u1,
                ///  CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
                CAS: u2,
                ///  Write protection This bit enables write mode access to the SDRAM bank.
                WP: u1,
                ///  SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
                SDCLK: u2,
                ///  Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
                RBURST: u1,
                ///  Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
                RPIPE: u2,
                padding: u17,
            }),
            ///  This register contains the control parameters for each SDRAM memory bank
            SDCR2: mmio.Mmio(packed struct(u32) {
                ///  Number of column address bits These bits define the number of bits of a column address.
                NC: u2,
                ///  Number of row address bits These bits define the number of bits of a row address.
                NR: u2,
                ///  Memory data bus width. These bits define the memory device width.
                MWID: u2,
                ///  Number of internal banks This bit sets the number of internal banks.
                NB: u1,
                ///  CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
                CAS: u2,
                ///  Write protection This bit enables write mode access to the SDRAM bank.
                WP: u1,
                ///  SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
                SDCLK: u2,
                ///  Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
                RBURST: u1,
                ///  Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
                RPIPE: u2,
                padding: u17,
            }),
            ///  This register contains the timing parameters of each SDRAM bank
            SDTR1: mmio.Mmio(packed struct(u32) {
                ///  Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
                TMRD: u4,
                ///  Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
                TXSR: u4,
                ///  Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
                TRAS: u4,
                ///  Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
                TRC: u4,
                ///  Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
                TWR: u4,
                ///  Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
                TRP: u4,
                ///  Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
                TRCD: u4,
                padding: u4,
            }),
            ///  This register contains the timing parameters of each SDRAM bank
            SDTR2: mmio.Mmio(packed struct(u32) {
                ///  Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
                TMRD: u4,
                ///  Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
                TXSR: u4,
                ///  Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
                TRAS: u4,
                ///  Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
                TRC: u4,
                ///  Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
                TWR: u4,
                ///  Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
                TRP: u4,
                ///  Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
                TRCD: u4,
                padding: u4,
            }),
            ///  This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
            SDCMR: mmio.Mmio(packed struct(u32) {
                ///  Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0.
                MODE: u3,
                ///  Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
                CTB2: u1,
                ///  Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
                CTB1: u1,
                ///  Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. ....
                NRFS: u4,
                ///  Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM.
                MRD: u14,
                padding: u9,
            }),
            ///  This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
            SDRTR: mmio.Mmio(packed struct(u32) {
                ///  Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register.
                CRE: u1,
                ///  Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20
                COUNT: u13,
                ///  RES Interrupt Enable
                REIE: u1,
                padding: u17,
            }),
            ///  SDRAM Status register
            SDSR: mmio.Mmio(packed struct(u32) {
                ///  Refresh error flag An interrupt is generated if REIE = 1 and RE = 1
                RE: u1,
                ///  Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1.
                MODES1: u2,
                ///  Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2.
                MODES2: u2,
                padding: u27,
            }),
        };

        ///  CEC
        pub const CEC = extern struct {
            ///  CEC control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
                CECEN: u1,
                ///  Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
                TXSOM: u1,
                ///  Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
                TXEOM: u1,
                padding: u29,
            }),
            ///  This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods
                SFT: u3,
                ///  Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
                RXTOL: u1,
                ///  Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
                BRESTP: u1,
                ///  Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
                BREGEN: u1,
                ///  Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
                LBPEGEN: u1,
                ///  Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
                BRDNOGEN: u1,
                ///  SFT Option Bit The SFTOPT bit is set and cleared by software.
                SFTOPT: u1,
                reserved16: u7,
                ///  Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
                OAR: u15,
                ///  Listen mode LSTN bit is set and cleared by software.
                LSTN: u1,
            }),
            ///  CEC Tx data register
            TXDR: mmio.Mmio(packed struct(u32) {
                ///  Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
                TXD: u8,
                padding: u24,
            }),
            ///  CEC Rx Data Register
            RXDR: mmio.Mmio(packed struct(u32) {
                ///  Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
                RXD: u8,
                padding: u24,
            }),
            ///  CEC Interrupt and Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
                RXBR: u1,
                ///  End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
                RXEND: u1,
                ///  Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
                RXOVR: u1,
                ///  Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
                BRE: u1,
                ///  Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
                SBPE: u1,
                ///  Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
                LBPE: u1,
                ///  Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
                RXACKE: u1,
                ///  Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
                ARBLST: u1,
                ///  Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
                TXBR: u1,
                ///  End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
                TXEND: u1,
                ///  Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
                TXUDR: u1,
                ///  Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
                TXERR: u1,
                ///  Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
                TXACKE: u1,
                padding: u19,
            }),
            ///  CEC interrupt enable register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
                RXBRIE: u1,
                ///  End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
                RXENDIE: u1,
                ///  Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
                RXOVRIE: u1,
                ///  Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
                BREIE: u1,
                ///  Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
                SBPEIE: u1,
                ///  Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
                LBPEIE: u1,
                ///  Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
                RXACKIE: u1,
                ///  Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
                ARBLSTIE: u1,
                ///  Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
                TXBRIE: u1,
                ///  Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
                TXENDIE: u1,
                ///  Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
                TXUDRIE: u1,
                ///  Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
                TXERRIE: u1,
                ///  Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
                TXACKIE: u1,
                padding: u19,
            }),
        };

        ///  HSEM
        pub const HSEM = extern struct {
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R0: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R1: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R2: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R3: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R4: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R5: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R6: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R7: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R8: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R9: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R10: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R11: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R12: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R13: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R14: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R15: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R16: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R17: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R18: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R19: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R20: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R21: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R22: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R23: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R24: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R25: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R26: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R27: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R28: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R29: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R30: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM register HSEM_R0 HSEM_R31
            HSEM_R31: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR0: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR1: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR2: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR3: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR4: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR5: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR6: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR7: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR8: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR9: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR10: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR11: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR12: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR13: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR14: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR15: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR16: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR17: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR18: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR19: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR20: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR21: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR22: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR23: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR24: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR25: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR26: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR27: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR28: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR29: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR30: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Read lock register
            HSEM_RLR31: mmio.Mmio(packed struct(u32) {
                ///  Semaphore ProcessID
                PROCID: u8,
                ///  Semaphore MasterID
                MASTERID: u8,
                reserved31: u15,
                ///  Lock indication
                LOCK: u1,
            }),
            ///  HSEM Interrupt enable register
            HSEM_IER: mmio.Mmio(packed struct(u32) {
                ///  Interrupt semaphore n enable bit
                ISEM0: u1,
                ///  Interrupt semaphore n enable bit
                ISEM1: u1,
                ///  Interrupt semaphore n enable bit
                ISEM2: u1,
                ///  Interrupt semaphore n enable bit
                ISEM3: u1,
                ///  Interrupt semaphore n enable bit
                ISEM4: u1,
                ///  Interrupt semaphore n enable bit
                ISEM5: u1,
                ///  Interrupt semaphore n enable bit
                ISEM6: u1,
                ///  Interrupt semaphore n enable bit
                ISEM7: u1,
                ///  Interrupt semaphore n enable bit
                ISEM8: u1,
                ///  Interrupt semaphore n enable bit
                ISEM9: u1,
                ///  Interrupt semaphore n enable bit
                ISEM10: u1,
                ///  Interrupt semaphore n enable bit
                ISEM11: u1,
                ///  Interrupt semaphore n enable bit
                ISEM12: u1,
                ///  Interrupt semaphore n enable bit
                ISEM13: u1,
                ///  Interrupt semaphore n enable bit
                ISEM14: u1,
                ///  Interrupt semaphore n enable bit
                ISEM15: u1,
                ///  Interrupt semaphore n enable bit
                ISEM16: u1,
                ///  Interrupt semaphore n enable bit
                ISEM17: u1,
                ///  Interrupt semaphore n enable bit
                ISEM18: u1,
                ///  Interrupt semaphore n enable bit
                ISEM19: u1,
                ///  Interrupt semaphore n enable bit
                ISEM20: u1,
                ///  Interrupt semaphore n enable bit
                ISEM21: u1,
                ///  Interrupt semaphore n enable bit
                ISEM22: u1,
                ///  Interrupt semaphore n enable bit
                ISEM23: u1,
                ///  Interrupt semaphore n enable bit
                ISEM24: u1,
                ///  Interrupt semaphore n enable bit
                ISEM25: u1,
                ///  Interrupt semaphore n enable bit
                ISEM26: u1,
                ///  Interrupt semaphore n enable bit
                ISEM27: u1,
                ///  Interrupt semaphore n enable bit
                ISEM28: u1,
                ///  Interrupt semaphore n enable bit
                ISEM29: u1,
                ///  Interrupt semaphore n enable bit
                ISEM30: u1,
                ///  Interrupt(N) semaphore n enable bit.
                ISEM31: u1,
            }),
            ///  HSEM Interrupt clear register
            HSEM_ICR: mmio.Mmio(packed struct(u32) {
                ///  Interrupt(N) semaphore n clear bit
                ISEM0: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM1: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM2: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM3: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM4: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM5: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM6: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM7: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM8: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM9: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM10: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM11: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM12: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM13: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM14: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM15: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM16: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM17: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM18: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM19: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM20: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM21: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM22: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM23: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM24: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM25: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM26: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM27: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM28: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM29: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM30: u1,
                ///  Interrupt(N) semaphore n clear bit
                ISEM31: u1,
            }),
            ///  HSEM Interrupt status register
            HSEM_ISR: mmio.Mmio(packed struct(u32) {
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM0: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM1: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM2: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM3: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM4: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM5: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM6: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM7: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM8: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM9: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM10: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM11: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM12: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM13: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM14: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM15: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM16: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM17: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM18: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM19: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM20: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM21: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM22: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM23: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM24: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM25: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM26: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM27: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM28: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM29: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM30: u1,
                ///  Interrupt(N) semaphore n status bit before enable (mask)
                ISEM31: u1,
            }),
            ///  HSEM Masked interrupt status register
            HSEM_MISR: mmio.Mmio(packed struct(u32) {
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM0: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM1: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM2: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM3: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM4: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM5: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM6: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM7: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM8: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM9: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM10: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM11: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM12: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM13: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM14: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM15: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM16: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM17: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM18: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM19: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM20: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM21: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM22: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM23: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM24: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM25: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM26: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM27: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM28: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM29: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM30: u1,
                ///  masked interrupt(N) semaphore n status bit after enable (mask)
                ISEM31: u1,
            }),
            reserved320: [48]u8,
            ///  HSEM Clear register
            HSEM_CR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  MasterID of semaphores to be cleared
                MASTERID: u8,
                ///  Semaphore clear Key
                KEY: u16,
            }),
            ///  HSEM Interrupt clear register
            HSEM_KEYR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Semaphore Clear Key
                KEY: u16,
            }),
        };

        ///  I2C
        pub const I2C1 = extern struct {
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
                PE: u1,
                ///  TX Interrupt enable
                TXIE: u1,
                ///  RX Interrupt enable
                RXIE: u1,
                ///  Address match Interrupt enable (slave only)
                ADDRIE: u1,
                ///  Not acknowledge received Interrupt enable
                NACKIE: u1,
                ///  STOP detection Interrupt enable
                STOPIE: u1,
                ///  Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
                TCIE: u1,
                ///  Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
                ERRIE: u1,
                ///  Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
                DNF: u4,
                ///  Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
                ANFOFF: u1,
                reserved14: u1,
                ///  DMA transmission requests enable
                TXDMAEN: u1,
                ///  DMA reception requests enable
                RXDMAEN: u1,
                ///  Slave byte control This bit is used to enable hardware byte control in slave mode.
                SBC: u1,
                ///  Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
                NOSTRETCH: u1,
                ///  Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
                WUPEN: u1,
                ///  General call enable
                GCEN: u1,
                ///  SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                SMBHEN: u1,
                ///  SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                SMBDEN: u1,
                ///  SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                ALERTEN: u1,
                ///  PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                PECEN: u1,
                padding: u8,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
                SADD0: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD1: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD2: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD3: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD4: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD5: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD6: u1,
                ///  Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD7: u1,
                ///  Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
                SADD8: u1,
                ///  Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
                SADD9: u1,
                ///  Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
                RD_WRN: u1,
                ///  10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
                ADD10: u1,
                ///  10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
                HEAD10R: u1,
                ///  Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
                START: u1,
                ///  Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
                STOP: u1,
                ///  NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
                NACK: u1,
                ///  Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
                NBYTES: u8,
                ///  NBYTES reload mode This bit is set and cleared by software.
                RELOAD: u1,
                ///  Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
                AUTOEND: u1,
                ///  Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                PECBYTE: u1,
                padding: u5,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
            OAR1: mmio.Mmio(packed struct(u32) {
                ///  Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
                OA1: u10,
                ///  Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
                OA1MODE: u1,
                reserved15: u4,
                ///  Own Address 1 enable
                OA1EN: u1,
                padding: u16,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
            OAR2: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
                OA2: u7,
                ///  Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
                OA2MSK: u3,
                reserved15: u4,
                ///  Own Address 2 enable
                OA2EN: u1,
                padding: u16,
            }),
            ///  Access: No wait states
            TIMINGR: mmio.Mmio(packed struct(u32) {
                ///  SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
                SCLL: u8,
                ///  SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
                SCLH: u8,
                ///  Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
                SDADEL: u4,
                ///  Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
                SCLDEL: u4,
                reserved28: u4,
                ///  Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
                PRESC: u4,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
            TIMEOUTR: mmio.Mmio(packed struct(u32) {
                ///  Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
                TIMEOUTA: u12,
                ///  Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
                TIDLE: u1,
                reserved15: u2,
                ///  Clock timeout enable
                TIMOUTEN: u1,
                ///  Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
                TIMEOUTB: u12,
                reserved31: u3,
                ///  Extended clock timeout enable
                TEXTEN: u1,
            }),
            ///  Access: No wait states
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
                TXE: u1,
                ///  Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
                TXIS: u1,
                ///  Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
                RXNE: u1,
                ///  Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
                ADDR: u1,
                ///  Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
                NACKF: u1,
                ///  Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
                STOPF: u1,
                ///  Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
                TC: u1,
                ///  Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
                TCR: u1,
                ///  Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
                BERR: u1,
                ///  Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
                ARLO: u1,
                ///  Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
                OVR: u1,
                ///  PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                PECERR: u1,
                ///  Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                TIMEOUT: u1,
                ///  SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                ALERT: u1,
                reserved15: u1,
                ///  Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
                BUSY: u1,
                ///  Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
                DIR: u1,
                ///  Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
                ADDCODE: u7,
                padding: u8,
            }),
            ///  Access: No wait states
            ICR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
                ADDRCF: u1,
                ///  Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
                NACKCF: u1,
                ///  Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
                STOPCF: u1,
                reserved8: u2,
                ///  Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
                BERRCF: u1,
                ///  Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
                ARLOCF: u1,
                ///  Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
                OVRCF: u1,
                ///  PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                PECCF: u1,
                ///  Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                TIMOUTCF: u1,
                ///  Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
                ALERTCF: u1,
                padding: u18,
            }),
            ///  Access: No wait states
            PECR: mmio.Mmio(packed struct(u32) {
                ///  Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
                PEC: u8,
                padding: u24,
            }),
            ///  Access: No wait states
            RXDR: mmio.Mmio(packed struct(u32) {
                ///  8-bit receive data Data byte received from the I2C bus.
                RXDATA: u8,
                padding: u24,
            }),
            ///  Access: No wait states
            TXDR: mmio.Mmio(packed struct(u32) {
                ///  8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
                TXDATA: u8,
                padding: u24,
            }),
        };

        ///  Access control
        pub const AC = extern struct {
            ///  Instruction and Data Tightly-Coupled Memory Control Registers
            ITCMCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  RMW
                RMW: u1,
                ///  RETEN
                RETEN: u1,
                ///  SZ
                SZ: u4,
                padding: u25,
            }),
            ///  Instruction and Data Tightly-Coupled Memory Control Registers
            DTCMCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  RMW
                RMW: u1,
                ///  RETEN
                RETEN: u1,
                ///  SZ
                SZ: u4,
                padding: u25,
            }),
            ///  AHBP Control register
            AHBPCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  SZ
                SZ: u3,
                padding: u28,
            }),
            ///  Auxiliary Cache Control register
            CACR: mmio.Mmio(packed struct(u32) {
                ///  SIWT
                SIWT: u1,
                ///  ECCEN
                ECCEN: u1,
                ///  FORCEWT
                FORCEWT: u1,
                padding: u29,
            }),
            ///  AHB Slave Control register
            AHBSCR: mmio.Mmio(packed struct(u32) {
                ///  CTL
                CTL: u2,
                ///  TPRI
                TPRI: u9,
                ///  INITCOUNT
                INITCOUNT: u5,
                padding: u16,
            }),
            reserved24: [4]u8,
            ///  Auxiliary Bus Fault Status register
            ABFSR: mmio.Mmio(packed struct(u32) {
                ///  ITCM
                ITCM: u1,
                ///  DTCM
                DTCM: u1,
                ///  AHBP
                AHBP: u1,
                ///  AXIM
                AXIM: u1,
                ///  EPPB
                EPPB: u1,
                reserved8: u3,
                ///  AXIMTYPE
                AXIMTYPE: u2,
                padding: u22,
            }),
        };

        ///  Processor features
        pub const PF = extern struct {
            ///  Cache Level ID register
            CLIDR: mmio.Mmio(packed struct(u32) {
                ///  CL1
                CL1: u3,
                ///  CL2
                CL2: u3,
                ///  CL3
                CL3: u3,
                ///  CL4
                CL4: u3,
                ///  CL5
                CL5: u3,
                ///  CL6
                CL6: u3,
                ///  CL7
                CL7: u3,
                ///  LoUIS
                LoUIS: u3,
                ///  LoC
                LoC: u3,
                ///  LoU
                LoU: u3,
                padding: u2,
            }),
            ///  Cache Type register
            CTR: mmio.Mmio(packed struct(u32) {
                ///  IminLine
                _IminLine: u4,
                reserved16: u12,
                ///  DMinLine
                DMinLine: u4,
                ///  ERG
                ERG: u4,
                ///  CWG
                CWG: u4,
                reserved29: u1,
                ///  Format
                Format: u3,
            }),
            ///  Cache Size ID register
            CCSIDR: mmio.Mmio(packed struct(u32) {
                ///  LineSize
                LineSize: u3,
                ///  Associativity
                Associativity: u10,
                ///  NumSets
                NumSets: u15,
                ///  WA
                WA: u1,
                ///  RA
                RA: u1,
                ///  WB
                WB: u1,
                ///  WT
                WT: u1,
            }),
        };

        ///  System control block
        pub const SCB = extern struct {
            ///  CPUID base register
            CPUID: mmio.Mmio(packed struct(u32) {
                ///  Revision number
                Revision: u4,
                ///  Part number of the processor
                PartNo: u12,
                ///  Reads as 0xF
                Constant: u4,
                ///  Variant number
                Variant: u4,
                ///  Implementer code
                Implementer: u8,
            }),
            ///  Interrupt control and state register
            ICSR: mmio.Mmio(packed struct(u32) {
                ///  Active vector
                VECTACTIVE: u9,
                reserved11: u2,
                ///  Return to base level
                RETTOBASE: u1,
                ///  Pending vector
                VECTPENDING: u7,
                reserved22: u3,
                ///  Interrupt pending flag
                ISRPENDING: u1,
                reserved25: u2,
                ///  SysTick exception clear-pending bit
                PENDSTCLR: u1,
                ///  SysTick exception set-pending bit
                PENDSTSET: u1,
                ///  PendSV clear-pending bit
                PENDSVCLR: u1,
                ///  PendSV set-pending bit
                PENDSVSET: u1,
                reserved31: u2,
                ///  NMI set-pending bit.
                NMIPENDSET: u1,
            }),
            ///  Vector table offset register
            VTOR: mmio.Mmio(packed struct(u32) {
                reserved9: u9,
                ///  Vector table base offset field
                TBLOFF: u21,
                padding: u2,
            }),
            ///  Application interrupt and reset control register
            AIRCR: mmio.Mmio(packed struct(u32) {
                ///  VECTRESET
                VECTRESET: u1,
                ///  VECTCLRACTIVE
                VECTCLRACTIVE: u1,
                ///  SYSRESETREQ
                SYSRESETREQ: u1,
                reserved8: u5,
                ///  PRIGROUP
                PRIGROUP: u3,
                reserved15: u4,
                ///  ENDIANESS
                ENDIANESS: u1,
                ///  Register key
                VECTKEYSTAT: u16,
            }),
            ///  System control register
            SCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SLEEPONEXIT
                SLEEPONEXIT: u1,
                ///  SLEEPDEEP
                SLEEPDEEP: u1,
                reserved4: u1,
                ///  Send Event on Pending bit
                SEVEONPEND: u1,
                padding: u27,
            }),
            ///  Configuration and control register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  Configures how the processor enters Thread mode
                NONBASETHRDENA: u1,
                ///  USERSETMPEND
                USERSETMPEND: u1,
                reserved3: u1,
                ///  UNALIGN_ TRP
                UNALIGN__TRP: u1,
                ///  DIV_0_TRP
                DIV_0_TRP: u1,
                reserved8: u3,
                ///  BFHFNMIGN
                BFHFNMIGN: u1,
                ///  STKALIGN
                STKALIGN: u1,
                reserved16: u6,
                ///  DC
                DC: u1,
                ///  IC
                IC: u1,
                ///  BP
                BP: u1,
                padding: u13,
            }),
            ///  System handler priority registers
            SHPR1: mmio.Mmio(packed struct(u32) {
                ///  Priority of system handler 4
                PRI_4: u8,
                ///  Priority of system handler 5
                PRI_5: u8,
                ///  Priority of system handler 6
                PRI_6: u8,
                padding: u8,
            }),
            ///  System handler priority registers
            SHPR2: mmio.Mmio(packed struct(u32) {
                reserved24: u24,
                ///  Priority of system handler 11
                PRI_11: u8,
            }),
            ///  System handler priority registers
            SHPR3: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Priority of system handler 14
                PRI_14: u8,
                ///  Priority of system handler 15
                PRI_15: u8,
            }),
            ///  System handler control and state register
            SHCRS: mmio.Mmio(packed struct(u32) {
                ///  Memory management fault exception active bit
                MEMFAULTACT: u1,
                ///  Bus fault exception active bit
                BUSFAULTACT: u1,
                reserved3: u1,
                ///  Usage fault exception active bit
                USGFAULTACT: u1,
                reserved7: u3,
                ///  SVC call active bit
                SVCALLACT: u1,
                ///  Debug monitor active bit
                MONITORACT: u1,
                reserved10: u1,
                ///  PendSV exception active bit
                PENDSVACT: u1,
                ///  SysTick exception active bit
                SYSTICKACT: u1,
                ///  Usage fault exception pending bit
                USGFAULTPENDED: u1,
                ///  Memory management fault exception pending bit
                MEMFAULTPENDED: u1,
                ///  Bus fault exception pending bit
                BUSFAULTPENDED: u1,
                ///  SVC call pending bit
                SVCALLPENDED: u1,
                ///  Memory management fault enable bit
                MEMFAULTENA: u1,
                ///  Bus fault enable bit
                BUSFAULTENA: u1,
                ///  Usage fault enable bit
                USGFAULTENA: u1,
                padding: u13,
            }),
            ///  Configurable fault status register
            CFSR_UFSR_BFSR_MMFSR: mmio.Mmio(packed struct(u32) {
                ///  IACCVIOL
                IACCVIOL: u1,
                ///  DACCVIOL
                DACCVIOL: u1,
                reserved3: u1,
                ///  MUNSTKERR
                MUNSTKERR: u1,
                ///  MSTKERR
                MSTKERR: u1,
                ///  MLSPERR
                MLSPERR: u1,
                reserved7: u1,
                ///  MMARVALID
                MMARVALID: u1,
                ///  Instruction bus error
                IBUSERR: u1,
                ///  Precise data bus error
                PRECISERR: u1,
                ///  Imprecise data bus error
                IMPRECISERR: u1,
                ///  Bus fault on unstacking for a return from exception
                UNSTKERR: u1,
                ///  Bus fault on stacking for exception entry
                STKERR: u1,
                ///  Bus fault on floating-point lazy state preservation
                LSPERR: u1,
                reserved15: u1,
                ///  Bus Fault Address Register (BFAR) valid flag
                BFARVALID: u1,
                ///  Undefined instruction usage fault
                UNDEFINSTR: u1,
                ///  Invalid state usage fault
                INVSTATE: u1,
                ///  Invalid PC load usage fault
                INVPC: u1,
                ///  No coprocessor usage fault.
                NOCP: u1,
                reserved24: u4,
                ///  Unaligned access usage fault
                UNALIGNED: u1,
                ///  Divide by zero usage fault
                DIVBYZERO: u1,
                padding: u6,
            }),
            ///  Hard fault status register
            HFSR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Vector table hard fault
                VECTTBL: u1,
                reserved30: u28,
                ///  Forced hard fault
                FORCED: u1,
                ///  Reserved for Debug use
                DEBUG_VT: u1,
            }),
            reserved52: [4]u8,
            ///  Memory management fault address register
            MMFAR: mmio.Mmio(packed struct(u32) {
                ///  Memory management fault address
                ADDRESS: u32,
            }),
            ///  Bus fault address register
            BFAR: mmio.Mmio(packed struct(u32) {
                ///  Bus fault address
                ADDRESS: u32,
            }),
        };

        ///  GPIO
        pub const GPIOA = extern struct {
            ///  GPIO port mode register
            MODER: mmio.Mmio(packed struct(u32) {
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE0: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE1: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE2: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE3: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE4: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE5: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE6: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE7: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE8: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE9: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE10: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE11: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE12: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE13: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE14: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
                MODE15: u2,
            }),
            ///  GPIO port output type register
            OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT0: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT1: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT2: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT3: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT4: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT5: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT6: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT7: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT8: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT9: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT10: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT11: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT12: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT13: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT14: u1,
                ///  Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED0: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED1: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED2: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED3: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED4: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED5: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED6: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED7: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED8: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED9: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED10: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED11: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED12: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED13: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED14: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
                OSPEED15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            PUPDR: mmio.Mmio(packed struct(u32) {
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: u2,
                ///  [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: u2,
            }),
            ///  GPIO port input data register
            IDR: mmio.Mmio(packed struct(u32) {
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD0: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD1: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD2: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD3: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD4: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD5: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD6: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD7: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD8: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD9: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD10: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD11: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD12: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD13: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD14: u1,
                ///  Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: u1,
                ///  Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: u1,
                ///  Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
            LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: u1,
                ///  Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: u1,
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            AFRL: mmio.Mmio(packed struct(u32) {
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL0: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL1: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL2: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL3: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL4: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL5: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL6: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
                AFSEL7: u4,
            }),
            ///  GPIO alternate function high register
            AFRH: mmio.Mmio(packed struct(u32) {
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL8: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL9: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL10: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL11: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL12: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL13: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL14: u4,
                ///  [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
                AFSEL15: u4,
            }),
        };

        ///  Floting point unit
        pub const FPU = extern struct {
            ///  Floating-point context control register
            FPCCR: mmio.Mmio(packed struct(u32) {
                ///  LSPACT
                LSPACT: u1,
                ///  USER
                USER: u1,
                reserved3: u1,
                ///  THREAD
                THREAD: u1,
                ///  HFRDY
                HFRDY: u1,
                ///  MMRDY
                MMRDY: u1,
                ///  BFRDY
                BFRDY: u1,
                reserved8: u1,
                ///  MONRDY
                MONRDY: u1,
                reserved30: u21,
                ///  LSPEN
                LSPEN: u1,
                ///  ASPEN
                ASPEN: u1,
            }),
            ///  Floating-point context address register
            FPCAR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Location of unpopulated floating-point
                ADDRESS: u29,
            }),
            ///  Floating-point status control register
            FPSCR: mmio.Mmio(packed struct(u32) {
                ///  Invalid operation cumulative exception bit
                IOC: u1,
                ///  Division by zero cumulative exception bit.
                DZC: u1,
                ///  Overflow cumulative exception bit
                OFC: u1,
                ///  Underflow cumulative exception bit
                UFC: u1,
                ///  Inexact cumulative exception bit
                IXC: u1,
                reserved7: u2,
                ///  Input denormal cumulative exception bit.
                IDC: u1,
                reserved22: u14,
                ///  Rounding Mode control field
                RMode: u2,
                ///  Flush-to-zero mode control bit:
                FZ: u1,
                ///  Default NaN mode control bit
                DN: u1,
                ///  Alternative half-precision control bit
                AHP: u1,
                reserved28: u1,
                ///  Overflow condition code flag
                V: u1,
                ///  Carry condition code flag
                C: u1,
                ///  Zero condition code flag
                Z: u1,
                ///  Negative condition code flag
                N: u1,
            }),
        };

        ///  System control block ACTLR
        pub const SCB_ACTRL = extern struct {
            ///  Auxiliary control register
            ACTRL: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  DISFOLD
                DISFOLD: u1,
                reserved10: u7,
                ///  FPEXCODIS
                FPEXCODIS: u1,
                ///  DISRAMODE
                DISRAMODE: u1,
                ///  DISITMATBFLUSH
                DISITMATBFLUSH: u1,
                padding: u19,
            }),
        };

        ///  Floating point unit CPACR
        pub const FPU_CPACR = extern struct {
            ///  Coprocessor access control register
            CPACR: mmio.Mmio(packed struct(u32) {
                reserved20: u20,
                ///  CP
                CP: u4,
                padding: u8,
            }),
        };

        ///  Nested vectored interrupt controller
        pub const NVIC_STIR = extern struct {
            ///  Software trigger interrupt register
            STIR: mmio.Mmio(packed struct(u32) {
                ///  Software generated interrupt ID
                INTID: u9,
                padding: u23,
            }),
        };

        ///  SysTick timer
        pub const STK = extern struct {
            ///  SysTick control and status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                ENABLE: u1,
                ///  SysTick exception request enable
                TICKINT: u1,
                ///  Clock source selection
                CLKSOURCE: u1,
                reserved16: u13,
                ///  COUNTFLAG
                COUNTFLAG: u1,
                padding: u15,
            }),
            ///  SysTick reload value register
            RVR: mmio.Mmio(packed struct(u32) {
                ///  RELOAD value
                RELOAD: u24,
                padding: u8,
            }),
            ///  SysTick current value register
            CVR: mmio.Mmio(packed struct(u32) {
                ///  Current counter value
                CURRENT: u24,
                padding: u8,
            }),
            ///  SysTick calibration value register
            CALIB: mmio.Mmio(packed struct(u32) {
                ///  Calibration value
                TENMS: u24,
                reserved30: u6,
                ///  SKEW flag: Indicates whether the TENMS value is exact
                SKEW: u1,
                ///  NOREF flag. Reads as zero
                NOREF: u1,
            }),
        };

        ///  Memory protection unit
        pub const MPU = extern struct {
            ///  MPU type register
            MPU_TYPER: mmio.Mmio(packed struct(u32) {
                ///  Separate flag
                SEPARATE: u1,
                reserved8: u7,
                ///  Number of MPU data regions
                DREGION: u8,
                ///  Number of MPU instruction regions
                IREGION: u8,
                padding: u8,
            }),
            ///  MPU control register
            MPU_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Enables the MPU
                ENABLE: u1,
                ///  Enables the operation of MPU during hard fault
                HFNMIENA: u1,
                ///  Enable priviliged software access to default memory map
                PRIVDEFENA: u1,
                padding: u29,
            }),
            ///  MPU region number register
            MPU_RNR: mmio.Mmio(packed struct(u32) {
                ///  MPU region
                REGION: u8,
                padding: u24,
            }),
            ///  MPU region base address register
            MPU_RBAR: mmio.Mmio(packed struct(u32) {
                ///  MPU region field
                REGION: u4,
                ///  MPU region number valid
                VALID: u1,
                ///  Region base address field
                ADDR: u27,
            }),
            ///  MPU region attribute and size register
            MPU_RASR: mmio.Mmio(packed struct(u32) {
                ///  Region enable bit.
                ENABLE: u1,
                ///  Size of the MPU protection region
                SIZE: u5,
                reserved8: u2,
                ///  Subregion disable bits
                SRD: u8,
                ///  memory attribute
                B: u1,
                ///  memory attribute
                C: u1,
                ///  Shareable memory attribute
                S: u1,
                ///  memory attribute
                TEX: u3,
                reserved24: u2,
                ///  Access permission
                AP: u3,
                reserved28: u1,
                ///  Instruction access disable bit
                XN: u1,
                padding: u3,
            }),
        };

        ///  Nested Vectored Interrupt Controller
        pub const NVIC = extern struct {
            ///  Interrupt Set-Enable Register
            ISER0: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER1: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER2: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER3: u32,
            ///  Interrupt Set-Enable Register
            ISER4: u32,
            reserved128: [108]u8,
            ///  Interrupt Clear-Enable Register
            ICER0: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER1: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER2: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER3: u32,
            ///  Interrupt Clear-Enable Register
            ICER4: u32,
            reserved256: [108]u8,
            ///  Interrupt Set-Pending Register
            ISPR0: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR1: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR2: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR3: u32,
            ///  Interrupt Set-Pending Register
            ISPR4: u32,
            reserved384: [108]u8,
            ///  Interrupt Clear-Pending Register
            ICPR0: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            ///  Interrupt Clear-Pending Register
            ICPR1: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            ///  Interrupt Clear-Pending Register
            ICPR2: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            reserved448: [52]u8,
            ///  Interrupt Clear-Pending Register
            ICPR3: u32,
            ///  Interrupt Clear-Pending Register
            ICPR4: u32,
            reserved512: [56]u8,
            ///  Interrupt Active Bit Register
            IABR0: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR1: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR2: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR3: u32,
            ///  Interrupt Active Bit Register
            IABR4: u32,
            reserved768: [236]u8,
            ///  Interrupt Priority Register
            IPR0: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR1: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR2: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR3: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR4: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR5: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR6: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR7: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR8: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR9: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR10: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR11: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR12: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR13: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR14: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR15: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR16: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR17: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR18: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR19: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR20: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR21: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR22: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR23: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR24: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR25: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR26: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR27: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR28: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR29: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR30: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR31: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR32: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR33: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR34: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR35: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR36: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR37: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR38: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR39: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
        };

        ///  Ethernet: DMA mode register (DMA)
        pub const Ethernet_DMA = extern struct {
            ///  DMA mode register
            DMAMR: mmio.Mmio(packed struct(u32) {
                ///  Software Reset
                SWR: u1,
                ///  DMA Tx or Rx Arbitration Scheme
                DA: u1,
                reserved11: u9,
                ///  Transmit priority
                TXPR: u1,
                ///  Priority ratio
                PR: u3,
                reserved16: u1,
                ///  Interrupt Mode
                INTM: u1,
                padding: u15,
            }),
            ///  System bus mode register
            DMASBMR: mmio.Mmio(packed struct(u32) {
                ///  Fixed Burst Length
                FB: u1,
                reserved12: u11,
                ///  Address-Aligned Beats
                AAL: u1,
                reserved14: u1,
                ///  Mixed Burst
                MB: u1,
                ///  Rebuild INCRx Burst
                RB: u1,
                padding: u16,
            }),
            ///  Interrupt status register
            DMAISR: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel Interrupt Status
                DC0IS: u1,
                reserved16: u15,
                ///  MTL Interrupt Status
                MTLIS: u1,
                ///  MAC Interrupt Status
                MACIS: u1,
                padding: u14,
            }),
            ///  Debug status register
            DMADSR: mmio.Mmio(packed struct(u32) {
                ///  AHB Master Write Channel
                AXWHSTS: u1,
                reserved8: u7,
                ///  DMA Channel Receive Process State
                RPS0: u4,
                ///  DMA Channel Transmit Process State
                TPS0: u4,
                padding: u16,
            }),
            reserved256: [240]u8,
            ///  Channel control register
            DMACCR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Segment Size
                MSS: u14,
                reserved16: u2,
                ///  8xPBL mode
                PBLX8: u1,
                reserved18: u1,
                ///  Descriptor Skip Length
                DSL: u3,
                padding: u11,
            }),
            ///  Channel transmit control register
            DMACTxCR: mmio.Mmio(packed struct(u32) {
                ///  Start or Stop Transmission Command
                ST: u1,
                reserved4: u3,
                ///  Operate on Second Packet
                OSF: u1,
                reserved12: u7,
                ///  TCP Segmentation Enabled
                TSE: u1,
                reserved16: u3,
                ///  Transmit Programmable Burst Length
                TXPBL: u6,
                padding: u10,
            }),
            ///  Channel receive control register
            DMACRxCR: mmio.Mmio(packed struct(u32) {
                ///  Start or Stop Receive Command
                SR: u1,
                ///  Receive Buffer size
                RBSZ: u14,
                reserved16: u1,
                ///  RXPBL
                RXPBL: u6,
                reserved31: u9,
                ///  DMA Rx Channel Packet Flush
                RPF: u1,
            }),
            reserved276: [8]u8,
            ///  Channel Tx descriptor list address register
            DMACTxDLAR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Start of Transmit List
                TDESLA: u30,
            }),
            reserved284: [4]u8,
            ///  Channel Rx descriptor list address register
            DMACRxDLAR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Start of Receive List
                RDESLA: u30,
            }),
            ///  Channel Tx descriptor tail pointer register
            DMACTxDTPR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Transmit Descriptor Tail Pointer
                TDT: u30,
            }),
            reserved296: [4]u8,
            ///  Channel Rx descriptor tail pointer register
            DMACRxDTPR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Receive Descriptor Tail Pointer
                RDT: u30,
            }),
            ///  Channel Tx descriptor ring length register
            DMACTxRLR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Descriptor Ring Length
                TDRL: u10,
                padding: u22,
            }),
            ///  Channel Rx descriptor ring length register
            DMACRxRLR: mmio.Mmio(packed struct(u32) {
                ///  Receive Descriptor Ring Length
                RDRL: u10,
                padding: u22,
            }),
            ///  Channel interrupt enable register
            DMACIER: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt Enable
                TIE: u1,
                ///  Transmit Stopped Enable
                TXSE: u1,
                ///  Transmit Buffer Unavailable Enable
                TBUE: u1,
                reserved6: u3,
                ///  Receive Interrupt Enable
                RIE: u1,
                ///  Receive Buffer Unavailable Enable
                RBUE: u1,
                ///  Receive Stopped Enable
                RSE: u1,
                ///  Receive Watchdog Timeout Enable
                RWTE: u1,
                ///  Early Transmit Interrupt Enable
                ETIE: u1,
                ///  Early Receive Interrupt Enable
                ERIE: u1,
                ///  Fatal Bus Error Enable
                FBEE: u1,
                ///  Context Descriptor Error Enable
                CDEE: u1,
                ///  Abnormal Interrupt Summary Enable
                AIE: u1,
                ///  Normal Interrupt Summary Enable
                NIE: u1,
                padding: u16,
            }),
            ///  Channel Rx interrupt watchdog timer register
            DMACRxIWTR: mmio.Mmio(packed struct(u32) {
                ///  Receive Interrupt Watchdog Timer Count
                RWT: u8,
                padding: u24,
            }),
            reserved324: [8]u8,
            ///  Channel current application transmit descriptor register
            DMACCATxDR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Descriptor Address Pointer
                CURTDESAPTR: u32,
            }),
            reserved332: [4]u8,
            ///  Channel current application receive descriptor register
            DMACCARxDR: mmio.Mmio(packed struct(u32) {
                ///  Application Receive Descriptor Address Pointer
                CURRDESAPTR: u32,
            }),
            reserved340: [4]u8,
            ///  Channel current application transmit buffer register
            DMACCATxBR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Buffer Address Pointer
                CURTBUFAPTR: u32,
            }),
            reserved348: [4]u8,
            ///  Channel current application receive buffer register
            DMACCARxBR: mmio.Mmio(packed struct(u32) {
                ///  Application Receive Buffer Address Pointer
                CURRBUFAPTR: u32,
            }),
            ///  Channel status register
            DMACSR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt
                TI: u1,
                ///  Transmit Process Stopped
                TPS: u1,
                ///  Transmit Buffer Unavailable
                TBU: u1,
                reserved6: u3,
                ///  Receive Interrupt
                RI: u1,
                ///  Receive Buffer Unavailable
                RBU: u1,
                ///  Receive Process Stopped
                RPS: u1,
                ///  Receive Watchdog Timeout
                RWT: u1,
                ///  Early Transmit Interrupt
                ET: u1,
                ///  Early Receive Interrupt
                ER: u1,
                ///  Fatal Bus Error
                FBE: u1,
                ///  Context Descriptor Error
                CDE: u1,
                ///  Abnormal Interrupt Summary
                AIS: u1,
                ///  Normal Interrupt Summary
                NIS: u1,
                ///  Tx DMA Error Bits
                TEB: u3,
                ///  Rx DMA Error Bits
                REB: u3,
                padding: u10,
            }),
            reserved364: [8]u8,
            ///  Channel missed frame count register
            DMACMFCR: mmio.Mmio(packed struct(u32) {
                ///  Dropped Packet Counters
                MFC: u11,
                reserved15: u4,
                ///  Overflow status of the MFC Counter
                MFCO: u1,
                padding: u16,
            }),
        };

        ///  Basic timers
        pub const TIM6 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: u1,
                reserved11: u3,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  Master mode selection
                MMS: u3,
                padding: u25,
            }),
            reserved12: [4]u8,
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                reserved8: u7,
                ///  Update DMA request enable
                UDE: u1,
                padding: u23,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                padding: u31,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                padding: u31,
            }),
            reserved36: [12]u8,
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Low counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy
                UIFCPY: u1,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Low Auto-reload value
                ARR: u16,
                padding: u16,
            }),
        };

        ///  Ethernet: MTL mode register (MTL)
        pub const Ethernet_MTL = extern struct {
            ///  Operating mode Register
            MTLOMR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  DTXSTS
                DTXSTS: u1,
                reserved8: u6,
                ///  CNTPRST
                CNTPRST: u1,
                ///  CNTCLR
                CNTCLR: u1,
                padding: u22,
            }),
            reserved32: [28]u8,
            ///  Interrupt status Register
            MTLISR: mmio.Mmio(packed struct(u32) {
                ///  Queue interrupt status
                Q0IS: u1,
                padding: u31,
            }),
            reserved256: [220]u8,
            ///  Tx queue operating mode Register
            MTLTxQOMR: mmio.Mmio(packed struct(u32) {
                ///  Flush Transmit Queue
                FTQ: u1,
                ///  Transmit Store and Forward
                TSF: u1,
                ///  Transmit Queue Enable
                TXQEN: u2,
                ///  Transmit Threshold Control
                TTC: u3,
                reserved16: u9,
                ///  Transmit Queue Size
                TQS: u3,
                padding: u13,
            }),
            ///  Tx queue underflow register
            MTLTxQUR: mmio.Mmio(packed struct(u32) {
                ///  Underflow Packet Counter
                UFFRMCNT: u11,
                ///  UFCNTOVF
                UFCNTOVF: u1,
                padding: u20,
            }),
            ///  Tx queue debug Register
            MTLTxQDR: mmio.Mmio(packed struct(u32) {
                ///  TXQPAUSED
                TXQPAUSED: u1,
                ///  TRCSTS
                TRCSTS: u2,
                ///  TWCSTS
                TWCSTS: u1,
                ///  TXQSTS
                TXQSTS: u1,
                ///  TXSTSFSTS
                TXSTSFSTS: u1,
                reserved16: u10,
                ///  PTXQ
                PTXQ: u3,
                reserved20: u1,
                ///  STXSTSF
                STXSTSF: u3,
                padding: u9,
            }),
            reserved300: [32]u8,
            ///  Queue interrupt control status Register
            MTLQICSR: mmio.Mmio(packed struct(u32) {
                ///  TXUNFIS
                TXUNFIS: u1,
                reserved8: u7,
                ///  TXUIE
                TXUIE: u1,
                reserved16: u7,
                ///  RXOVFIS
                RXOVFIS: u1,
                reserved24: u7,
                ///  RXOIE
                RXOIE: u1,
                padding: u7,
            }),
            ///  Rx queue operating mode register
            MTLRxQOMR: mmio.Mmio(packed struct(u32) {
                ///  RTC
                RTC: u2,
                reserved3: u1,
                ///  FUP
                FUP: u1,
                ///  FEP
                FEP: u1,
                ///  RSF
                RSF: u1,
                ///  DIS_TCP_EF
                DIS_TCP_EF: u1,
                ///  EHFC
                EHFC: u1,
                ///  RFA
                RFA: u3,
                reserved14: u3,
                ///  RFD
                RFD: u3,
                reserved20: u3,
                ///  RQS
                RQS: u3,
                padding: u9,
            }),
            ///  Rx queue missed packet and overflow counter register
            MTLRxQMPOCR: mmio.Mmio(packed struct(u32) {
                ///  OVFPKTCNT
                OVFPKTCNT: u11,
                ///  OVFCNTOVF
                OVFCNTOVF: u1,
                reserved16: u4,
                ///  MISPKTCNT
                MISPKTCNT: u11,
                ///  MISCNTOVF
                MISCNTOVF: u1,
                padding: u4,
            }),
            ///  Rx queue debug register
            MTLRxQDR: mmio.Mmio(packed struct(u32) {
                ///  RWCSTS
                RWCSTS: u1,
                ///  RRCSTS
                RRCSTS: u2,
                reserved4: u1,
                ///  RXQSTS
                RXQSTS: u2,
                reserved16: u10,
                ///  PRXQ
                PRXQ: u14,
                padding: u2,
            }),
        };

        ///  JPEG
        pub const JPEG = extern struct {
            ///  JPEG codec control register
            CONFR0: mmio.Mmio(packed struct(u32) {
                ///  Start This bit start or stop the encoding or decoding process. Read this register always return 0.
                START: u1,
                padding: u31,
            }),
            ///  JPEG codec configuration register 1
            CONFR1: mmio.Mmio(packed struct(u32) {
                ///  Number of color components This field defines the number of color components minus 1.
                NF: u2,
                reserved3: u1,
                ///  Decoding Enable This bit selects the coding or decoding process
                DE: u1,
                ///  Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream.
                COLORSPACE: u2,
                ///  Number of components for Scan This field defines the number of components minus 1 for scan header marker segment.
                NS: u2,
                ///  Header Processing This bit enable the header processing (generation/parsing).
                HDR: u1,
                reserved16: u7,
                ///  Y Size This field defines the number of lines in source image.
                YSIZE: u16,
            }),
            ///  JPEG codec configuration register 2
            CONFR2: mmio.Mmio(packed struct(u32) {
                ///  Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated.
                NMCU: u26,
                padding: u6,
            }),
            ///  JPEG codec configuration register 3
            CONFR3: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  X size This field defines the number of pixels per line.
                XSIZE: u16,
            }),
            ///  JPEG codec configuration register 4-7
            CONFRN1: mmio.Mmio(packed struct(u32) {
                ///  Huffman DC Selects the Huffman table for encoding the DC coefficients.
                HD: u1,
                ///  Huffman AC Selects the Huffman table for encoding the AC coefficients.
                HA: u1,
                ///  Quantization Table Selects quantization table associated with a color component.
                QT: u2,
                ///  Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
                NB: u4,
                ///  Vertical Sampling Factor Vertical sampling factor for component i.
                VSF: u4,
                ///  Horizontal Sampling Factor Horizontal sampling factor for component i.
                HSF: u4,
                padding: u16,
            }),
            ///  JPEG codec configuration register 4-7
            CONFRN2: mmio.Mmio(packed struct(u32) {
                ///  Huffman DC Selects the Huffman table for encoding the DC coefficients.
                HD: u1,
                ///  Huffman AC Selects the Huffman table for encoding the AC coefficients.
                HA: u1,
                ///  Quantization Table Selects quantization table associated with a color component.
                QT: u2,
                ///  Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
                NB: u4,
                ///  Vertical Sampling Factor Vertical sampling factor for component i.
                VSF: u4,
                ///  Horizontal Sampling Factor Horizontal sampling factor for component i.
                HSF: u4,
                padding: u16,
            }),
            ///  JPEG codec configuration register 4-7
            CONFRN3: mmio.Mmio(packed struct(u32) {
                ///  Huffman DC Selects the Huffman table for encoding the DC coefficients.
                HD: u1,
                ///  Huffman AC Selects the Huffman table for encoding the AC coefficients.
                HA: u1,
                ///  Quantization Table Selects quantization table associated with a color component.
                QT: u2,
                ///  Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
                NB: u4,
                ///  Vertical Sampling Factor Vertical sampling factor for component i.
                VSF: u4,
                ///  Horizontal Sampling Factor Horizontal sampling factor for component i.
                HSF: u4,
                padding: u16,
            }),
            ///  JPEG codec configuration register 4-7
            CONFRN4: mmio.Mmio(packed struct(u32) {
                ///  Huffman DC Selects the Huffman table for encoding the DC coefficients.
                HD: u1,
                ///  Huffman AC Selects the Huffman table for encoding the AC coefficients.
                HA: u1,
                ///  Quantization Table Selects quantization table associated with a color component.
                QT: u2,
                ///  Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
                NB: u4,
                ///  Vertical Sampling Factor Vertical sampling factor for component i.
                VSF: u4,
                ///  Horizontal Sampling Factor Horizontal sampling factor for component i.
                HSF: u4,
                padding: u16,
            }),
            reserved48: [16]u8,
            ///  JPEG control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  JPEG Core Enable Enable the JPEG codec Core.
                JCEN: u1,
                ///  Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
                IFTIE: u1,
                ///  Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
                IFNFIE: u1,
                ///  Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
                OFTIE: u1,
                ///  Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
                OFNEIE: u1,
                ///  End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
                EOCIE: u1,
                ///  Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
                HPDIE: u1,
                reserved11: u4,
                ///  Input DMA Enable Enable the DMA request generation for the input FIFO.
                IDMAEN: u1,
                ///  Output DMA Enable Enable the DMA request generation for the output FIFO.
                ODMAEN: u1,
                ///  Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
                IFF: u1,
                ///  Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
                OFF: u1,
                padding: u17,
            }),
            ///  JPEG status register
            SR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.
                IFTF: u1,
                ///  Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
                IFNFF: u1,
                ///  Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
                OFTF: u1,
                ///  Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
                OFNEF: u1,
                ///  End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
                EOCF: u1,
                ///  Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
                HPDF: u1,
                ///  Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
                COF: u1,
                padding: u24,
            }),
            ///  JPEG clear flag register
            CFR: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.
                CEOCF: u1,
                ///  Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
                CHPDF: u1,
                padding: u25,
            }),
            reserved64: [4]u8,
            ///  JPEG data input register
            DIR: mmio.Mmio(packed struct(u32) {
                ///  Data Input FIFO Input FIFO data register.
                DATAIN: u32,
            }),
            ///  JPEG data output register
            DOR: mmio.Mmio(packed struct(u32) {
                ///  Data Output FIFO Output FIFO data register.
                DATAOUT: u32,
            }),
        };

        ///  MDMA
        pub const MDMA = extern struct {
            ///  MDMA Global Interrupt/Status Register
            MDMA_GISR0: mmio.Mmio(packed struct(u32) {
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF0: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF1: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF2: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF3: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF4: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF5: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF6: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF7: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF8: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF9: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF10: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF11: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF12: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF13: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF14: u1,
                ///  Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
                GIF15: u1,
                padding: u16,
            }),
            reserved64: [60]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C0ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF0: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF0: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF0: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF0: u1,
                ///  channel x buffer transfer complete
                TCIF0: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA0: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C0IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF0: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF0: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF0: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF0: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF0: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C0ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C0CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C0TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C0BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C0SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C0DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C0BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C0LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C0TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved112: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C0MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C0MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved128: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C1ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF1: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF1: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF1: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF1: u1,
                ///  channel x buffer transfer complete
                TCIF1: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA1: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C1IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF1: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF1: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF1: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF1: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF1: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C1ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C1CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C1TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C1BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C1SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C1DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C1BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C1LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C1TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved176: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C1MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C1MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved192: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C2ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF2: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF2: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF2: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF2: u1,
                ///  channel x buffer transfer complete
                TCIF2: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA2: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C2IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF2: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF2: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF2: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF2: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF2: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C2ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C2CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C2TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C2BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C2SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C2DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C2BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C2LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C2TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved240: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C2MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C2MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved256: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C3ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF3: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF3: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF3: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF3: u1,
                ///  channel x buffer transfer complete
                TCIF3: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA3: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C3IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF3: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF3: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF3: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF3: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF3: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C3ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C3CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C3TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C3BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C3SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C3DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C3BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C3LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C3TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved304: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C3MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C3MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved320: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C4ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF4: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF4: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF4: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF4: u1,
                ///  channel x buffer transfer complete
                TCIF4: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA4: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C4IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF4: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF4: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF4: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF4: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF4: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C4ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C4CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C4TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C4BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C4SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C4DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C4BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C4LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C4TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved368: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C4MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C4MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved384: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C5ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF5: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF5: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF5: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF5: u1,
                ///  channel x buffer transfer complete
                TCIF5: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA5: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C5IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF5: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF5: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF5: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF5: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF5: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C5ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C5CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C5TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C5BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C5SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C5DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C5BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C5LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C5TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved432: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C5MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C5MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved448: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C6ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF6: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF6: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF6: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF6: u1,
                ///  channel x buffer transfer complete
                TCIF6: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA6: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C6IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF6: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF6: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF6: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF6: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF6: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C6ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C6CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C6TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C6BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C6SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C6DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C6BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C6LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C6TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved496: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C6MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C6MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved512: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C7ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF7: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF7: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF7: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF7: u1,
                ///  channel x buffer transfer complete
                TCIF7: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA7: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C7IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF7: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF7: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF7: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF7: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF7: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C7ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C7CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C7TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C7BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C7SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C7DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C7BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C7LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C7TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved560: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C7MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C7MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved576: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C8ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF8: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF8: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF8: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF8: u1,
                ///  channel x buffer transfer complete
                TCIF8: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA8: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C8IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF8: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF8: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF8: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF8: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF8: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C8ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C8CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C8TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C8BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C8SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C8DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C8BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C8LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C8TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved624: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C8MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C8MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved640: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C9ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF9: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF9: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF9: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF9: u1,
                ///  channel x buffer transfer complete
                TCIF9: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA9: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C9IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF9: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF9: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF9: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF9: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF9: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C9ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C9CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C9TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C9BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C9SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C9DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C9BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C9LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C9TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved688: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C9MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C9MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved704: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C10ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF10: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF10: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF10: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF10: u1,
                ///  channel x buffer transfer complete
                TCIF10: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA10: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C10IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF10: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF10: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF10: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF10: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF10: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C10ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C10CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C10TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C10BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C10SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C10DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C10BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C10LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C10TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved752: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C10MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C10MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved768: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C11ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF11: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF11: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF11: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF11: u1,
                ///  channel x buffer transfer complete
                TCIF11: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA11: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C11IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF11: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF11: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF11: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF11: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF11: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C11ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C11CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C11TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C11BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C11SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C11DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C11BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C11LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C11TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved816: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C11MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C11MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved832: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C12ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF12: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF12: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF12: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF12: u1,
                ///  channel x buffer transfer complete
                TCIF12: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA12: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C12IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF12: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF12: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF12: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF12: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF12: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C12ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C12CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C12TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C12BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C12SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C12DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C12BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C12LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C12TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved880: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C12MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C12MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved896: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C13ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF13: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF13: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF13: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF13: u1,
                ///  channel x buffer transfer complete
                TCIF13: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA13: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C13IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF13: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF13: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF13: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF13: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF13: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C13ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C13CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C13TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C13BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C13SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C13DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C13BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C13LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C13TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved944: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C13MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C13MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved960: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C14ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF14: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF14: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF14: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF14: u1,
                ///  channel x buffer transfer complete
                TCIF14: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA14: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C14IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF14: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF14: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF14: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF14: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF14: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C14ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C14CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C14TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C14BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C14SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C14DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C14BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C14LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C14TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved1008: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C14MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C14MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
            reserved1024: [8]u8,
            ///  MDMA channel x interrupt/status register
            MDMA_C15ISR: mmio.Mmio(packed struct(u32) {
                ///  Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                TEIF15: u1,
                ///  Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
                CTCIF15: u1,
                ///  Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BRTIF15: u1,
                ///  Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
                BTIF15: u1,
                ///  channel x buffer transfer complete
                TCIF15: u1,
                reserved16: u11,
                ///  channel x request active flag
                CRQA15: u1,
                padding: u15,
            }),
            ///  MDMA channel x interrupt flag clear register
            MDMA_C15IFCR: mmio.Mmio(packed struct(u32) {
                ///  Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
                CTEIF15: u1,
                ///  Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
                CCTCIF15: u1,
                ///  Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
                CBRTIF15: u1,
                ///  Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
                CBTIF15: u1,
                ///  CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
                CLTCIF15: u1,
                padding: u27,
            }),
            ///  MDMA Channel x error status register
            MDMA_C15ESR: mmio.Mmio(packed struct(u32) {
                ///  Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
                TEA: u7,
                ///  Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
                TED: u1,
                ///  Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TELD: u1,
                ///  Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                TEMD: u1,
                ///  Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                ASE: u1,
                ///  Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C15CR: mmio.Mmio(packed struct(u32) {
                ///  channel enable
                EN: u1,
                ///  Transfer error interrupt enable This bit is set and cleared by software.
                TEIE: u1,
                ///  Channel Transfer Complete interrupt enable This bit is set and cleared by software.
                CTCIE: u1,
                ///  Block Repeat transfer interrupt enable This bit is set and cleared by software.
                BRTIE: u1,
                ///  Block Transfer interrupt enable This bit is set and cleared by software.
                BTIE: u1,
                ///  buffer Transfer Complete interrupt enable This bit is set and cleared by software.
                TCIE: u1,
                ///  Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
                PL: u2,
                reserved12: u4,
                ///  byte Endianness exchange
                BEX: u1,
                ///  Half word Endianes exchange
                HEX: u1,
                ///  Word Endianness exchange
                WEX: u1,
                reserved16: u1,
                ///  SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel.
            MDMA_C15TCR: mmio.Mmio(packed struct(u32) {
                ///  Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
                SINC: u2,
                ///  Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
                DINC: u2,
                ///  Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
                SSIZE: u2,
                ///  Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
                DSIZE: u2,
                ///  source increment offset size
                SINCOS: u2,
                ///  Destination increment offset
                DINCOS: u2,
                ///  source burst transfer configuration
                SBURST: u3,
                ///  Destination burst transfer configuration
                DBURST: u3,
                ///  buffer transfer lengh
                TLEN: u7,
                ///  PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
                PKE: u1,
                ///  Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
                PAM: u2,
                ///  Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
                TRGM: u2,
                ///  SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
                SWRM: u1,
                ///  Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
                BWM: u1,
            }),
            ///  MDMA Channel x block number of data register
            MDMA_C15BNDTR: mmio.Mmio(packed struct(u32) {
                ///  block number of data to transfer
                BNDT: u17,
                reserved18: u1,
                ///  Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
                BRSUM: u1,
                ///  Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
                BRDUM: u1,
                ///  Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
                BRC: u12,
            }),
            ///  MDMA channel x source address register
            MDMA_C15SAR: mmio.Mmio(packed struct(u32) {
                ///  source adr base
                SAR: u32,
            }),
            ///  MDMA channel x destination address register
            MDMA_C15DAR: mmio.Mmio(packed struct(u32) {
                ///  Destination adr base
                DAR: u32,
            }),
            ///  MDMA channel x Block Repeat address Update register
            MDMA_C15BRUR: mmio.Mmio(packed struct(u32) {
                ///  source adresse update value
                SUV: u16,
                ///  destination address update
                DUV: u16,
            }),
            ///  MDMA channel x Link Address register
            MDMA_C15LAR: mmio.Mmio(packed struct(u32) {
                ///  Link address register
                LAR: u32,
            }),
            ///  MDMA channel x Trigger and Bus selection Register
            MDMA_C15TBR: mmio.Mmio(packed struct(u32) {
                ///  Trigger selection
                TSEL: u6,
                reserved16: u10,
                ///  Source BUS select This bit is protected and can be written only if EN is 0.
                SBUS: u1,
                ///  Destination BUS slect This bit is protected and can be written only if EN is 0.
                DBUS: u1,
                padding: u14,
            }),
            reserved1072: [4]u8,
            ///  MDMA channel x Mask address register
            MDMA_C15MAR: mmio.Mmio(packed struct(u32) {
                ///  Mask address
                MAR: u32,
            }),
            ///  MDMA channel x Mask Data register
            MDMA_C15MDR: mmio.Mmio(packed struct(u32) {
                ///  Mask data
                MDR: u32,
            }),
        };

        ///  QUADSPI
        pub const QUADSPI = extern struct {
            ///  QUADSPI control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Enable Enable the QUADSPI.
                EN: u1,
                ///  Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
                ABORT: u1,
                ///  DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
                DMAEN: u1,
                ///  Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
                TCEN: u1,
                ///  Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
                SSHIFT: u1,
                reserved6: u1,
                ///  Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
                DFM: u1,
                ///  Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
                FSEL: u1,
                ///  FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value.
                FTHRES: u5,
                reserved16: u3,
                ///  Transfer error interrupt enable This bit enables the transfer error interrupt.
                TEIE: u1,
                ///  Transfer complete interrupt enable This bit enables the transfer complete interrupt.
                TCIE: u1,
                ///  FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
                FTIE: u1,
                ///  Status match interrupt enable This bit enables the status match interrupt.
                SMIE: u1,
                ///  TimeOut interrupt enable This bit enables the TimeOut interrupt.
                TOIE: u1,
                reserved22: u1,
                ///  Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
                APMS: u1,
                ///  Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
                PMM: u1,
                ///  clock prescaler
                PRESCALER: u8,
            }),
            ///  QUADSPI device configuration register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  indicates the level that clk takes between command
                CKMODE: u1,
                reserved8: u7,
                ///  Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0.
                CSHT: u3,
                reserved16: u5,
                ///  Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0.
                FSIZE: u5,
                padding: u11,
            }),
            ///  QUADSPI status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.
                TEF: u1,
                ///  Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
                TCF: u1,
                ///  FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
                FTF: u1,
                ///  Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
                SMF: u1,
                ///  Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
                TOF: u1,
                ///  Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
                BUSY: u1,
                reserved8: u2,
                ///  FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero.
                FLEVEL: u6,
                padding: u18,
            }),
            ///  QUADSPI flag clear register
            FCR: mmio.Mmio(packed struct(u32) {
                ///  Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register
                CTEF: u1,
                ///  Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
                CTCF: u1,
                reserved3: u1,
                ///  Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
                CSMF: u1,
                ///  Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
                CTOF: u1,
                padding: u27,
            }),
            ///  QUADSPI data length register
            DLR: mmio.Mmio(packed struct(u32) {
                ///  Data length Number of data to be retrieved (value+1) in indirect and status-polling modes. A value no greater than 3 (indicating 4 bytes) should be used for status-polling mode. All 1s in indirect mode means undefined length, where QUADSPI will continue until the end of memory, as defined by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001: 2 bytes are to be transferred 0x0000_0002: 3 bytes are to be transferred 0x0000_0003: 4 bytes are to be transferred ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred 0xFFFF_FFFE: 4,294,967,295 (4G-1) bytes are to be transferred 0xFFFF_FFFF: undefined length -- all bytes until the end of Flash memory (as defined by FSIZE) are to be transferred. Continue reading indefinitely if FSIZE = 0x1F. DL[0] is stuck at 1 in dual-flash mode (DFM = 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in memory-mapped mode (FMODE = 10). This field can be written only when BUSY = 0.
                DL: u32,
            }),
            ///  QUADSPI communication configuration register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0.
                INSTRUCTION: u8,
                ///  Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0.
                IMODE: u2,
                ///  Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0.
                ADMODE: u2,
                ///  Address size This bit defines address size: This field can be written only when BUSY = 0.
                ADSIZE: u2,
                ///  Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0.
                ABMODE: u2,
                ///  Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0.
                ABSIZE: u2,
                ///  Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0.
                DCYC: u5,
                reserved24: u1,
                ///  Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0.
                DMODE: u2,
                ///  Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0.
                FMODE: u2,
                ///  Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
                SIOO: u1,
                reserved30: u1,
                ///  DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
                DHHC: u1,
                ///  Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
                DDRM: u1,
            }),
            ///  QUADSPI address register
            AR: mmio.Mmio(packed struct(u32) {
                ///  [31 0]: Address Address to be send to the external Flash memory Writes to this field are ignored when BUSY = 0 or when FMODE = 11 (memory-mapped mode). In dual flash mode, ADDRESS[0] is automatically stuck to 0 as the address should always be even
                ADDRESS: u32,
            }),
            ///  QUADSPI alternate bytes registers
            ABR: mmio.Mmio(packed struct(u32) {
                ///  Alternate Bytes Optional data to be send to the external SPI device right after the address. This field can be written only when BUSY = 0.
                ALTERNATE: u32,
            }),
            ///  QUADSPI data register
            DR: mmio.Mmio(packed struct(u32) {
                ///  Data Data to be sent/received to/from the external SPI device. In indirect write mode, data written to this register is stored on the FIFO before it is sent to the Flash memory during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In indirect read mode, reading this register gives (via the FIFO) the data which was received from the Flash memory. If the FIFO does not have as many bytes as requested by the read operation and if BUSY=1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In automatic polling mode, this register contains the last data read from the Flash memory (without masking). Word, halfword, and byte accesses to this register are supported. In indirect write mode, a byte write adds 1 byte to the FIFO, a halfword write 2, and a word write 4. Similarly, in indirect read mode, a byte read removes 1 byte from the FIFO, a halfword read 2, and a word read 4. Accesses in indirect mode must be aligned to the bottom of this register: a byte read must read DATA[7:0] and a halfword read must read DATA[15:0].
                DATA: u32,
            }),
            ///  QUADSPI polling status mask register
            PSMKR: mmio.Mmio(packed struct(u32) {
                ///  Status mask Mask to be applied to the status bytes received in polling mode. For bit n: This field can be written only when BUSY = 0.
                MASK: u32,
            }),
            ///  QUADSPI polling status match register
            PSMAR: mmio.Mmio(packed struct(u32) {
                ///  Status match Value to be compared with the masked status register to get a match. This field can be written only when BUSY = 0.
                MATCH: u32,
            }),
            ///  QUADSPI polling interval register
            PIR: mmio.Mmio(packed struct(u32) {
                ///  Polling interval Number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0.
                INTERVAL: u16,
                padding: u16,
            }),
            ///  QUADSPI low-power timeout register
            LPTR: mmio.Mmio(packed struct(u32) {
                ///  Timeout period After each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises nCS, putting the Flash memory in a lower-consumption state. This field can be written only when BUSY = 0.
                TIMEOUT: u16,
                padding: u16,
            }),
        };

        ///  RNG
        pub const RNG = extern struct {
            ///  RNG control register
            CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Random number generator enable
                RNGEN: u1,
                ///  Interrupt enable
                IE: u1,
                reserved5: u1,
                ///  Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
                CED: u1,
                padding: u26,
            }),
            ///  RNG status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.
                DRDY: u1,
                ///  Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
                CECS: u1,
                ///  Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
                SECS: u1,
                reserved5: u2,
                ///  Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
                CEIS: u1,
                ///  Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
                SEIS: u1,
                padding: u25,
            }),
            ///  The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
            DR: mmio.Mmio(packed struct(u32) {
                ///  Random data 32-bit random data which are valid when DRDY=1.
                RNDATA: u32,
            }),
        };

        ///  RTC
        pub const RTC = extern struct {
            ///  The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_TR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format
                SU: u4,
                ///  Second tens in BCD format
                ST: u3,
                reserved8: u1,
                ///  Minute units in BCD format
                MNU: u4,
                ///  Minute tens in BCD format
                MNT: u3,
                reserved16: u1,
                ///  Hour units in BCD format
                HU: u4,
                ///  Hour tens in BCD format
                HT: u2,
                ///  AM/PM notation
                PM: u1,
                padding: u9,
            }),
            ///  The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_DR: mmio.Mmio(packed struct(u32) {
                ///  Date units in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                reserved8: u2,
                ///  Month units in BCD format
                MU: u4,
                ///  Month tens in BCD format
                MT: u1,
                ///  Week day units
                WDU: u3,
                ///  Year units in BCD format
                YU: u4,
                ///  Year tens in BCD format
                YT: u4,
                padding: u8,
            }),
            ///  RTC control register
            RTC_CR: mmio.Mmio(packed struct(u32) {
                ///  Wakeup clock selection
                WUCKSEL: u3,
                ///  Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
                TSEDGE: u1,
                ///  RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
                REFCKON: u1,
                ///  Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
                BYPSHAD: u1,
                ///  Hour format
                FMT: u1,
                reserved8: u1,
                ///  Alarm A enable
                ALRAE: u1,
                ///  Alarm B enable
                ALRBE: u1,
                ///  Wakeup timer enable
                WUTE: u1,
                ///  timestamp enable
                TSE: u1,
                ///  Alarm A interrupt enable
                ALRAIE: u1,
                ///  Alarm B interrupt enable
                ALRBIE: u1,
                ///  Wakeup timer interrupt enable
                WUTIE: u1,
                ///  Time-stamp interrupt enable
                TSIE: u1,
                ///  Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
                ADD1H: u1,
                ///  Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
                SUB1H: u1,
                ///  Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
                BKP: u1,
                ///  Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output
                COSEL: u1,
                ///  Output polarity This bit is used to configure the polarity of RTC_ALARM output
                POL: u1,
                ///  Output selection These bits are used to select the flag to be routed to RTC_ALARM output
                OSEL: u2,
                ///  Calibration output enable This bit enables the RTC_CALIB output
                COE: u1,
                ///  timestamp on internal event enable
                ITSE: u1,
                padding: u7,
            }),
            ///  This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
            RTC_ISR: mmio.Mmio(packed struct(u32) {
                ///  Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
                ALRAWF: u1,
                ///  Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
                ALRBWF: u1,
                ///  Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set.
                WUTWF: u1,
                ///  Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
                SHPF: u1,
                ///  Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
                INITS: u1,
                ///  Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
                RSF: u1,
                ///  Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
                INITF: u1,
                ///  Initialization mode
                INIT: u1,
                ///  Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0.
                ALRAF: u1,
                ///  Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0.
                ALRBF: u1,
                ///  Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
                WUTF: u1,
                ///  Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0.
                TSF: u1,
                ///  Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared.
                TSOVF: u1,
                ///  RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0
                TAMP1F: u1,
                ///  RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0
                TAMP2F: u1,
                ///  RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0
                TAMP3F: u1,
                ///  Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
                RECALPF: u1,
                ///  Internal tTime-stamp flag
                ITSF: u1,
                padding: u14,
            }),
            ///  This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_PRER: mmio.Mmio(packed struct(u32) {
                ///  Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
                PREDIV_S: u15,
                reserved16: u1,
                ///  Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
                PREDIV_A: u7,
                padding: u9,
            }),
            ///  This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_WUTR: mmio.Mmio(packed struct(u32) {
                ///  Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden.
                WUT: u16,
                padding: u16,
            }),
            reserved28: [4]u8,
            ///  This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_ALRMAR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format.
                SU: u4,
                ///  Second tens in BCD format.
                ST: u3,
                ///  Alarm A seconds mask
                MSK1: u1,
                ///  Minute units in BCD format.
                MNU: u4,
                ///  Minute tens in BCD format.
                MNT: u3,
                ///  Alarm A minutes mask
                MSK2: u1,
                ///  Hour units in BCD format.
                HU: u4,
                ///  Hour tens in BCD format.
                HT: u2,
                ///  AM/PM notation
                PM: u1,
                ///  Alarm A hours mask
                MSK3: u1,
                ///  Date units or day in BCD format.
                DU: u4,
                ///  Date tens in BCD format.
                DT: u2,
                ///  Week day selection
                WDSEL: u1,
                ///  Alarm A date mask
                MSK4: u1,
            }),
            ///  This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_ALRMBR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format
                SU: u4,
                ///  Second tens in BCD format
                ST: u3,
                ///  Alarm B seconds mask
                MSK1: u1,
                ///  Minute units in BCD format
                MNU: u4,
                ///  Minute tens in BCD format
                MNT: u3,
                ///  Alarm B minutes mask
                MSK2: u1,
                ///  Hour units in BCD format
                HU: u4,
                ///  Hour tens in BCD format
                HT: u2,
                ///  AM/PM notation
                PM: u1,
                ///  Alarm B hours mask
                MSK3: u1,
                ///  Date units or day in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                ///  Week day selection
                WDSEL: u1,
                ///  Alarm B date mask
                MSK4: u1,
            }),
            ///  RTC write protection register
            RTC_WPR: mmio.Mmio(packed struct(u32) {
                ///  Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
                KEY: u8,
                padding: u24,
            }),
            ///  RTC sub second register
            RTC_SSR: mmio.Mmio(packed struct(u32) {
                ///  Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
                SS: u16,
                padding: u16,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_SHIFTR: mmio.Mmio(packed struct(u32) {
                ///  Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time.
                SUBFS: u15,
                reserved31: u16,
                ///  Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
                ADD1S: u1,
            }),
            ///  The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
            RTC_TSTR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format.
                SU: u4,
                ///  Second tens in BCD format.
                ST: u3,
                reserved8: u1,
                ///  Minute units in BCD format.
                MNU: u4,
                ///  Minute tens in BCD format.
                MNT: u3,
                reserved16: u1,
                ///  Hour units in BCD format.
                HU: u4,
                ///  Hour tens in BCD format.
                HT: u2,
                ///  AM/PM notation
                PM: u1,
                padding: u9,
            }),
            ///  The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
            RTC_TSDR: mmio.Mmio(packed struct(u32) {
                ///  Date units in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                reserved8: u2,
                ///  Month units in BCD format
                MU: u4,
                ///  Month tens in BCD format
                MT: u1,
                ///  Week day units
                WDU: u3,
                padding: u16,
            }),
            ///  The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
            RTC_TSSSR: mmio.Mmio(packed struct(u32) {
                ///  Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
                SS: u16,
                padding: u16,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page9.
            RTC_CALR: mmio.Mmio(packed struct(u32) {
                ///  Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13.
                CALM: u9,
                reserved13: u4,
                ///  Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
                CALW16: u1,
                ///  Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
                CALW8: u1,
                ///  Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
                CALP: u1,
                padding: u16,
            }),
            ///  RTC tamper and alternate function configuration register
            RTC_TAMPCR: mmio.Mmio(packed struct(u32) {
                ///  RTC_TAMP1 input detection enable
                TAMP1E: u1,
                ///  Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
                TAMP1TRG: u1,
                ///  Tamper interrupt enable
                TAMPIE: u1,
                ///  RTC_TAMP2 input detection enable
                TAMP2E: u1,
                ///  Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
                TAMP2TRG: u1,
                ///  RTC_TAMP3 detection enable
                TAMP3E: u1,
                ///  Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
                TAMP3TRG: u1,
                ///  Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
                TAMPTS: u1,
                ///  Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled.
                TAMPFREQ: u3,
                ///  RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs.
                TAMPFLT: u2,
                ///  RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs.
                TAMPPRCH: u2,
                ///  RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
                TAMPPUDIS: u1,
                ///  Tamper 1 interrupt enable
                TAMP1IE: u1,
                ///  Tamper 1 no erase
                TAMP1NOERASE: u1,
                ///  Tamper 1 mask flag
                TAMP1MF: u1,
                ///  Tamper 2 interrupt enable
                TAMP2IE: u1,
                ///  Tamper 2 no erase
                TAMP2NOERASE: u1,
                ///  Tamper 2 mask flag
                TAMP2MF: u1,
                ///  Tamper 3 interrupt enable
                TAMP3IE: u1,
                ///  Tamper 3 no erase
                TAMP3NOERASE: u1,
                ///  Tamper 3 mask flag
                TAMP3MF: u1,
                padding: u7,
            }),
            ///  This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
            RTC_ALRMASSR: mmio.Mmio(packed struct(u32) {
                ///  Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
                SS: u15,
                reserved24: u9,
                ///  Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
                MASKSS: u4,
                padding: u4,
            }),
            ///  This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
            RTC_ALRMBSSR: mmio.Mmio(packed struct(u32) {
                ///  Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
                SS: u15,
                reserved24: u9,
                ///  Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
                MASKSS: u4,
                padding: u4,
            }),
            ///  RTC option register
            RTC_OR: mmio.Mmio(packed struct(u32) {
                ///  RTC_ALARM output type on PC13
                RTC_ALARM_TYPE: u1,
                ///  RTC_OUT remap
                RTC_OUT_RMP: u1,
                padding: u30,
            }),
            ///  RTC backup registers
            RTC_BKP0R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP1R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP2R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP3R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP4R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP5R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP6R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP7R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP8R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP9R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP10R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP11R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP12R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP13R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP14R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP15R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP16R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP17R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP18R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP19R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP20R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP21R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP22R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP23R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP24R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP25R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP26R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP27R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP28R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP29R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP30R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
            ///  RTC backup registers
            RTC_BKP31R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
                BKP: u32,
            }),
        };

        ///  SAI
        pub const SAI4 = extern struct {
            ///  Global configuration register
            SAI_GCR: mmio.Mmio(packed struct(u32) {
                ///  Synchronization inputs
                SYNCIN: u2,
                reserved4: u2,
                ///  Synchronization outputs These bits are set and cleared by software.
                SYNCOUT: u2,
                padding: u26,
            }),
            ///  Configuration register 1
            SAI_ACR1: mmio.Mmio(packed struct(u32) {
                ///  SAIx audio block mode immediately
                MODE: u2,
                ///  Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
                PRTCFG: u2,
                reserved5: u1,
                ///  Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
                DS: u3,
                ///  Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
                LSBFIRST: u1,
                ///  Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
                CKSTR: u1,
                ///  Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
                SYNCEN: u2,
                ///  Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
                MONO: u1,
                ///  Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
                OUTDRIV: u1,
                reserved16: u2,
                ///  Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
                SAIXEN: u1,
                ///  DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
                DMAEN: u1,
                reserved19: u1,
                ///  No divider
                NOMCK: u1,
                ///  Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
                MCKDIV: u4,
                reserved26: u2,
                ///  Oversampling ratio for master clock
                OSR: u1,
                padding: u5,
            }),
            ///  Configuration register 2
            SAI_ACR2: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold. This bit is set and cleared by software.
                FTH: u3,
                ///  FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
                FFLUSH: u1,
                ///  Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
                TRIS: u1,
                ///  Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
                MUTE: u1,
                ///  Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
                MUTEVAL: u1,
                ///  Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
                MUTECNT: u6,
                ///  Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
                CPL: u1,
                ///  Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
                COMP: u2,
                padding: u16,
            }),
            ///  This register has no meaning in AC97 and SPDIF audio protocol
            SAI_AFRCR: mmio.Mmio(packed struct(u32) {
                ///  Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
                FRL: u8,
                ///  Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
                FSALL: u7,
                reserved16: u1,
                ///  Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
                FSDEF: u1,
                ///  Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
                FSPOL: u1,
                ///  Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
                FSOFF: u1,
                padding: u13,
            }),
            ///  This register has no meaning in AC97 and SPDIF audio protocol
            SAI_ASLOTR: mmio.Mmio(packed struct(u32) {
                ///  First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                FBOFF: u5,
                reserved6: u1,
                ///  Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                SLOTSZ: u2,
                ///  Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                NBSLOT: u4,
                reserved16: u4,
                ///  Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                SLOTEN: u16,
            }),
            ///  Interrupt mask register 2
            SAI_AIM: mmio.Mmio(packed struct(u32) {
                ///  Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
                OVRUDRIE: u1,
                ///  Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
                MUTEDETIE: u1,
                ///  Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
                WCKCFGIE: u1,
                ///  FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
                FREQIE: u1,
                ///  Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
                CNRDYIE: u1,
                ///  Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
                AFSDETIE: u1,
                ///  Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
                LFSDETIE: u1,
                padding: u25,
            }),
            ///  Status register
            SAI_ASR: mmio.Mmio(packed struct(u32) {
                ///  Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
                OVRUDR: u1,
                ///  Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
                MUTEDET: u1,
                ///  Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
                WCKCFG: u1,
                ///  FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
                FREQ: u1,
                ///  Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
                CNRDY: u1,
                ///  Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
                AFSDET: u1,
                ///  Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
                LFSDET: u1,
                reserved16: u9,
                ///  FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
                FLVL: u3,
                padding: u13,
            }),
            ///  Clear flag register
            SAI_ACLRFR: mmio.Mmio(packed struct(u32) {
                ///  Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
                COVRUDR: u1,
                ///  Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
                CMUTEDET: u1,
                ///  Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
                CWCKCFG: u1,
                reserved4: u1,
                ///  Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
                CCNRDY: u1,
                ///  Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
                CAFSDET: u1,
                ///  Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
                CLFSDET: u1,
                padding: u25,
            }),
            ///  Data register
            SAI_ADR: mmio.Mmio(packed struct(u32) {
                ///  Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
                DATA: u32,
            }),
            ///  Configuration register 1
            SAI_BCR1: mmio.Mmio(packed struct(u32) {
                ///  SAIx audio block mode immediately
                MODE: u2,
                ///  Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
                PRTCFG: u2,
                reserved5: u1,
                ///  Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
                DS: u3,
                ///  Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
                LSBFIRST: u1,
                ///  Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
                CKSTR: u1,
                ///  Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
                SYNCEN: u2,
                ///  Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
                MONO: u1,
                ///  Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
                OUTDRIV: u1,
                reserved16: u2,
                ///  Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
                SAIXEN: u1,
                ///  DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
                DMAEN: u1,
                reserved19: u1,
                ///  No divider
                NOMCK: u1,
                ///  Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
                MCKDIV: u4,
                reserved26: u2,
                ///  Oversampling ratio for master clock
                OSR: u1,
                padding: u5,
            }),
            ///  Configuration register 2
            SAI_BCR2: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold. This bit is set and cleared by software.
                FTH: u3,
                ///  FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
                FFLUSH: u1,
                ///  Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
                TRIS: u1,
                ///  Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
                MUTE: u1,
                ///  Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
                MUTEVAL: u1,
                ///  Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
                MUTECNT: u6,
                ///  Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
                CPL: u1,
                ///  Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
                COMP: u2,
                padding: u16,
            }),
            ///  This register has no meaning in AC97 and SPDIF audio protocol
            SAI_BFRCR: mmio.Mmio(packed struct(u32) {
                ///  Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
                FRL: u8,
                ///  Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
                FSALL: u7,
                reserved16: u1,
                ///  Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
                FSDEF: u1,
                ///  Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
                FSPOL: u1,
                ///  Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
                FSOFF: u1,
                padding: u13,
            }),
            ///  This register has no meaning in AC97 and SPDIF audio protocol
            SAI_BSLOTR: mmio.Mmio(packed struct(u32) {
                ///  First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                FBOFF: u5,
                reserved6: u1,
                ///  Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                SLOTSZ: u2,
                ///  Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                NBSLOT: u4,
                reserved16: u4,
                ///  Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
                SLOTEN: u16,
            }),
            ///  Interrupt mask register 2
            SAI_BIM: mmio.Mmio(packed struct(u32) {
                ///  Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
                OVRUDRIE: u1,
                ///  Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
                MUTEDETIE: u1,
                ///  Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
                WCKCFGIE: u1,
                ///  FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
                FREQIE: u1,
                ///  Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
                CNRDYIE: u1,
                ///  Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
                AFSDETIE: u1,
                ///  Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
                LFSDETIE: u1,
                padding: u25,
            }),
            ///  Status register
            SAI_BSR: mmio.Mmio(packed struct(u32) {
                ///  Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
                OVRUDR: u1,
                ///  Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
                MUTEDET: u1,
                ///  Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
                WCKCFG: u1,
                ///  FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
                FREQ: u1,
                ///  Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
                CNRDY: u1,
                ///  Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
                AFSDET: u1,
                ///  Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
                LFSDET: u1,
                reserved16: u9,
                ///  FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
                FLVL: u3,
                padding: u13,
            }),
            ///  Clear flag register
            SAI_BCLRFR: mmio.Mmio(packed struct(u32) {
                ///  Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
                COVRUDR: u1,
                ///  Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
                CMUTEDET: u1,
                ///  Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
                CWCKCFG: u1,
                reserved4: u1,
                ///  Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
                CCNRDY: u1,
                ///  Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
                CAFSDET: u1,
                ///  Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
                CLFSDET: u1,
                padding: u25,
            }),
            ///  Data register
            SAI_BDR: mmio.Mmio(packed struct(u32) {
                ///  Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
                DATA: u32,
            }),
            ///  PDM control register
            SAI_PDMCR: mmio.Mmio(packed struct(u32) {
                ///  PDM enable
                PDMEN: u1,
                reserved4: u3,
                ///  Number of microphones
                MICNBR: u2,
                reserved8: u2,
                ///  Clock enable of bitstream clock number 1
                CKEN1: u1,
                ///  Clock enable of bitstream clock number 2
                CKEN2: u1,
                ///  Clock enable of bitstream clock number 3
                CKEN3: u1,
                ///  Clock enable of bitstream clock number 4
                CKEN4: u1,
                padding: u20,
            }),
            ///  PDM delay register
            SAI_PDMDLY: mmio.Mmio(packed struct(u32) {
                ///  Delay line adjust for first microphone of pair 1
                DLYM1L: u3,
                reserved4: u1,
                ///  Delay line adjust for second microphone of pair 1
                DLYM1R: u3,
                reserved8: u1,
                ///  Delay line for first microphone of pair 2
                DLYM2L: u3,
                reserved12: u1,
                ///  Delay line for second microphone of pair 2
                DLYM2R: u3,
                reserved16: u1,
                ///  Delay line for first microphone of pair 3
                DLYM3L: u3,
                reserved20: u1,
                ///  Delay line for second microphone of pair 3
                DLYM3R: u3,
                reserved24: u1,
                ///  Delay line for first microphone of pair 4
                DLYM4L: u3,
                reserved28: u1,
                ///  Delay line for second microphone of pair 4
                DLYM4R: u3,
                padding: u1,
            }),
        };

        ///  Ethernet: media access control (MAC)
        pub const Ethernet_MAC = extern struct {
            ///  Operating mode configuration register
            MACCR: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RE: u1,
                ///  TE
                TE: u1,
                ///  PRELEN
                PRELEN: u2,
                ///  DC
                DC: u1,
                ///  BL
                BL: u2,
                reserved8: u1,
                ///  DR
                DR: u1,
                ///  DCRS
                DCRS: u1,
                ///  DO
                DO: u1,
                ///  ECRSFD
                ECRSFD: u1,
                ///  LM
                LM: u1,
                ///  DM
                DM: u1,
                ///  FES
                FES: u1,
                reserved16: u1,
                ///  JE
                JE: u1,
                ///  JD
                JD: u1,
                reserved19: u1,
                ///  WD
                WD: u1,
                ///  ACS
                ACS: u1,
                ///  CST
                CST: u1,
                ///  S2KP
                S2KP: u1,
                ///  GPSLCE
                GPSLCE: u1,
                ///  IPG
                IPG: u3,
                ///  IPC
                IPC: u1,
                ///  SARC
                SARC: u3,
                ///  ARPEN
                ARPEN: u1,
            }),
            ///  Extended operating mode configuration register
            MACECR: mmio.Mmio(packed struct(u32) {
                ///  GPSL
                GPSL: u14,
                reserved16: u2,
                ///  DCRCC
                DCRCC: u1,
                ///  SPEN
                SPEN: u1,
                ///  USP
                USP: u1,
                reserved24: u5,
                ///  EIPGEN
                EIPGEN: u1,
                ///  EIPG
                EIPG: u5,
                padding: u2,
            }),
            ///  Packet filtering control register
            MACPFR: mmio.Mmio(packed struct(u32) {
                ///  PR
                PR: u1,
                ///  HUC
                HUC: u1,
                ///  HMC
                HMC: u1,
                ///  DAIF
                DAIF: u1,
                ///  PM
                PM: u1,
                ///  DBF
                DBF: u1,
                ///  PCF
                PCF: u2,
                ///  SAIF
                SAIF: u1,
                ///  SAF
                SAF: u1,
                ///  HPF
                HPF: u1,
                reserved16: u5,
                ///  VTFE
                VTFE: u1,
                reserved20: u3,
                ///  IPFE
                IPFE: u1,
                ///  DNTU
                DNTU: u1,
                reserved31: u9,
                ///  RA
                RA: u1,
            }),
            ///  Watchdog timeout register
            MACWTR: mmio.Mmio(packed struct(u32) {
                ///  WTO
                WTO: u4,
                reserved8: u4,
                ///  PWE
                PWE: u1,
                padding: u23,
            }),
            ///  Hash Table 0 register
            MACHT0R: mmio.Mmio(packed struct(u32) {
                ///  HT31T0
                HT31T0: u32,
            }),
            ///  Hash Table 1 register
            MACHT1R: mmio.Mmio(packed struct(u32) {
                ///  HT63T32
                HT63T32: u32,
            }),
            reserved80: [56]u8,
            ///  VLAN tag register
            MACVTR: mmio.Mmio(packed struct(u32) {
                ///  VL
                VL: u16,
                ///  ETV
                ETV: u1,
                ///  VTIM
                VTIM: u1,
                ///  ESVL
                ESVL: u1,
                ///  ERSVLM
                ERSVLM: u1,
                ///  DOVLTC
                DOVLTC: u1,
                ///  EVLS
                EVLS: u2,
                reserved24: u1,
                ///  EVLRXS
                EVLRXS: u1,
                ///  VTHM
                VTHM: u1,
                ///  EDVLP
                EDVLP: u1,
                ///  ERIVLT
                ERIVLT: u1,
                ///  EIVLS
                EIVLS: u2,
                reserved31: u1,
                ///  EIVLRXS
                EIVLRXS: u1,
            }),
            reserved88: [4]u8,
            ///  VLAN Hash table register
            MACVHTR: mmio.Mmio(packed struct(u32) {
                ///  VLHT
                VLHT: u16,
                padding: u16,
            }),
            reserved96: [4]u8,
            ///  VLAN inclusion register
            MACVIR: mmio.Mmio(packed struct(u32) {
                ///  VLT
                VLT: u16,
                ///  VLC
                VLC: u2,
                ///  VLP
                VLP: u1,
                ///  CSVL
                CSVL: u1,
                ///  VLTI
                VLTI: u1,
                padding: u11,
            }),
            ///  Inner VLAN inclusion register
            MACIVIR: mmio.Mmio(packed struct(u32) {
                ///  VLT
                VLT: u16,
                ///  VLC
                VLC: u2,
                ///  VLP
                VLP: u1,
                ///  CSVL
                CSVL: u1,
                ///  VLTI
                VLTI: u1,
                padding: u11,
            }),
            reserved112: [8]u8,
            ///  Tx Queue flow control register
            MACQTxFCR: mmio.Mmio(packed struct(u32) {
                ///  FCB_BPA
                FCB_BPA: u1,
                ///  TFE
                TFE: u1,
                reserved4: u2,
                ///  PLT
                PLT: u3,
                ///  DZPQ
                DZPQ: u1,
                reserved16: u8,
                ///  PT
                PT: u16,
            }),
            reserved144: [28]u8,
            ///  Rx flow control register
            MACRxFCR: mmio.Mmio(packed struct(u32) {
                ///  RFE
                RFE: u1,
                ///  UP
                UP: u1,
                padding: u30,
            }),
            reserved176: [28]u8,
            ///  Interrupt status register
            MACISR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PHYIS
                PHYIS: u1,
                ///  PMTIS
                PMTIS: u1,
                ///  LPIIS
                LPIIS: u1,
                reserved8: u2,
                ///  MMCIS
                MMCIS: u1,
                ///  MMCRXIS
                MMCRXIS: u1,
                ///  MMCTXIS
                MMCTXIS: u1,
                reserved12: u1,
                ///  TSIS
                TSIS: u1,
                ///  TXSTSIS
                TXSTSIS: u1,
                ///  RXSTSIS
                RXSTSIS: u1,
                padding: u17,
            }),
            ///  Interrupt enable register
            MACIER: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PHYIE
                PHYIE: u1,
                ///  PMTIE
                PMTIE: u1,
                ///  LPIIE
                LPIIE: u1,
                reserved12: u6,
                ///  TSIE
                TSIE: u1,
                ///  TXSTSIE
                TXSTSIE: u1,
                ///  RXSTSIE
                RXSTSIE: u1,
                padding: u17,
            }),
            ///  Rx Tx status register
            MACRxTxSR: mmio.Mmio(packed struct(u32) {
                ///  TJT
                TJT: u1,
                ///  NCARR
                NCARR: u1,
                ///  LCARR
                LCARR: u1,
                ///  EXDEF
                EXDEF: u1,
                ///  LCOL
                LCOL: u1,
                ///  LCOL
                EXCOL: u1,
                reserved8: u2,
                ///  RWT
                RWT: u1,
                padding: u23,
            }),
            reserved192: [4]u8,
            ///  PMT control status register
            MACPCSR: mmio.Mmio(packed struct(u32) {
                ///  PWRDWN
                PWRDWN: u1,
                ///  MGKPKTEN
                MGKPKTEN: u1,
                ///  RWKPKTEN
                RWKPKTEN: u1,
                reserved5: u2,
                ///  MGKPRCVD
                MGKPRCVD: u1,
                ///  RWKPRCVD
                RWKPRCVD: u1,
                reserved9: u2,
                ///  GLBLUCAST
                GLBLUCAST: u1,
                ///  RWKPFE
                RWKPFE: u1,
                reserved24: u13,
                ///  RWKPTR
                RWKPTR: u5,
                reserved31: u2,
                ///  RWKFILTRST
                RWKFILTRST: u1,
            }),
            ///  Remove wakeup packet filter register
            MACRWKPFR: mmio.Mmio(packed struct(u32) {
                ///  MACRWKPFR
                MACRWKPFR: u32,
            }),
            reserved208: [8]u8,
            ///  LPI control status register
            MACLCSR: mmio.Mmio(packed struct(u32) {
                ///  TLPIEN
                TLPIEN: u1,
                ///  TLPIEX
                TLPIEX: u1,
                ///  RLPIEN
                RLPIEN: u1,
                ///  RLPIEX
                RLPIEX: u1,
                reserved8: u4,
                ///  TLPIST
                TLPIST: u1,
                ///  RLPIST
                RLPIST: u1,
                reserved16: u6,
                ///  LPIEN
                LPIEN: u1,
                ///  PLS
                PLS: u1,
                ///  PLSEN
                PLSEN: u1,
                ///  LPITXA
                LPITXA: u1,
                ///  LPITE
                LPITE: u1,
                padding: u11,
            }),
            ///  LPI timers control register
            MACLTCR: mmio.Mmio(packed struct(u32) {
                ///  TWT
                TWT: u16,
                ///  LST
                LST: u10,
                padding: u6,
            }),
            ///  LPI entry timer register
            MACLETR: mmio.Mmio(packed struct(u32) {
                ///  LPIET
                LPIET: u17,
                padding: u15,
            }),
            ///  1-microsecond-tick counter register
            MAC1USTCR: mmio.Mmio(packed struct(u32) {
                ///  TIC_1US_CNTR
                TIC_1US_CNTR: u12,
                padding: u20,
            }),
            reserved272: [48]u8,
            ///  Version register
            MACVR: mmio.Mmio(packed struct(u32) {
                ///  SNPSVER
                SNPSVER: u8,
                ///  USERVER
                USERVER: u8,
                padding: u16,
            }),
            ///  Debug register
            MACDR: mmio.Mmio(packed struct(u32) {
                ///  RPESTS
                RPESTS: u1,
                ///  RFCFCSTS
                RFCFCSTS: u2,
                reserved16: u13,
                ///  TPESTS
                TPESTS: u1,
                ///  TFCSTS
                TFCSTS: u2,
                padding: u13,
            }),
            reserved288: [8]u8,
            ///  HW feature 1 register
            MACHWF1R: mmio.Mmio(packed struct(u32) {
                ///  RXFIFOSIZE
                RXFIFOSIZE: u5,
                reserved6: u1,
                ///  TXFIFOSIZE
                TXFIFOSIZE: u5,
                ///  OSTEN
                OSTEN: u1,
                ///  PTOEN
                PTOEN: u1,
                ///  ADVTHWORD
                ADVTHWORD: u1,
                ///  ADDR64
                ADDR64: u2,
                ///  DCBEN
                DCBEN: u1,
                ///  SPHEN
                SPHEN: u1,
                ///  TSOEN
                TSOEN: u1,
                ///  DBGMEMA
                DBGMEMA: u1,
                ///  AVSEL
                AVSEL: u1,
                reserved24: u3,
                ///  HASHTBLSZ
                HASHTBLSZ: u2,
                reserved27: u1,
                ///  L3L4FNUM
                L3L4FNUM: u4,
                padding: u1,
            }),
            ///  HW feature 2 register
            MACHWF2R: mmio.Mmio(packed struct(u32) {
                ///  RXQCNT
                RXQCNT: u4,
                reserved6: u2,
                ///  TXQCNT
                TXQCNT: u4,
                reserved12: u2,
                ///  RXCHCNT
                RXCHCNT: u4,
                reserved18: u2,
                ///  TXCHCNT
                TXCHCNT: u4,
                reserved24: u2,
                ///  PPSOUTNUM
                PPSOUTNUM: u3,
                reserved28: u1,
                ///  AUXSNAPNUM
                AUXSNAPNUM: u3,
                padding: u1,
            }),
            reserved512: [216]u8,
            ///  MDIO address register
            MACMDIOAR: mmio.Mmio(packed struct(u32) {
                ///  MB
                MB: u1,
                ///  C45E
                C45E: u1,
                ///  GOC
                GOC: u2,
                ///  SKAP
                SKAP: u1,
                reserved8: u3,
                ///  CR
                CR: u4,
                ///  NTC
                NTC: u3,
                reserved16: u1,
                ///  RDA
                RDA: u5,
                ///  PA
                PA: u5,
                ///  BTB
                BTB: u1,
                ///  PSE
                PSE: u1,
                padding: u4,
            }),
            ///  MDIO data register
            MACMDIODR: mmio.Mmio(packed struct(u32) {
                ///  MD
                MD: u16,
                ///  RA
                RA: u16,
            }),
            reserved768: [248]u8,
            ///  Address 0 high register
            MACA0HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved31: u15,
                ///  AE
                AE: u1,
            }),
            ///  Address 0 low register
            MACA0LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  Address 1 high register
            MACA1HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  Address 1 low register
            MACA1LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  Address 2 high register
            MACA2HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  Address 2 low register
            MACA2LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  Address 3 high register
            MACA3HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  Address 3 low register
            MACA3LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            reserved1792: [992]u8,
            ///  MMC control register
            MMC_CONTROL: mmio.Mmio(packed struct(u32) {
                ///  CNTRST
                CNTRST: u1,
                ///  CNTSTOPRO
                CNTSTOPRO: u1,
                ///  RSTONRD
                RSTONRD: u1,
                ///  CNTFREEZ
                CNTFREEZ: u1,
                ///  CNTPRST
                CNTPRST: u1,
                ///  CNTPRSTLVL
                CNTPRSTLVL: u1,
                reserved8: u2,
                ///  UCDBC
                UCDBC: u1,
                padding: u23,
            }),
            ///  MMC Rx interrupt register
            MMC_RX_INTERRUPT: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  RXCRCERPIS
                RXCRCERPIS: u1,
                ///  RXALGNERPIS
                RXALGNERPIS: u1,
                reserved17: u10,
                ///  RXUCGPIS
                RXUCGPIS: u1,
                reserved26: u8,
                ///  RXLPIUSCIS
                RXLPIUSCIS: u1,
                ///  RXLPITRCIS
                RXLPITRCIS: u1,
                padding: u4,
            }),
            ///  MMC Tx interrupt register
            MMC_TX_INTERRUPT: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  TXSCOLGPIS
                TXSCOLGPIS: u1,
                ///  TXMCOLGPIS
                TXMCOLGPIS: u1,
                reserved21: u5,
                ///  TXGPKTIS
                TXGPKTIS: u1,
                reserved26: u4,
                ///  TXLPIUSCIS
                TXLPIUSCIS: u1,
                ///  TXLPITRCIS
                TXLPITRCIS: u1,
                padding: u4,
            }),
            ///  MMC Rx interrupt mask register
            MMC_RX_INTERRUPT_MASK: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  RXCRCERPIM
                RXCRCERPIM: u1,
                ///  RXALGNERPIM
                RXALGNERPIM: u1,
                reserved17: u10,
                ///  RXUCGPIM
                RXUCGPIM: u1,
                reserved26: u8,
                ///  RXLPIUSCIM
                RXLPIUSCIM: u1,
                ///  RXLPITRCIM
                RXLPITRCIM: u1,
                padding: u4,
            }),
            ///  MMC Tx interrupt mask register
            MMC_TX_INTERRUPT_MASK: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  TXSCOLGPIM
                TXSCOLGPIM: u1,
                ///  TXMCOLGPIM
                TXMCOLGPIM: u1,
                reserved21: u5,
                ///  TXGPKTIM
                TXGPKTIM: u1,
                reserved26: u4,
                ///  TXLPIUSCIM
                TXLPIUSCIM: u1,
                ///  TXLPITRCIM
                TXLPITRCIM: u1,
                padding: u4,
            }),
            reserved1868: [56]u8,
            ///  Tx single collision good packets register
            TX_SINGLE_COLLISION_GOOD_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  TXSNGLCOLG
                TXSNGLCOLG: u32,
            }),
            ///  Tx multiple collision good packets register
            TX_MULTIPLE_COLLISION_GOOD_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  TXMULTCOLG
                TXMULTCOLG: u32,
            }),
            reserved1896: [20]u8,
            ///  Tx packet count good register
            TX_PACKET_COUNT_GOOD: mmio.Mmio(packed struct(u32) {
                ///  TXPKTG
                TXPKTG: u32,
            }),
            reserved1940: [40]u8,
            ///  Rx CRC error packets register
            RX_CRC_ERROR_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  RXCRCERR
                RXCRCERR: u32,
            }),
            ///  Rx alignment error packets register
            RX_ALIGNMENT_ERROR_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  RXALGNERR
                RXALGNERR: u32,
            }),
            reserved1988: [40]u8,
            ///  Rx unicast packets good register
            RX_UNICAST_PACKETS_GOOD: mmio.Mmio(packed struct(u32) {
                ///  RXUCASTG
                RXUCASTG: u32,
            }),
            reserved2028: [36]u8,
            ///  Tx LPI microsecond timer register
            TX_LPI_USEC_CNTR: mmio.Mmio(packed struct(u32) {
                ///  TXLPIUSC
                TXLPIUSC: u32,
            }),
            ///  Tx LPI transition counter register
            TX_LPI_TRAN_CNTR: mmio.Mmio(packed struct(u32) {
                ///  TXLPITRC
                TXLPITRC: u32,
            }),
            ///  Rx LPI microsecond counter register
            RX_LPI_USEC_CNTR: mmio.Mmio(packed struct(u32) {
                ///  RXLPIUSC
                RXLPIUSC: u32,
            }),
            ///  Rx LPI transition counter register
            RX_LPI_TRAN_CNTR: mmio.Mmio(packed struct(u32) {
                ///  RXLPITRC
                RXLPITRC: u32,
            }),
            reserved2304: [260]u8,
            ///  L3 and L4 control 0 register
            MACL3L4C0R: mmio.Mmio(packed struct(u32) {
                ///  L3PEN0
                L3PEN0: u1,
                reserved2: u1,
                ///  L3SAM0
                L3SAM0: u1,
                ///  L3SAIM0
                L3SAIM0: u1,
                ///  L3DAM0
                L3DAM0: u1,
                ///  L3DAIM0
                L3DAIM0: u1,
                ///  L3HSBM0
                L3HSBM0: u5,
                ///  L3HDBM0
                L3HDBM0: u5,
                ///  L4PEN0
                L4PEN0: u1,
                reserved18: u1,
                ///  L4SPM0
                L4SPM0: u1,
                ///  L4SPIM0
                L4SPIM0: u1,
                ///  L4DPM0
                L4DPM0: u1,
                ///  L4DPIM0
                L4DPIM0: u1,
                padding: u10,
            }),
            ///  Layer4 address filter 0 register
            MACL4A0R: mmio.Mmio(packed struct(u32) {
                ///  L4SP0
                L4SP0: u16,
                ///  L4DP0
                L4DP0: u16,
            }),
            reserved2320: [8]u8,
            ///  MACL3A00R
            MACL3A00R: mmio.Mmio(packed struct(u32) {
                ///  L3A00
                L3A00: u32,
            }),
            ///  Layer3 address 1 filter 0 register
            MACL3A10R: mmio.Mmio(packed struct(u32) {
                ///  L3A10
                L3A10: u32,
            }),
            ///  Layer3 Address 2 filter 0 register
            MACL3A20: mmio.Mmio(packed struct(u32) {
                ///  L3A20
                L3A20: u32,
            }),
            ///  Layer3 Address 3 filter 0 register
            MACL3A30: mmio.Mmio(packed struct(u32) {
                ///  L3A30
                L3A30: u32,
            }),
            reserved2352: [16]u8,
            ///  L3 and L4 control 1 register
            MACL3L4C1R: mmio.Mmio(packed struct(u32) {
                ///  L3PEN1
                L3PEN1: u1,
                reserved2: u1,
                ///  L3SAM1
                L3SAM1: u1,
                ///  L3SAIM1
                L3SAIM1: u1,
                ///  L3DAM1
                L3DAM1: u1,
                ///  L3DAIM1
                L3DAIM1: u1,
                ///  L3HSBM1
                L3HSBM1: u5,
                ///  L3HDBM1
                L3HDBM1: u5,
                ///  L4PEN1
                L4PEN1: u1,
                reserved18: u1,
                ///  L4SPM1
                L4SPM1: u1,
                ///  L4SPIM1
                L4SPIM1: u1,
                ///  L4DPM1
                L4DPM1: u1,
                ///  L4DPIM1
                L4DPIM1: u1,
                padding: u10,
            }),
            ///  Layer 4 address filter 1 register
            MACL4A1R: mmio.Mmio(packed struct(u32) {
                ///  L4SP1
                L4SP1: u16,
                ///  L4DP1
                L4DP1: u16,
            }),
            reserved2368: [8]u8,
            ///  Layer3 address 0 filter 1 Register
            MACL3A01R: mmio.Mmio(packed struct(u32) {
                ///  L3A01
                L3A01: u32,
            }),
            ///  Layer3 address 1 filter 1 register
            MACL3A11R: mmio.Mmio(packed struct(u32) {
                ///  L3A11
                L3A11: u32,
            }),
            ///  Layer3 address 2 filter 1 Register
            MACL3A21R: mmio.Mmio(packed struct(u32) {
                ///  L3A21
                L3A21: u32,
            }),
            ///  Layer3 address 3 filter 1 register
            MACL3A31R: mmio.Mmio(packed struct(u32) {
                ///  L3A31
                L3A31: u32,
            }),
            reserved2784: [400]u8,
            ///  ARP address register
            MACARPAR: mmio.Mmio(packed struct(u32) {
                ///  ARPPA
                ARPPA: u32,
            }),
            reserved2816: [28]u8,
            ///  Timestamp control Register
            MACTSCR: mmio.Mmio(packed struct(u32) {
                ///  TSENA
                TSENA: u1,
                ///  TSCFUPDT
                TSCFUPDT: u1,
                ///  TSINIT
                TSINIT: u1,
                ///  TSUPDT
                TSUPDT: u1,
                reserved5: u1,
                ///  TSADDREG
                TSADDREG: u1,
                reserved8: u2,
                ///  TSENALL
                TSENALL: u1,
                ///  TSCTRLSSR
                TSCTRLSSR: u1,
                ///  TSVER2ENA
                TSVER2ENA: u1,
                ///  TSIPENA
                TSIPENA: u1,
                ///  TSIPV6ENA
                TSIPV6ENA: u1,
                ///  TSIPV4ENA
                TSIPV4ENA: u1,
                ///  TSEVNTENA
                TSEVNTENA: u1,
                ///  TSMSTRENA
                TSMSTRENA: u1,
                ///  SNAPTYPSEL
                SNAPTYPSEL: u2,
                ///  TSENMACADDR
                TSENMACADDR: u1,
                ///  CSC
                CSC: u1,
                reserved24: u4,
                ///  TXTSSTSM
                TXTSSTSM: u1,
                padding: u7,
            }),
            ///  Sub-second increment register
            MACSSIR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  SNSINC
                SNSINC: u8,
                ///  SSINC
                SSINC: u8,
                padding: u8,
            }),
            ///  System time seconds register
            MACSTSR: mmio.Mmio(packed struct(u32) {
                ///  TSS
                TSS: u32,
            }),
            ///  System time nanoseconds register
            MACSTNR: mmio.Mmio(packed struct(u32) {
                ///  TSSS
                TSSS: u31,
                padding: u1,
            }),
            ///  System time seconds update register
            MACSTSUR: mmio.Mmio(packed struct(u32) {
                ///  TSS
                TSS: u32,
            }),
            ///  System time nanoseconds update register
            MACSTNUR: mmio.Mmio(packed struct(u32) {
                ///  TSSS
                TSSS: u31,
                ///  ADDSUB
                ADDSUB: u1,
            }),
            ///  Timestamp addend register
            MACTSAR: mmio.Mmio(packed struct(u32) {
                ///  TSAR
                TSAR: u32,
            }),
            reserved2848: [4]u8,
            ///  Timestamp status register
            MACTSSR: mmio.Mmio(packed struct(u32) {
                ///  TSSOVF
                TSSOVF: u1,
                ///  TSTARGT0
                TSTARGT0: u1,
                ///  AUXTSTRIG
                AUXTSTRIG: u1,
                ///  TSTRGTERR0
                TSTRGTERR0: u1,
                reserved15: u11,
                ///  TXTSSIS
                TXTSSIS: u1,
                ///  ATSSTN
                ATSSTN: u4,
                reserved24: u4,
                ///  ATSSTM
                ATSSTM: u1,
                ///  ATSNS
                ATSNS: u5,
                padding: u2,
            }),
            reserved2864: [12]u8,
            ///  Tx timestamp status nanoseconds register
            MACTxTSSNR: mmio.Mmio(packed struct(u32) {
                ///  TXTSSLO
                TXTSSLO: u31,
                ///  TXTSSMIS
                TXTSSMIS: u1,
            }),
            ///  Tx timestamp status seconds register
            MACTxTSSSR: mmio.Mmio(packed struct(u32) {
                ///  TXTSSHI
                TXTSSHI: u32,
            }),
            reserved2880: [8]u8,
            ///  Auxiliary control register
            MACACR: mmio.Mmio(packed struct(u32) {
                ///  ATSFC
                ATSFC: u1,
                reserved4: u3,
                ///  ATSEN0
                ATSEN0: u1,
                ///  ATSEN1
                ATSEN1: u1,
                ///  ATSEN2
                ATSEN2: u1,
                ///  ATSEN3
                ATSEN3: u1,
                padding: u24,
            }),
            reserved2888: [4]u8,
            ///  Auxiliary timestamp nanoseconds register
            MACATSNR: mmio.Mmio(packed struct(u32) {
                ///  AUXTSLO
                AUXTSLO: u31,
                padding: u1,
            }),
            ///  Auxiliary timestamp seconds register
            MACATSSR: mmio.Mmio(packed struct(u32) {
                ///  AUXTSHI
                AUXTSHI: u32,
            }),
            ///  Timestamp Ingress asymmetric correction register
            MACTSIACR: mmio.Mmio(packed struct(u32) {
                ///  OSTIAC
                OSTIAC: u32,
            }),
            ///  Timestamp Egress asymmetric correction register
            MACTSEACR: mmio.Mmio(packed struct(u32) {
                ///  OSTEAC
                OSTEAC: u32,
            }),
            ///  Timestamp Ingress correction nanosecond register
            MACTSICNR: mmio.Mmio(packed struct(u32) {
                ///  TSIC
                TSIC: u32,
            }),
            ///  Timestamp Egress correction nanosecond register
            MACTSECNR: mmio.Mmio(packed struct(u32) {
                ///  TSEC
                TSEC: u32,
            }),
            reserved2928: [16]u8,
            ///  PPS control register
            MACPPSCR: mmio.Mmio(packed struct(u32) {
                ///  PPSCTRL
                PPSCTRL: u4,
                ///  PPSEN0
                PPSEN0: u1,
                ///  TRGTMODSEL0
                TRGTMODSEL0: u2,
                padding: u25,
            }),
            reserved2944: [12]u8,
            ///  PPS target time seconds register
            MACPPSTTSR: mmio.Mmio(packed struct(u32) {
                ///  TSTRH0
                TSTRH0: u31,
                padding: u1,
            }),
            ///  PPS target time nanoseconds register
            MACPPSTTNR: mmio.Mmio(packed struct(u32) {
                ///  TTSL0
                TTSL0: u31,
                ///  TRGTBUSY0
                TRGTBUSY0: u1,
            }),
            ///  PPS interval register
            MACPPSIR: mmio.Mmio(packed struct(u32) {
                ///  PPSINT0
                PPSINT0: u32,
            }),
            ///  PPS width register
            MACPPSWR: mmio.Mmio(packed struct(u32) {
                ///  PPSWIDTH0
                PPSWIDTH0: u32,
            }),
            reserved3008: [48]u8,
            ///  PTP Offload control register
            MACPOCR: mmio.Mmio(packed struct(u32) {
                ///  PTOEN
                PTOEN: u1,
                ///  ASYNCEN
                ASYNCEN: u1,
                ///  APDREQEN
                APDREQEN: u1,
                reserved4: u1,
                ///  ASYNCTRIG
                ASYNCTRIG: u1,
                ///  APDREQTRIG
                APDREQTRIG: u1,
                ///  DRRDIS
                DRRDIS: u1,
                reserved8: u1,
                ///  DN
                DN: u8,
                padding: u16,
            }),
            ///  PTP Source Port Identity 0 Register
            MACSPI0R: mmio.Mmio(packed struct(u32) {
                ///  SPI0
                SPI0: u32,
            }),
            ///  PTP Source port identity 1 register
            MACSPI1R: mmio.Mmio(packed struct(u32) {
                ///  SPI1
                SPI1: u32,
            }),
            ///  PTP Source port identity 2 register
            MACSPI2R: mmio.Mmio(packed struct(u32) {
                ///  SPI2
                SPI2: u16,
                padding: u16,
            }),
            ///  Log message interval register
            MACLMIR: mmio.Mmio(packed struct(u32) {
                ///  LSI
                LSI: u8,
                ///  DRSYNCR
                DRSYNCR: u3,
                reserved24: u13,
                ///  LMPDRI
                LMPDRI: u8,
            }),
        };

        ///  DMA controller
        pub const DMA1 = extern struct {
            ///  low interrupt status register
            LISR: mmio.Mmio(packed struct(u32) {
                ///  Stream x FIFO error interrupt flag (x=3..0)
                FEIF0: u1,
                reserved2: u1,
                ///  Stream x direct mode error interrupt flag (x=3..0)
                DMEIF0: u1,
                ///  Stream x transfer error interrupt flag (x=3..0)
                TEIF0: u1,
                ///  Stream x half transfer interrupt flag (x=3..0)
                HTIF0: u1,
                ///  Stream x transfer complete interrupt flag (x = 3..0)
                TCIF0: u1,
                ///  Stream x FIFO error interrupt flag (x=3..0)
                FEIF1: u1,
                reserved8: u1,
                ///  Stream x direct mode error interrupt flag (x=3..0)
                DMEIF1: u1,
                ///  Stream x transfer error interrupt flag (x=3..0)
                TEIF1: u1,
                ///  Stream x half transfer interrupt flag (x=3..0)
                HTIF1: u1,
                ///  Stream x transfer complete interrupt flag (x = 3..0)
                TCIF1: u1,
                reserved16: u4,
                ///  Stream x FIFO error interrupt flag (x=3..0)
                FEIF2: u1,
                reserved18: u1,
                ///  Stream x direct mode error interrupt flag (x=3..0)
                DMEIF2: u1,
                ///  Stream x transfer error interrupt flag (x=3..0)
                TEIF2: u1,
                ///  Stream x half transfer interrupt flag (x=3..0)
                HTIF2: u1,
                ///  Stream x transfer complete interrupt flag (x = 3..0)
                TCIF2: u1,
                ///  Stream x FIFO error interrupt flag (x=3..0)
                FEIF3: u1,
                reserved24: u1,
                ///  Stream x direct mode error interrupt flag (x=3..0)
                DMEIF3: u1,
                ///  Stream x transfer error interrupt flag (x=3..0)
                TEIF3: u1,
                ///  Stream x half transfer interrupt flag (x=3..0)
                HTIF3: u1,
                ///  Stream x transfer complete interrupt flag (x = 3..0)
                TCIF3: u1,
                padding: u4,
            }),
            ///  high interrupt status register
            HISR: mmio.Mmio(packed struct(u32) {
                ///  Stream x FIFO error interrupt flag (x=7..4)
                FEIF4: u1,
                reserved2: u1,
                ///  Stream x direct mode error interrupt flag (x=7..4)
                DMEIF4: u1,
                ///  Stream x transfer error interrupt flag (x=7..4)
                TEIF4: u1,
                ///  Stream x half transfer interrupt flag (x=7..4)
                HTIF4: u1,
                ///  Stream x transfer complete interrupt flag (x=7..4)
                TCIF4: u1,
                ///  Stream x FIFO error interrupt flag (x=7..4)
                FEIF5: u1,
                reserved8: u1,
                ///  Stream x direct mode error interrupt flag (x=7..4)
                DMEIF5: u1,
                ///  Stream x transfer error interrupt flag (x=7..4)
                TEIF5: u1,
                ///  Stream x half transfer interrupt flag (x=7..4)
                HTIF5: u1,
                ///  Stream x transfer complete interrupt flag (x=7..4)
                TCIF5: u1,
                reserved16: u4,
                ///  Stream x FIFO error interrupt flag (x=7..4)
                FEIF6: u1,
                reserved18: u1,
                ///  Stream x direct mode error interrupt flag (x=7..4)
                DMEIF6: u1,
                ///  Stream x transfer error interrupt flag (x=7..4)
                TEIF6: u1,
                ///  Stream x half transfer interrupt flag (x=7..4)
                HTIF6: u1,
                ///  Stream x transfer complete interrupt flag (x=7..4)
                TCIF6: u1,
                ///  Stream x FIFO error interrupt flag (x=7..4)
                FEIF7: u1,
                reserved24: u1,
                ///  Stream x direct mode error interrupt flag (x=7..4)
                DMEIF7: u1,
                ///  Stream x transfer error interrupt flag (x=7..4)
                TEIF7: u1,
                ///  Stream x half transfer interrupt flag (x=7..4)
                HTIF7: u1,
                ///  Stream x transfer complete interrupt flag (x=7..4)
                TCIF7: u1,
                padding: u4,
            }),
            ///  low interrupt flag clear register
            LIFCR: mmio.Mmio(packed struct(u32) {
                ///  Stream x clear FIFO error interrupt flag (x = 3..0)
                CFEIF0: u1,
                reserved2: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 3..0)
                CDMEIF0: u1,
                ///  Stream x clear transfer error interrupt flag (x = 3..0)
                CTEIF0: u1,
                ///  Stream x clear half transfer interrupt flag (x = 3..0)
                CHTIF0: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 3..0)
                CTCIF0: u1,
                ///  Stream x clear FIFO error interrupt flag (x = 3..0)
                CFEIF1: u1,
                reserved8: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 3..0)
                CDMEIF1: u1,
                ///  Stream x clear transfer error interrupt flag (x = 3..0)
                CTEIF1: u1,
                ///  Stream x clear half transfer interrupt flag (x = 3..0)
                CHTIF1: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 3..0)
                CTCIF1: u1,
                reserved16: u4,
                ///  Stream x clear FIFO error interrupt flag (x = 3..0)
                CFEIF2: u1,
                reserved18: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 3..0)
                CDMEIF2: u1,
                ///  Stream x clear transfer error interrupt flag (x = 3..0)
                CTEIF2: u1,
                ///  Stream x clear half transfer interrupt flag (x = 3..0)
                CHTIF2: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 3..0)
                CTCIF2: u1,
                ///  Stream x clear FIFO error interrupt flag (x = 3..0)
                CFEIF3: u1,
                reserved24: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 3..0)
                CDMEIF3: u1,
                ///  Stream x clear transfer error interrupt flag (x = 3..0)
                CTEIF3: u1,
                ///  Stream x clear half transfer interrupt flag (x = 3..0)
                CHTIF3: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 3..0)
                CTCIF3: u1,
                padding: u4,
            }),
            ///  high interrupt flag clear register
            HIFCR: mmio.Mmio(packed struct(u32) {
                ///  Stream x clear FIFO error interrupt flag (x = 7..4)
                CFEIF4: u1,
                reserved2: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 7..4)
                CDMEIF4: u1,
                ///  Stream x clear transfer error interrupt flag (x = 7..4)
                CTEIF4: u1,
                ///  Stream x clear half transfer interrupt flag (x = 7..4)
                CHTIF4: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 7..4)
                CTCIF4: u1,
                ///  Stream x clear FIFO error interrupt flag (x = 7..4)
                CFEIF5: u1,
                reserved8: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 7..4)
                CDMEIF5: u1,
                ///  Stream x clear transfer error interrupt flag (x = 7..4)
                CTEIF5: u1,
                ///  Stream x clear half transfer interrupt flag (x = 7..4)
                CHTIF5: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 7..4)
                CTCIF5: u1,
                reserved16: u4,
                ///  Stream x clear FIFO error interrupt flag (x = 7..4)
                CFEIF6: u1,
                reserved18: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 7..4)
                CDMEIF6: u1,
                ///  Stream x clear transfer error interrupt flag (x = 7..4)
                CTEIF6: u1,
                ///  Stream x clear half transfer interrupt flag (x = 7..4)
                CHTIF6: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 7..4)
                CTCIF6: u1,
                ///  Stream x clear FIFO error interrupt flag (x = 7..4)
                CFEIF7: u1,
                reserved24: u1,
                ///  Stream x clear direct mode error interrupt flag (x = 7..4)
                CDMEIF7: u1,
                ///  Stream x clear transfer error interrupt flag (x = 7..4)
                CTEIF7: u1,
                ///  Stream x clear half transfer interrupt flag (x = 7..4)
                CHTIF7: u1,
                ///  Stream x clear transfer complete interrupt flag (x = 7..4)
                CTCIF7: u1,
                padding: u4,
            }),
            ///  stream x configuration register
            S0CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                reserved21: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S0NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S0PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S0M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S0M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S0FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S1CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S1NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S1PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S1M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S1M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S1FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S2CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S2NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S2PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S2M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S2M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S2FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S3CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S3NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S3PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S3M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S3M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S3FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S4CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S4NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S4PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S4M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S4M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S4FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S5CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S5NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S5PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S5M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S5M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S5FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S6CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S6NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S6PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S6M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S6M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S6FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
            ///  stream x configuration register
            S7CR: mmio.Mmio(packed struct(u32) {
                ///  Stream enable / flag stream ready when read low
                EN: u1,
                ///  Direct mode error interrupt enable
                DMEIE: u1,
                ///  Transfer error interrupt enable
                TEIE: u1,
                ///  Half transfer interrupt enable
                HTIE: u1,
                ///  Transfer complete interrupt enable
                TCIE: u1,
                ///  Peripheral flow controller
                PFCTRL: u1,
                ///  Data transfer direction
                DIR: u2,
                ///  Circular mode
                CIRC: u1,
                ///  Peripheral increment mode
                PINC: u1,
                ///  Memory increment mode
                MINC: u1,
                ///  Peripheral data size
                PSIZE: u2,
                ///  Memory data size
                MSIZE: u2,
                ///  Peripheral increment offset size
                PINCOS: u1,
                ///  Priority level
                PL: u2,
                ///  Double buffer mode
                DBM: u1,
                ///  Current target (only in double buffer mode)
                CT: u1,
                ///  ACK
                ACK: u1,
                ///  Peripheral burst transfer configuration
                PBURST: u2,
                ///  Memory burst transfer configuration
                MBURST: u2,
                padding: u7,
            }),
            ///  stream x number of data register
            S7NDTR: mmio.Mmio(packed struct(u32) {
                ///  Number of data items to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  stream x peripheral address register
            S7PAR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address
                PA: u32,
            }),
            ///  stream x memory 0 address register
            S7M0AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 0 address
                M0A: u32,
            }),
            ///  stream x memory 1 address register
            S7M1AR: mmio.Mmio(packed struct(u32) {
                ///  Memory 1 address (used in case of Double buffer mode)
                M1A: u32,
            }),
            ///  stream x FIFO control register
            S7FCR: mmio.Mmio(packed struct(u32) {
                ///  FIFO threshold selection
                FTH: u2,
                ///  Direct mode disable
                DMDIS: u1,
                ///  FIFO status
                FS: u3,
                reserved7: u1,
                ///  FIFO error interrupt enable
                FEIE: u1,
                padding: u24,
            }),
        };

        ///  Universal synchronous asynchronous receiver transmitter
        pub const USART1 = extern struct {
            ///  Control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  USART enable
                UE: u1,
                ///  USART enable in Stop mode
                UESM: u1,
                ///  Receiver enable
                RE: u1,
                ///  Transmitter enable
                TE: u1,
                ///  IDLE interrupt enable
                IDLEIE: u1,
                ///  RXNE interrupt enable
                RXNEIE: u1,
                ///  Transmission complete interrupt enable
                TCIE: u1,
                ///  interrupt enable
                TXEIE: u1,
                ///  PE interrupt enable
                PEIE: u1,
                ///  Parity selection
                PS: u1,
                ///  Parity control enable
                PCE: u1,
                ///  Receiver wakeup method
                WAKE: u1,
                ///  Word length
                M0: u1,
                ///  Mute mode enable
                MME: u1,
                ///  Character match interrupt enable
                CMIE: u1,
                ///  Oversampling mode
                OVER8: u1,
                ///  DEDT0
                DEDT0: u1,
                ///  DEDT1
                DEDT1: u1,
                ///  DEDT2
                DEDT2: u1,
                ///  DEDT3
                DEDT3: u1,
                ///  Driver Enable de-assertion time
                DEDT4: u1,
                ///  DEAT0
                DEAT0: u1,
                ///  DEAT1
                DEAT1: u1,
                ///  DEAT2
                DEAT2: u1,
                ///  DEAT3
                DEAT3: u1,
                ///  Driver Enable assertion time
                DEAT4: u1,
                ///  Receiver timeout interrupt enable
                RTOIE: u1,
                ///  End of Block interrupt enable
                EOBIE: u1,
                ///  Word length
                M1: u1,
                ///  FIFO mode enable
                FIFOEN: u1,
                ///  TXFIFO empty interrupt enable
                TXFEIE: u1,
                ///  RXFIFO Full interrupt enable
                RXFFIE: u1,
            }),
            ///  Control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Synchronous Slave mode enable
                SLVEN: u1,
                reserved3: u2,
                ///  When the DSI_NSS bit is set, the NSS pin input is ignored
                DIS_NSS: u1,
                ///  7-bit Address Detection/4-bit Address Detection
                ADDM7: u1,
                ///  LIN break detection length
                LBDL: u1,
                ///  LIN break detection interrupt enable
                LBDIE: u1,
                reserved8: u1,
                ///  Last bit clock pulse
                LBCL: u1,
                ///  Clock phase
                CPHA: u1,
                ///  Clock polarity
                CPOL: u1,
                ///  Clock enable
                CLKEN: u1,
                ///  STOP bits
                STOP: u2,
                ///  LIN mode enable
                LINEN: u1,
                ///  Swap TX/RX pins
                SWAP: u1,
                ///  RX pin active level inversion
                RXINV: u1,
                ///  TX pin active level inversion
                TXINV: u1,
                ///  Binary data inversion
                TAINV: u1,
                ///  Most significant bit first
                MSBFIRST: u1,
                ///  Auto baud rate enable
                ABREN: u1,
                ///  ABRMOD0
                ABRMOD0: u1,
                ///  Auto baud rate mode
                ABRMOD1: u1,
                ///  Receiver timeout enable
                RTOEN: u1,
                ///  Address of the USART node
                ADD0_3: u4,
                ///  Address of the USART node
                ADD4_7: u4,
            }),
            ///  Control register 3
            CR3: mmio.Mmio(packed struct(u32) {
                ///  Error interrupt enable
                EIE: u1,
                ///  Ir mode enable
                IREN: u1,
                ///  Ir low-power
                IRLP: u1,
                ///  Half-duplex selection
                HDSEL: u1,
                ///  Smartcard NACK enable
                NACK: u1,
                ///  Smartcard mode enable
                SCEN: u1,
                ///  DMA enable receiver
                DMAR: u1,
                ///  DMA enable transmitter
                DMAT: u1,
                ///  RTS enable
                RTSE: u1,
                ///  CTS enable
                CTSE: u1,
                ///  CTS interrupt enable
                CTSIE: u1,
                ///  One sample bit method enable
                ONEBIT: u1,
                ///  Overrun Disable
                OVRDIS: u1,
                ///  DMA Disable on Reception Error
                DDRE: u1,
                ///  Driver enable mode
                DEM: u1,
                ///  Driver enable polarity selection
                DEP: u1,
                reserved17: u1,
                ///  Smartcard auto-retry count
                SCARCNT: u3,
                ///  Wakeup from Stop mode interrupt flag selection
                WUS: u2,
                ///  Wakeup from Stop mode interrupt enable
                WUFIE: u1,
                ///  TXFIFO threshold interrupt enable
                TXFTIE: u1,
                ///  Transmission Complete before guard time, interrupt enable
                TCBGTIE: u1,
                ///  Receive FIFO threshold configuration
                RXFTCFG: u3,
                ///  RXFIFO threshold interrupt enable
                RXFTIE: u1,
                ///  TXFIFO threshold configuration
                TXFTCFG: u3,
            }),
            ///  Baud rate register
            BRR: mmio.Mmio(packed struct(u32) {
                ///  DIV_Fraction
                BRR_0_3: u4,
                ///  DIV_Mantissa
                BRR_4_15: u12,
                padding: u16,
            }),
            ///  Guard time and prescaler register
            GTPR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u8,
                ///  Guard time value
                GT: u8,
                padding: u16,
            }),
            ///  Receiver timeout register
            RTOR: mmio.Mmio(packed struct(u32) {
                ///  Receiver timeout value
                RTO: u24,
                ///  Block Length
                BLEN: u8,
            }),
            ///  Request register
            RQR: mmio.Mmio(packed struct(u32) {
                ///  Auto baud rate request
                ABRRQ: u1,
                ///  Send break request
                SBKRQ: u1,
                ///  Mute mode request
                MMRQ: u1,
                ///  Receive data flush request
                RXFRQ: u1,
                ///  Transmit data flush request
                TXFRQ: u1,
                padding: u27,
            }),
            ///  Interrupt & status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  PE
                PE: u1,
                ///  FE
                FE: u1,
                ///  NF
                NF: u1,
                ///  ORE
                ORE: u1,
                ///  IDLE
                IDLE: u1,
                ///  RXNE
                RXNE: u1,
                ///  TC
                TC: u1,
                ///  TXE
                TXE: u1,
                ///  LBDF
                LBDF: u1,
                ///  CTSIF
                CTSIF: u1,
                ///  CTS
                CTS: u1,
                ///  RTOF
                RTOF: u1,
                ///  EOBF
                EOBF: u1,
                ///  SPI slave underrun error flag
                UDR: u1,
                ///  ABRE
                ABRE: u1,
                ///  ABRF
                ABRF: u1,
                ///  BUSY
                BUSY: u1,
                ///  CMF
                CMF: u1,
                ///  SBKF
                SBKF: u1,
                ///  RWU
                RWU: u1,
                ///  WUF
                WUF: u1,
                ///  TEACK
                TEACK: u1,
                ///  REACK
                REACK: u1,
                ///  TXFIFO Empty
                TXFE: u1,
                ///  RXFIFO Full
                RXFF: u1,
                ///  Transmission complete before guard time flag
                TCBGT: u1,
                ///  RXFIFO threshold flag
                RXFT: u1,
                ///  TXFIFO threshold flag
                TXFT: u1,
                padding: u4,
            }),
            ///  Interrupt flag clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Parity error clear flag
                PECF: u1,
                ///  Framing error clear flag
                FECF: u1,
                ///  Noise detected clear flag
                NCF: u1,
                ///  Overrun error clear flag
                ORECF: u1,
                ///  Idle line detected clear flag
                IDLECF: u1,
                ///  TXFIFO empty clear flag
                TXFECF: u1,
                ///  Transmission complete clear flag
                TCCF: u1,
                ///  Transmission complete before Guard time clear flag
                TCBGTC: u1,
                ///  LIN break detection clear flag
                LBDCF: u1,
                ///  CTS clear flag
                CTSCF: u1,
                reserved11: u1,
                ///  Receiver timeout clear flag
                RTOCF: u1,
                ///  End of block clear flag
                EOBCF: u1,
                ///  SPI slave underrun clear flag
                UDRCF: u1,
                reserved17: u3,
                ///  Character match clear flag
                CMCF: u1,
                reserved20: u2,
                ///  Wakeup from Stop mode clear flag
                WUCF: u1,
                padding: u11,
            }),
            ///  Receive data register
            RDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data value
                RDR: u9,
                padding: u23,
            }),
            ///  Transmit data register
            TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data value
                TDR: u9,
                padding: u23,
            }),
            ///  USART prescaler register
            PRESC: mmio.Mmio(packed struct(u32) {
                ///  Clock prescaler
                PRESCALER: u4,
                padding: u28,
            }),
        };

        ///  SDMMC1
        pub const SDMMC1 = extern struct {
            ///  SDMMC power control register
            POWER: mmio.Mmio(packed struct(u32) {
                ///  SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
                PWRCTRL: u2,
                ///  Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
                VSWITCH: u1,
                ///  Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
                VSWITCHEN: u1,
                ///  Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
                DIRPOL: u1,
                padding: u27,
            }),
            ///  The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
            CLKCR: mmio.Mmio(packed struct(u32) {
                ///  Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
                CLKDIV: u10,
                reserved12: u2,
                ///  Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
                PWRSAV: u1,
                reserved14: u1,
                ///  Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
                WIDBUS: u2,
                ///  SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
                NEGEDGE: u1,
                ///  Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
                HWFC_EN: u1,
                ///  Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
                DDR: u1,
                ///  Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
                BUSSPEED: u1,
                ///  Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
                SELCLKRX: u2,
                padding: u10,
            }),
            ///  The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
            ARGR: mmio.Mmio(packed struct(u32) {
                ///  Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
                CMDARG: u32,
            }),
            ///  The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
            CMDR: mmio.Mmio(packed struct(u32) {
                ///  Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
                CMDINDEX: u6,
                ///  The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
                CMDTRANS: u1,
                ///  The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
                CMDSTOP: u1,
                ///  Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
                WAITRESP: u2,
                ///  CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
                WAITINT: u1,
                ///  CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
                WAITPEND: u1,
                ///  Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
                CPSMEN: u1,
                ///  Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
                DTHOLD: u1,
                ///  Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
                BOOTMODE: u1,
                ///  Enable boot mode procedure.
                BOOTEN: u1,
                ///  The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
                CMDSUSPEND: u1,
                padding: u15,
            }),
            ///  SDMMC command response register
            RESPCMDR: mmio.Mmio(packed struct(u32) {
                ///  Response command index
                RESPCMD: u6,
                padding: u26,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            RESP1R: mmio.Mmio(packed struct(u32) {
                ///  see Table 432
                CARDSTATUS1: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            RESP2R: mmio.Mmio(packed struct(u32) {
                ///  see Table404.
                CARDSTATUS2: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            RESP3R: mmio.Mmio(packed struct(u32) {
                ///  see Table404.
                CARDSTATUS3: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            RESP4R: mmio.Mmio(packed struct(u32) {
                ///  see Table404.
                CARDSTATUS4: u32,
            }),
            ///  The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
            DTIMER: mmio.Mmio(packed struct(u32) {
                ///  Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
                DATATIME: u32,
            }),
            ///  The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
            DLENR: mmio.Mmio(packed struct(u32) {
                ///  Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
                DATALENGTH: u25,
                padding: u7,
            }),
            ///  The SDMMC_DCTRL register control the data path state machine (DPSM).
            DCTRL: mmio.Mmio(packed struct(u32) {
                ///  Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
                DTEN: u1,
                ///  Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                DTDIR: u1,
                ///  Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                DTMODE: u2,
                ///  Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
                DBLOCKSIZE: u4,
                ///  Read wait start. If this bit is set, read wait operation starts.
                RWSTART: u1,
                ///  Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
                RWSTOP: u1,
                ///  Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                RWMOD: u1,
                ///  SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
                SDIOEN: u1,
                ///  Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                BOOTACKEN: u1,
                ///  FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
                FIFORST: u1,
                padding: u18,
            }),
            ///  The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
            DCNTR: mmio.Mmio(packed struct(u32) {
                ///  Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
                DATACOUNT: u25,
                padding: u7,
            }),
            ///  The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
            STAR: mmio.Mmio(packed struct(u32) {
                ///  Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                CCRCFAIL: u1,
                ///  Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DCRCFAIL: u1,
                ///  Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
                CTIMEOUT: u1,
                ///  Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DTIMEOUT: u1,
                ///  Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                TXUNDERR: u1,
                ///  Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                RXOVERR: u1,
                ///  Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                CMDREND: u1,
                ///  Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                CMDSENT: u1,
                ///  Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DATAEND: u1,
                ///  Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DHOLD: u1,
                ///  Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DBCKEND: u1,
                ///  Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                DABORT: u1,
                ///  Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
                DPSMACT: u1,
                ///  Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
                CPSMACT: u1,
                ///  Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
                TXFIFOHE: u1,
                ///  Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
                RXFIFOHF: u1,
                ///  Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
                TXFIFOF: u1,
                ///  Receive FIFO full This bit is cleared when one FIFO location becomes empty.
                RXFIFOF: u1,
                ///  Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
                TXFIFOE: u1,
                ///  Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
                RXFIFOE: u1,
                ///  Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
                BUSYD0: u1,
                ///  end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                BUSYD0END: u1,
                ///  SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                SDIOIT: u1,
                ///  Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                ACKFAIL: u1,
                ///  Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                ACKTIMEOUT: u1,
                ///  Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                VSWEND: u1,
                ///  SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                CKSTOP: u1,
                ///  IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                IDMATE: u1,
                ///  IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
                IDMABTC: u1,
                padding: u3,
            }),
            ///  The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
            ICR: mmio.Mmio(packed struct(u32) {
                ///  CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
                CCRCFAILC: u1,
                ///  DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
                DCRCFAILC: u1,
                ///  CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
                CTIMEOUTC: u1,
                ///  DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
                DTIMEOUTC: u1,
                ///  TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
                TXUNDERRC: u1,
                ///  RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
                RXOVERRC: u1,
                ///  CMDREND flag clear bit Set by software to clear the CMDREND flag.
                CMDRENDC: u1,
                ///  CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
                CMDSENTC: u1,
                ///  DATAEND flag clear bit Set by software to clear the DATAEND flag.
                DATAENDC: u1,
                ///  DHOLD flag clear bit Set by software to clear the DHOLD flag.
                DHOLDC: u1,
                ///  DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
                DBCKENDC: u1,
                ///  DABORT flag clear bit Set by software to clear the DABORT flag.
                DABORTC: u1,
                reserved21: u9,
                ///  BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
                BUSYD0ENDC: u1,
                ///  SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
                SDIOITC: u1,
                ///  ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
                ACKFAILC: u1,
                ///  ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
                ACKTIMEOUTC: u1,
                ///  VSWEND flag clear bit Set by software to clear the VSWEND flag.
                VSWENDC: u1,
                ///  CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
                CKSTOPC: u1,
                ///  IDMA transfer error clear bit Set by software to clear the IDMATE flag.
                IDMATEC: u1,
                ///  IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
                IDMABTCC: u1,
                padding: u3,
            }),
            ///  The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
            MASKR: mmio.Mmio(packed struct(u32) {
                ///  Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
                CCRCFAILIE: u1,
                ///  Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
                DCRCFAILIE: u1,
                ///  Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
                CTIMEOUTIE: u1,
                ///  Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
                DTIMEOUTIE: u1,
                ///  Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
                TXUNDERRIE: u1,
                ///  Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
                RXOVERRIE: u1,
                ///  Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
                CMDRENDIE: u1,
                ///  Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
                CMDSENTIE: u1,
                ///  Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
                DATAENDIE: u1,
                ///  Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
                DHOLDIE: u1,
                ///  Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
                DBCKENDIE: u1,
                ///  Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
                DABORTIE: u1,
                reserved14: u2,
                ///  Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
                TXFIFOHEIE: u1,
                ///  Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
                RXFIFOHFIE: u1,
                reserved17: u1,
                ///  Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
                RXFIFOFIE: u1,
                ///  Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
                TXFIFOEIE: u1,
                reserved21: u2,
                ///  BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
                BUSYD0ENDIE: u1,
                ///  SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
                SDIOITIE: u1,
                ///  Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
                ACKFAILIE: u1,
                ///  Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
                ACKTIMEOUTIE: u1,
                ///  Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
                VSWENDIE: u1,
                ///  Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
                CKSTOPIE: u1,
                reserved28: u1,
                ///  IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
                IDMABTCIE: u1,
                padding: u3,
            }),
            ///  The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
            ACKTIMER: mmio.Mmio(packed struct(u32) {
                ///  Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
                ACKTIME: u25,
                padding: u7,
            }),
            reserved80: [12]u8,
            ///  The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
            IDMACTRLR: mmio.Mmio(packed struct(u32) {
                ///  IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                IDMAEN: u1,
                ///  Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                IDMABMODE: u1,
                ///  Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
                IDMABACT: u1,
                padding: u29,
            }),
            ///  The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
            IDMABSIZER: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
                IDMABNDT: u8,
                padding: u19,
            }),
            ///  The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
            IDMABASE0R: mmio.Mmio(packed struct(u32) {
                ///  Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
                IDMABASE0: u32,
            }),
            ///  The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
            IDMABASE1R: mmio.Mmio(packed struct(u32) {
                ///  Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
                IDMABASE1: u32,
            }),
            reserved128: [32]u8,
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            FIFOR: mmio.Mmio(packed struct(u32) {
                ///  Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
                FIFODATA: u32,
            }),
            reserved1012: [880]u8,
            ///  SDMMC IP version register
            VER: mmio.Mmio(packed struct(u32) {
                ///  IP minor revision number.
                MINREV: u4,
                ///  IP major revision number.
                MAJREV: u4,
                padding: u24,
            }),
            ///  SDMMC IP identification register
            ID: mmio.Mmio(packed struct(u32) {
                ///  SDMMC IP identification.
                IP_ID: u32,
            }),
        };

        ///  High Resolution Timer: Master Timers
        pub const HRTIM_Master = extern struct {
            ///  Master Timer Control Register
            MCR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Master Clock prescaler
                CK_PSC: u3,
                ///  Master Continuous mode
                CONT: u1,
                ///  Master Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                reserved8: u2,
                ///  ynchronization input
                SYNC_IN: u2,
                ///  Synchronization Resets Master
                SYNCRSTM: u1,
                ///  Synchronization Starts Master
                SYNCSTRTM: u1,
                ///  Synchronization output
                SYNC_OUT: u2,
                ///  Synchronization source
                SYNC_SRC: u2,
                ///  Master Counter enable
                MCEN: u1,
                ///  Timer A counter enable
                TACEN: u1,
                ///  Timer B counter enable
                TBCEN: u1,
                ///  Timer C counter enable
                TCCEN: u1,
                ///  Timer D counter enable
                TDCEN: u1,
                ///  Timer E counter enable
                TECEN: u1,
                reserved25: u3,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                reserved29: u1,
                ///  Master Timer Repetition update
                MREPU: u1,
                ///  Burst DMA Update
                BRSTDMA: u2,
            }),
            ///  Master Timer Interrupt Status Register
            MISR: mmio.Mmio(packed struct(u32) {
                ///  Master Compare 1 Interrupt Flag
                MCMP1: u1,
                ///  Master Compare 2 Interrupt Flag
                MCMP2: u1,
                ///  Master Compare 3 Interrupt Flag
                MCMP3: u1,
                ///  Master Compare 4 Interrupt Flag
                MCMP4: u1,
                ///  Master Repetition Interrupt Flag
                MREP: u1,
                ///  Sync Input Interrupt Flag
                SYNC: u1,
                ///  Master Update Interrupt Flag
                MUPD: u1,
                padding: u25,
            }),
            ///  Master Timer Interrupt Clear Register
            MICR: mmio.Mmio(packed struct(u32) {
                ///  Master Compare 1 Interrupt flag clear
                MCMP1C: u1,
                ///  Master Compare 2 Interrupt flag clear
                MCMP2C: u1,
                ///  Master Compare 3 Interrupt flag clear
                MCMP3C: u1,
                ///  Master Compare 4 Interrupt flag clear
                MCMP4C: u1,
                ///  Repetition Interrupt flag clear
                MREPC: u1,
                ///  Sync Input Interrupt flag clear
                SYNCC: u1,
                ///  Master update Interrupt flag clear
                MUPDC: u1,
                padding: u25,
            }),
            ///  MDIER4
            MDIER4: mmio.Mmio(packed struct(u32) {
                ///  MCMP1IE
                MCMP1IE: u1,
                ///  MCMP2IE
                MCMP2IE: u1,
                ///  MCMP3IE
                MCMP3IE: u1,
                ///  MCMP4IE
                MCMP4IE: u1,
                ///  MREPIE
                MREPIE: u1,
                ///  SYNCIE
                SYNCIE: u1,
                ///  MUPDIE
                MUPDIE: u1,
                reserved16: u9,
                ///  MCMP1DE
                MCMP1DE: u1,
                ///  MCMP2DE
                MCMP2DE: u1,
                ///  MCMP3DE
                MCMP3DE: u1,
                ///  MCMP4DE
                MCMP4DE: u1,
                ///  MREPDE
                MREPDE: u1,
                ///  SYNCDE
                SYNCDE: u1,
                ///  MUPDDE
                MUPDDE: u1,
                padding: u9,
            }),
            ///  Master Timer Counter Register
            MCNTR: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                MCNT: u16,
                padding: u16,
            }),
            ///  Master Timer Period Register
            MPER: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Period value
                MPER: u16,
                padding: u16,
            }),
            ///  Master Timer Repetition Register
            MREP: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Repetition counter value
                MREP: u8,
                padding: u24,
            }),
            ///  Master Timer Compare 1 Register
            MCMP1R: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Compare 1 value
                MCMP1: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  Master Timer Compare 2 Register
            MCMP2R: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Compare 2 value
                MCMP2: u16,
                padding: u16,
            }),
            ///  Master Timer Compare 3 Register
            MCMP3R: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Compare 3 value
                MCMP3: u16,
                padding: u16,
            }),
            ///  Master Timer Compare 4 Register
            MCMP4R: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Compare 4 value
                MCMP4: u16,
                padding: u16,
            }),
        };

        ///  VREFBUF
        pub const VREFBUF = extern struct {
            ///  VREFBUF control and status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
                ENVR: u1,
                ///  High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
                HIZ: u1,
                reserved3: u1,
                ///  Voltage reference buffer ready
                VRR: u1,
                ///  Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
                VRS: u3,
                padding: u25,
            }),
            ///  VREFBUF calibration control register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
                TRIM: u6,
                padding: u26,
            }),
        };

        ///  IWDG
        pub const IWDG = extern struct {
            ///  Key register
            KR: mmio.Mmio(packed struct(u32) {
                ///  Key value (write only, read 0x0000) These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section23.3.6: Register access protection) Writing the key value CCCCh starts the watchdog (except if the hardware watchdog option is selected)
                KEY: u16,
                padding: u16,
            }),
            ///  Prescaler register
            PR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset.
                PR: u3,
                padding: u29,
            }),
            ///  Reload register
            RLR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset.
                RL: u12,
                padding: u20,
            }),
            ///  Status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.
                PVU: u1,
                ///  Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
                RVU: u1,
                ///  Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
                WVU: u1,
                padding: u29,
            }),
            ///  Window register
            WINR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset.
                WIN: u12,
                padding: u20,
            }),
        };

        ///  WWDG
        pub const WWDG = extern struct {
            ///  Control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).
                T: u7,
                ///  Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
                WDGA: u1,
                padding: u24,
            }),
            ///  Configuration register
            CFR: mmio.Mmio(packed struct(u32) {
                ///  7-bit window value These bits contain the window value to be compared to the downcounter.
                W: u7,
                reserved9: u2,
                ///  Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.
                EWI: u1,
                reserved11: u1,
                ///  Timer base The time base of the prescaler can be modified as follows:
                WDGTB: u2,
                padding: u19,
            }),
            ///  Status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Early wakeup interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.
                EWIF: u1,
                padding: u31,
            }),
        };

        ///  PWR
        pub const PWR = extern struct {
            ///  PWR control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)
                LPDS: u1,
                reserved4: u3,
                ///  Programmable voltage detector enable
                PVDE: u1,
                ///  Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details.
                PLS: u3,
                ///  Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
                DBP: u1,
                ///  Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
                FLPS: u1,
                reserved14: u4,
                ///  System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance.
                SVOS: u2,
                ///  Peripheral voltage monitor on VDDA enable
                AVDEN: u1,
                ///  Analog voltage detector level selection These bits select the voltage threshold detected by the AVD.
                ALS: u2,
                padding: u13,
            }),
            ///  PWR control status register 1
            CSR1: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.
                PVDO: u1,
                reserved13: u8,
                ///  Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
                ACTVOSRDY: u1,
                ///  VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU.
                ACTVOS: u2,
                ///  Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
                AVDO: u1,
                padding: u15,
            }),
            ///  This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes.
                BREN: u1,
                reserved4: u3,
                ///  VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled.
                MONEN: u1,
                reserved16: u11,
                ///  Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready.
                BRRDY: u1,
                reserved20: u3,
                ///  VBAT level monitoring versus low threshold
                VBATL: u1,
                ///  VBAT level monitoring versus high threshold
                VBATH: u1,
                ///  Temperature level monitoring versus low threshold
                TEMPL: u1,
                ///  Temperature level monitoring versus high threshold
                TEMPH: u1,
                padding: u8,
            }),
            ///  Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
            CR3: mmio.Mmio(packed struct(u32) {
                ///  Power management unit bypass
                BYPASS: u1,
                ///  Low drop-out regulator enable
                LDOEN: u1,
                ///  SD converter Enable
                SCUEN: u1,
                reserved8: u5,
                ///  VBAT charging enable
                VBE: u1,
                ///  VBAT charging resistor selection
                VBRS: u1,
                reserved24: u14,
                ///  VDD33USB voltage level detector enable.
                USB33DEN: u1,
                ///  USB regulator enable.
                USBREGEN: u1,
                ///  USB supply ready.
                USB33RDY: u1,
                padding: u5,
            }),
            ///  This register allows controlling CPU1 power.
            CPUCR: mmio.Mmio(packed struct(u32) {
                ///  D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain.
                PDDS_D1: u1,
                ///  D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain.
                PDDS_D2: u1,
                ///  System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain.
                PDDS_D3: u1,
                reserved5: u2,
                ///  STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit.
                STOPF: u1,
                ///  System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit
                SBF: u1,
                ///  D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode.
                SBF_D1: u1,
                ///  D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode.
                SBF_D2: u1,
                ///  Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware.
                CSSF: u1,
                reserved11: u1,
                ///  Keep system D3 domain in Run mode regardless of the CPU sub-systems modes
                RUN_D3: u1,
                padding: u20,
            }),
            reserved24: [4]u8,
            ///  This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
            D3CR: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                ///  VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3).
                VOSRDY: u1,
                ///  Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling.
                VOS: u2,
                padding: u16,
            }),
            reserved32: [4]u8,
            ///  reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
            WKUPCR: mmio.Mmio(packed struct(u32) {
                ///  Clear Wakeup pin flag for WKUP. These bits are always read as 0.
                WKUPC: u6,
                padding: u26,
            }),
            ///  reset only by system reset, not reset by wakeup from Standby mode
            WKUPFR: mmio.Mmio(packed struct(u32) {
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF1: u1,
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF2: u1,
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF3: u1,
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF4: u1,
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF5: u1,
                ///  Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
                WKUPF6: u1,
                padding: u26,
            }),
            ///  Reset only by system reset, not reset by wakeup from Standby mode
            WKUPEPR: mmio.Mmio(packed struct(u32) {
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN1: u1,
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN2: u1,
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN3: u1,
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN4: u1,
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN5: u1,
                ///  Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
                WKUPEN6: u1,
                reserved8: u2,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP1: u1,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP2: u1,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP3: u1,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP4: u1,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP5: u1,
                ///  Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
                WKUPP6: u1,
                reserved16: u2,
                ///  Wakeup pin pull configuration
                WKUPPUPD1: u2,
                ///  Wakeup pin pull configuration
                WKUPPUPD2: u2,
                ///  Wakeup pin pull configuration
                WKUPPUPD3: u2,
                ///  Wakeup pin pull configuration
                WKUPPUPD4: u2,
                ///  Wakeup pin pull configuration
                WKUPPUPD5: u2,
                ///  Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode.
                WKUPPUPD6: u2,
                padding: u4,
            }),
        };

        ///  Serial peripheral interface
        pub const SPI1 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Serial Peripheral Enable
                SPE: u1,
                reserved8: u7,
                ///  Master automatic SUSP in Receive mode
                MASRX: u1,
                ///  Master transfer start
                CSTART: u1,
                ///  Master SUSPend request
                CSUSP: u1,
                ///  Rx/Tx direction at Half-duplex mode
                HDDIR: u1,
                ///  Internal SS signal input level
                SSI: u1,
                ///  32-bit CRC polynomial configuration
                CRC33_17: u1,
                ///  CRC calculation initialization pattern control for receiver
                RCRCI: u1,
                ///  CRC calculation initialization pattern control for transmitter
                TCRCI: u1,
                ///  Locking the AF configuration of associated IOs
                IOLOCK: u1,
                padding: u15,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Number of data at current transfer
                TSIZE: u16,
                ///  Number of data transfer extension to be reload into TSIZE just when a previous
                TSER: u16,
            }),
            ///  configuration register 1
            CFG1: mmio.Mmio(packed struct(u32) {
                ///  Number of bits in at single SPI data frame
                DSIZE: u5,
                ///  threshold level
                FTHVL: u4,
                ///  Behavior of slave transmitter at underrun condition
                UDRCFG: u2,
                ///  Detection of underrun condition at slave transmitter
                UDRDET: u2,
                reserved14: u1,
                ///  Rx DMA stream enable
                RXDMAEN: u1,
                ///  Tx DMA stream enable
                TXDMAEN: u1,
                ///  Length of CRC frame to be transacted and compared
                CRCSIZE: u5,
                reserved22: u1,
                ///  Hardware CRC computation enable
                CRCEN: u1,
                reserved28: u5,
                ///  Master baud rate
                MBR: u3,
                padding: u1,
            }),
            ///  configuration register 2
            CFG2: mmio.Mmio(packed struct(u32) {
                ///  Master SS Idleness
                MSSI: u4,
                ///  Master Inter-Data Idleness
                MIDI: u4,
                reserved15: u7,
                ///  Swap functionality of MISO and MOSI pins
                IOSWP: u1,
                reserved17: u1,
                ///  SPI Communication Mode
                COMM: u2,
                ///  Serial Protocol
                SP: u3,
                ///  SPI Master
                MASTER: u1,
                ///  Data frame format
                LSBFRST: u1,
                ///  Clock phase
                CPHA: u1,
                ///  Clock polarity
                CPOL: u1,
                ///  Software management of SS signal input
                SSM: u1,
                reserved28: u1,
                ///  SS input/output polarity
                SSIOP: u1,
                ///  SS output enable
                SSOE: u1,
                ///  SS output management in master mode
                SSOM: u1,
                ///  Alternate function GPIOs control
                AFCNTR: u1,
            }),
            ///  Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                ///  RXP Interrupt Enable
                RXPIE: u1,
                ///  TXP interrupt enable
                TXPIE: u1,
                ///  DXP interrupt enabled
                DPXPIE: u1,
                ///  EOT, SUSP and TXC interrupt enable
                EOTIE: u1,
                ///  TXTFIE interrupt enable
                TXTFIE: u1,
                ///  UDR interrupt enable
                UDRIE: u1,
                ///  OVR interrupt enable
                OVRIE: u1,
                ///  CRC Interrupt enable
                CRCEIE: u1,
                ///  TIFRE interrupt enable
                TIFREIE: u1,
                ///  Mode Fault interrupt enable
                MODFIE: u1,
                ///  Additional number of transactions reload interrupt enable
                TSERFIE: u1,
                padding: u21,
            }),
            ///  Status Register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Rx-Packet available
                RXP: u1,
                ///  Tx-Packet space available
                TXP: u1,
                ///  Duplex Packet
                DXP: u1,
                ///  End Of Transfer
                EOT: u1,
                ///  Transmission Transfer Filled
                TXTF: u1,
                ///  Underrun at slave transmission mode
                UDR: u1,
                ///  Overrun
                OVR: u1,
                ///  CRC Error
                CRCE: u1,
                ///  TI frame format error
                TIFRE: u1,
                ///  Mode Fault
                MODF: u1,
                ///  Additional number of SPI data to be transacted was reload
                TSERF: u1,
                ///  SUSPend
                SUSP: u1,
                ///  TxFIFO transmission complete
                TXC: u1,
                ///  RxFIFO Packing LeVeL
                RXPLVL: u2,
                ///  RxFIFO Word Not Empty
                RXWNE: u1,
                ///  Number of data frames remaining in current TSIZE session
                CTSIZE: u16,
            }),
            ///  Interrupt/Status Flags Clear Register
            IFCR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  End Of Transfer flag clear
                EOTC: u1,
                ///  Transmission Transfer Filled flag clear
                TXTFC: u1,
                ///  Underrun flag clear
                UDRC: u1,
                ///  Overrun flag clear
                OVRC: u1,
                ///  CRC Error flag clear
                CRCEC: u1,
                ///  TI frame format error flag clear
                TIFREC: u1,
                ///  Mode Fault flag clear
                MODFC: u1,
                ///  TSERFC flag clear
                TSERFC: u1,
                ///  SUSPend flag clear
                SUSPC: u1,
                padding: u20,
            }),
            reserved32: [4]u8,
            ///  Transmit Data Register
            TXDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data register
                TXDR: u32,
            }),
            reserved48: [12]u8,
            ///  Receive Data Register
            RXDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data register
                RXDR: u32,
            }),
            reserved64: [12]u8,
            ///  Polynomial Register
            CRCPOLY: mmio.Mmio(packed struct(u32) {
                ///  CRC polynomial register
                CRCPOLY: u32,
            }),
            ///  Transmitter CRC Register
            TXCRC: mmio.Mmio(packed struct(u32) {
                ///  CRC register for transmitter
                TXCRC: u32,
            }),
            ///  Receiver CRC Register
            RXCRC: mmio.Mmio(packed struct(u32) {
                ///  CRC register for receiver
                RXCRC: u32,
            }),
            ///  Underrun Data Register
            UDRDR: mmio.Mmio(packed struct(u32) {
                ///  Data at slave underrun condition
                UDRDR: u32,
            }),
            ///  configuration register
            CGFR: mmio.Mmio(packed struct(u32) {
                ///  I2S mode selection
                I2SMOD: u1,
                ///  I2S configuration mode
                I2SCFG: u3,
                ///  I2S standard selection
                I2SSTD: u2,
                reserved7: u1,
                ///  PCM frame synchronization
                PCMSYNC: u1,
                ///  Data length to be transferred
                DATLEN: u2,
                ///  Channel length (number of bits per audio channel)
                CHLEN: u1,
                ///  Serial audio clock polarity
                CKPOL: u1,
                ///  Word select inversion
                FIXCH: u1,
                ///  Fixed channel length in SLAVE
                WSINV: u1,
                ///  Data format
                DATFMT: u1,
                reserved16: u1,
                ///  I2S linear prescaler
                I2SDIV: u8,
                ///  Odd factor for the prescaler
                ODD: u1,
                ///  Master clock output enable
                MCKOE: u1,
                padding: u6,
            }),
        };

        ///  High Resolution Timer: TIMA
        pub const HRTIM_TIMA = extern struct {
            ///  Timerx Control Register
            TIMACR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Timer x Clock prescaler
                CK_PSCx: u3,
                ///  Continuous mode
                CONT: u1,
                ///  Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                ///  Push-Pull mode enable
                PSHPLL: u1,
                reserved10: u3,
                ///  Synchronization Resets Timer x
                SYNCRSTx: u1,
                ///  Synchronization Starts Timer x
                SYNCSTRTx: u1,
                ///  Delayed CMP2 mode
                DELCMP2: u2,
                ///  Delayed CMP4 mode
                DELCMP4: u2,
                reserved17: u1,
                ///  Timer x Repetition update
                TxREPU: u1,
                ///  Timerx reset update
                TxRSTU: u1,
                reserved20: u1,
                ///  TBU
                TBU: u1,
                ///  TCU
                TCU: u1,
                ///  TDU
                TDU: u1,
                ///  TEU
                TEU: u1,
                ///  Master Timer update
                MSTU: u1,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                ///  Update Gating
                UPDGAT: u4,
            }),
            ///  Timerx Interrupt Status Register
            TIMAISR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt Flag
                CMP1: u1,
                ///  Compare 2 Interrupt Flag
                CMP2: u1,
                ///  Compare 3 Interrupt Flag
                CMP3: u1,
                ///  Compare 4 Interrupt Flag
                CMP4: u1,
                ///  Repetition Interrupt Flag
                REP: u1,
                reserved6: u1,
                ///  Update Interrupt Flag
                UPD: u1,
                ///  Capture1 Interrupt Flag
                CPT1: u1,
                ///  Capture2 Interrupt Flag
                CPT2: u1,
                ///  Output 1 Set Interrupt Flag
                SETx1: u1,
                ///  Output 1 Reset Interrupt Flag
                RSTx1: u1,
                ///  Output 2 Set Interrupt Flag
                SETx2: u1,
                ///  Output 2 Reset Interrupt Flag
                RSTx2: u1,
                ///  Reset Interrupt Flag
                RST: u1,
                ///  Delayed Protection Flag
                DLYPRT: u1,
                reserved16: u1,
                ///  Current Push Pull Status
                CPPSTAT: u1,
                ///  Idle Push Pull Status
                IPPSTAT: u1,
                ///  Output 1 State
                O1STAT: u1,
                ///  Output 2 State
                O2STAT: u1,
                padding: u12,
            }),
            ///  Timerx Interrupt Clear Register
            TIMAICR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt flag Clear
                CMP1C: u1,
                ///  Compare 2 Interrupt flag Clear
                CMP2C: u1,
                ///  Compare 3 Interrupt flag Clear
                CMP3C: u1,
                ///  Compare 4 Interrupt flag Clear
                CMP4C: u1,
                ///  Repetition Interrupt flag Clear
                REPC: u1,
                reserved6: u1,
                ///  Update Interrupt flag Clear
                UPDC: u1,
                ///  Capture1 Interrupt flag Clear
                CPT1C: u1,
                ///  Capture2 Interrupt flag Clear
                CPT2C: u1,
                ///  Output 1 Set flag Clear
                SET1xC: u1,
                ///  Output 1 Reset flag Clear
                RSTx1C: u1,
                ///  Output 2 Set flag Clear
                SET2xC: u1,
                ///  Output 2 Reset flag Clear
                RSTx2C: u1,
                ///  Reset Interrupt flag Clear
                RSTC: u1,
                ///  Delayed Protection Flag Clear
                DLYPRTC: u1,
                padding: u17,
            }),
            ///  TIMxDIER5
            TIMADIER5: mmio.Mmio(packed struct(u32) {
                ///  CMP1IE
                CMP1IE: u1,
                ///  CMP2IE
                CMP2IE: u1,
                ///  CMP3IE
                CMP3IE: u1,
                ///  CMP4IE
                CMP4IE: u1,
                ///  REPIE
                REPIE: u1,
                reserved6: u1,
                ///  UPDIE
                UPDIE: u1,
                ///  CPT1IE
                CPT1IE: u1,
                ///  CPT2IE
                CPT2IE: u1,
                ///  SET1xIE
                SET1xIE: u1,
                ///  RSTx1IE
                RSTx1IE: u1,
                ///  SETx2IE
                SETx2IE: u1,
                ///  RSTx2IE
                RSTx2IE: u1,
                ///  RSTIE
                RSTIE: u1,
                ///  DLYPRTIE
                DLYPRTIE: u1,
                reserved16: u1,
                ///  CMP1DE
                CMP1DE: u1,
                ///  CMP2DE
                CMP2DE: u1,
                ///  CMP3DE
                CMP3DE: u1,
                ///  CMP4DE
                CMP4DE: u1,
                ///  REPDE
                REPDE: u1,
                reserved22: u1,
                ///  UPDDE
                UPDDE: u1,
                ///  CPT1DE
                CPT1DE: u1,
                ///  CPT2DE
                CPT2DE: u1,
                ///  SET1xDE
                SET1xDE: u1,
                ///  RSTx1DE
                RSTx1DE: u1,
                ///  SETx2DE
                SETx2DE: u1,
                ///  RSTx2DE
                RSTx2DE: u1,
                ///  RSTDE
                RSTDE: u1,
                ///  DLYPRTDE
                DLYPRTDE: u1,
                padding: u1,
            }),
            ///  Timerx Counter Register
            CNTAR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Counter value
                CNTx: u16,
                padding: u16,
            }),
            ///  Timerx Period Register
            PERAR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Period value
                PERx: u16,
                padding: u16,
            }),
            ///  Timerx Repetition Register
            REPAR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Repetition counter value
                REPx: u8,
                padding: u24,
            }),
            ///  Timerx Compare 1 Register
            CMP1AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 1 Compound Register
            CMP1CAR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                ///  Timerx Repetition value (aliased from HRTIM_REPx register)
                REPx: u8,
                padding: u8,
            }),
            ///  Timerx Compare 2 Register
            CMP2AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 2 value
                CMP2x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 3 Register
            CMP3AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 3 value
                CMP3x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 4 Register
            CMP4AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 4 value
                CMP4x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 1 Register
            CPT1AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 1 value
                CPT1x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 2 Register
            CPT2AR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 2 value
                CPT2x: u16,
                padding: u16,
            }),
            ///  Timerx Deadtime Register
            DTAR: mmio.Mmio(packed struct(u32) {
                ///  Deadtime Rising value
                DTRx: u9,
                ///  Sign Deadtime Rising value
                SDTRx: u1,
                ///  Deadtime Prescaler
                DTPRSC: u3,
                reserved14: u1,
                ///  Deadtime Rising Sign Lock
                DTRSLKx: u1,
                ///  Deadtime Rising Lock
                DTRLKx: u1,
                ///  Deadtime Falling value
                DTFx: u9,
                ///  Sign Deadtime Falling value
                SDTFx: u1,
                reserved30: u4,
                ///  Deadtime Falling Sign Lock
                DTFSLKx: u1,
                ///  Deadtime Falling Lock
                DTFLKx: u1,
            }),
            ///  Timerx Output1 Set Register
            SETA1R: mmio.Mmio(packed struct(u32) {
                ///  Software Set trigger
                SST: u1,
                ///  Timer A resynchronizaton
                RESYNC: u1,
                ///  Timer A Period
                PER: u1,
                ///  Timer A compare 1
                CMP1: u1,
                ///  Timer A compare 2
                CMP2: u1,
                ///  Timer A compare 3
                CMP3: u1,
                ///  Timer A compare 4
                CMP4: u1,
                ///  Master Period
                MSTPER: u1,
                ///  Master Compare 1
                MSTCMP1: u1,
                ///  Master Compare 2
                MSTCMP2: u1,
                ///  Master Compare 3
                MSTCMP3: u1,
                ///  Master Compare 4
                MSTCMP4: u1,
                ///  Timer Event 1
                TIMEVNT1: u1,
                ///  Timer Event 2
                TIMEVNT2: u1,
                ///  Timer Event 3
                TIMEVNT3: u1,
                ///  Timer Event 4
                TIMEVNT4: u1,
                ///  Timer Event 5
                TIMEVNT5: u1,
                ///  Timer Event 6
                TIMEVNT6: u1,
                ///  Timer Event 7
                TIMEVNT7: u1,
                ///  Timer Event 8
                TIMEVNT8: u1,
                ///  Timer Event 9
                TIMEVNT9: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Registers update (transfer preload to active)
                UPDATE: u1,
            }),
            ///  Timerx Output1 Reset Register
            RSTA1R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Set Register
            SETA2R: mmio.Mmio(packed struct(u32) {
                ///  SST
                SST: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Reset Register
            RSTA2R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx External Event Filtering Register 1
            EEFAR1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 latch
                EE1LTCH: u1,
                ///  External Event 1 filter
                EE1FLTR: u4,
                reserved6: u1,
                ///  External Event 2 latch
                EE2LTCH: u1,
                ///  External Event 2 filter
                EE2FLTR: u4,
                reserved12: u1,
                ///  External Event 3 latch
                EE3LTCH: u1,
                ///  External Event 3 filter
                EE3FLTR: u4,
                reserved18: u1,
                ///  External Event 4 latch
                EE4LTCH: u1,
                ///  External Event 4 filter
                EE4FLTR: u4,
                reserved24: u1,
                ///  External Event 5 latch
                EE5LTCH: u1,
                ///  External Event 5 filter
                EE5FLTR: u4,
                padding: u3,
            }),
            ///  Timerx External Event Filtering Register 2
            EEFAR2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 latch
                EE6LTCH: u1,
                ///  External Event 6 filter
                EE6FLTR: u4,
                reserved6: u1,
                ///  External Event 7 latch
                EE7LTCH: u1,
                ///  External Event 7 filter
                EE7FLTR: u4,
                reserved12: u1,
                ///  External Event 8 latch
                EE8LTCH: u1,
                ///  External Event 8 filter
                EE8FLTR: u4,
                reserved18: u1,
                ///  External Event 9 latch
                EE9LTCH: u1,
                ///  External Event 9 filter
                EE9FLTR: u4,
                reserved24: u1,
                ///  External Event 10 latch
                EE10LTCH: u1,
                ///  External Event 10 filter
                EE10FLTR: u4,
                padding: u3,
            }),
            ///  TimerA Reset Register
            RSTAR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Timer A Update reset
                UPDT: u1,
                ///  Timer A compare 2 reset
                CMP2: u1,
                ///  Timer A compare 4 reset
                CMP4: u1,
                ///  Master timer Period
                MSTPER: u1,
                ///  Master compare 1
                MSTCMP1: u1,
                ///  Master compare 2
                MSTCMP2: u1,
                ///  Master compare 3
                MSTCMP3: u1,
                ///  Master compare 4
                MSTCMP4: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Timer B Compare 1
                TIMBCMP1: u1,
                ///  Timer B Compare 2
                TIMBCMP2: u1,
                ///  Timer B Compare 4
                TIMBCMP4: u1,
                ///  Timer C Compare 1
                TIMCCMP1: u1,
                ///  Timer C Compare 2
                TIMCCMP2: u1,
                ///  Timer C Compare 4
                TIMCCMP4: u1,
                ///  Timer D Compare 1
                TIMDCMP1: u1,
                ///  Timer D Compare 2
                TIMDCMP2: u1,
                ///  Timer D Compare 4
                TIMDCMP4: u1,
                ///  Timer E Compare 1
                TIMECMP1: u1,
                ///  Timer E Compare 2
                TIMECMP2: u1,
                ///  Timer E Compare 4
                TIMECMP4: u1,
                padding: u1,
            }),
            ///  Timerx Chopper Register
            CHPAR: mmio.Mmio(packed struct(u32) {
                ///  Timerx carrier frequency value
                CHPFRQ: u4,
                ///  Timerx chopper duty cycle value
                CHPDTY: u3,
                ///  STRTPW
                STRTPW: u4,
                padding: u21,
            }),
            ///  Timerx Capture 2 Control Register
            CPT1ACR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                reserved16: u4,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  CPT2xCR
            CPT2ACR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                reserved16: u4,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  Timerx Output Register
            OUTAR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Output 1 polarity
                POL1: u1,
                ///  Output 1 Idle mode
                IDLEM1: u1,
                ///  Output 1 Idle State
                IDLES1: u1,
                ///  Output 1 Fault state
                FAULT1: u2,
                ///  Output 1 Chopper enable
                CHP1: u1,
                ///  Output 1 Deadtime upon burst mode Idle entry
                DIDL1: u1,
                ///  Deadtime enable
                DTEN: u1,
                ///  Delayed Protection Enable
                DLYPRTEN: u1,
                ///  Delayed Protection
                DLYPRT: u3,
                reserved17: u4,
                ///  Output 2 polarity
                POL2: u1,
                ///  Output 2 Idle mode
                IDLEM2: u1,
                ///  Output 2 Idle State
                IDLES2: u1,
                ///  Output 2 Fault state
                FAULT2: u2,
                ///  Output 2 Chopper enable
                CHP2: u1,
                ///  Output 2 Deadtime upon burst mode Idle entry
                DIDL2: u1,
                padding: u8,
            }),
            ///  Timerx Fault Register
            FLTAR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 enable
                FLT1EN: u1,
                ///  Fault 2 enable
                FLT2EN: u1,
                ///  Fault 3 enable
                FLT3EN: u1,
                ///  Fault 4 enable
                FLT4EN: u1,
                ///  Fault 5 enable
                FLT5EN: u1,
                reserved31: u26,
                ///  Fault sources Lock
                FLTLCK: u1,
            }),
        };

        ///  General purpose timers
        pub const TIM2 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                ///  Direction
                DIR: u1,
                ///  Center-aligned mode selection
                CMS: u2,
                ///  Auto-reload preload enable
                ARPE: u1,
                ///  Clock division
                CKD: u2,
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Capture/compare DMA selection
                CCDS: u1,
                ///  Master mode selection
                MMS: u3,
                ///  TI1 selection
                TI1S: u1,
                padding: u24,
            }),
            ///  slave mode control register
            SMCR: mmio.Mmio(packed struct(u32) {
                ///  Slave mode selection
                SMS: u3,
                reserved4: u1,
                ///  Trigger selection
                TS: u3,
                ///  Master/Slave mode
                MSM: u1,
                ///  External trigger filter
                ETF: u4,
                ///  External trigger prescaler
                ETPS: u2,
                ///  External clock enable
                ECE: u1,
                ///  External trigger polarity
                ETP: u1,
                ///  Slave mode selection - bit 3
                SMS_3: u1,
                reserved20: u3,
                ///  Trigger selection
                TS_4_3: u2,
                padding: u10,
            }),
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                ///  Capture/Compare 1 interrupt enable
                CC1IE: u1,
                ///  Capture/Compare 2 interrupt enable
                CC2IE: u1,
                ///  Capture/Compare 3 interrupt enable
                CC3IE: u1,
                ///  Capture/Compare 4 interrupt enable
                CC4IE: u1,
                reserved6: u1,
                ///  Trigger interrupt enable
                TIE: u1,
                reserved8: u1,
                ///  Update DMA request enable
                UDE: u1,
                ///  Capture/Compare 1 DMA request enable
                CC1DE: u1,
                ///  Capture/Compare 2 DMA request enable
                CC2DE: u1,
                ///  Capture/Compare 3 DMA request enable
                CC3DE: u1,
                ///  Capture/Compare 4 DMA request enable
                CC4DE: u1,
                reserved14: u1,
                ///  Trigger DMA request enable
                TDE: u1,
                padding: u17,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                ///  Capture/compare 1 interrupt flag
                CC1IF: u1,
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                ///  Capture/Compare 3 interrupt flag
                CC3IF: u1,
                ///  Capture/Compare 4 interrupt flag
                CC4IF: u1,
                reserved6: u1,
                ///  Trigger interrupt flag
                TIF: u1,
                reserved9: u2,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: u1,
                ///  Capture/compare 2 overcapture flag
                CC2OF: u1,
                ///  Capture/Compare 3 overcapture flag
                CC3OF: u1,
                ///  Capture/Compare 4 overcapture flag
                CC4OF: u1,
                padding: u19,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                ///  Capture/compare 2 generation
                CC2G: u1,
                ///  Capture/compare 3 generation
                CC3G: u1,
                ///  Capture/compare 4 generation
                CC4G: u1,
                reserved6: u1,
                ///  Trigger generation
                TG: u1,
                padding: u25,
            }),
            ///  capture/compare mode register 1 (output mode)
            CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  OC1FE
                OC1FE: u1,
                ///  OC1PE
                OC1PE: u1,
                ///  OC1M
                OC1M: u3,
                ///  OC1CE
                OC1CE: u1,
                ///  CC2S
                CC2S: u2,
                ///  OC2FE
                OC2FE: u1,
                ///  OC2PE
                OC2PE: u1,
                ///  OC2M
                OC2M: u3,
                ///  OC2CE
                OC2CE: u1,
                ///  Output Compare 1 mode - bit 3
                OC1M_3: u1,
                reserved24: u7,
                ///  Output Compare 2 mode - bit 3
                OC2M_3: u1,
                padding: u7,
            }),
            ///  capture/compare mode register 2 (output mode)
            CCMR2_Output: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  OC3FE
                OC3FE: u1,
                ///  OC3PE
                OC3PE: u1,
                ///  OC3M
                OC3M: u3,
                ///  OC3CE
                OC3CE: u1,
                ///  CC4S
                CC4S: u2,
                ///  OC4FE
                OC4FE: u1,
                ///  OC4PE
                OC4PE: u1,
                ///  OC4M
                OC4M: u3,
                ///  O24CE
                O24CE: u1,
                ///  Output Compare 1 mode - bit 3
                OC3M_3: u1,
                reserved24: u7,
                ///  Output Compare 2 mode - bit 3
                OC4M_3: u1,
                padding: u7,
            }),
            ///  capture/compare enable register
            CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable
                CC1E: u1,
                ///  Capture/Compare 1 output Polarity
                CC1P: u1,
                reserved3: u1,
                ///  Capture/Compare 1 output Polarity
                CC1NP: u1,
                ///  Capture/Compare 2 output enable
                CC2E: u1,
                ///  Capture/Compare 2 output Polarity
                CC2P: u1,
                reserved7: u1,
                ///  Capture/Compare 2 output Polarity
                CC2NP: u1,
                ///  Capture/Compare 3 output enable
                CC3E: u1,
                ///  Capture/Compare 3 output Polarity
                CC3P: u1,
                reserved11: u1,
                ///  Capture/Compare 3 output Polarity
                CC3NP: u1,
                ///  Capture/Compare 4 output enable
                CC4E: u1,
                ///  Capture/Compare 3 output Polarity
                CC4P: u1,
                reserved15: u1,
                ///  Capture/Compare 4 output Polarity
                CC4NP: u1,
                padding: u16,
            }),
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  low counter value
                CNT_L: u16,
                ///  High counter value
                CNT_H: u16,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Low Auto-reload value
                ARR_L: u16,
                ///  High Auto-reload value
                ARR_H: u16,
            }),
            reserved52: [4]u8,
            ///  capture/compare register 1
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 1 value
                CCR1_L: u16,
                ///  High Capture/Compare 1 value
                CCR1_H: u16,
            }),
            ///  capture/compare register 2
            CCR2: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 2 value
                CCR2_L: u16,
                ///  High Capture/Compare 2 value
                CCR2_H: u16,
            }),
            ///  capture/compare register 3
            CCR3: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR3_L: u16,
                ///  High Capture/Compare value
                CCR3_H: u16,
            }),
            ///  capture/compare register 4
            CCR4: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR4_L: u16,
                ///  High Capture/Compare value
                CCR4_H: u16,
            }),
            reserved72: [4]u8,
            ///  DMA control register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  DMA base address
                DBA: u5,
                reserved8: u3,
                ///  DMA burst length
                DBL: u5,
                padding: u19,
            }),
            ///  DMA address for full transfer
            DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses
                DMAB: u16,
                padding: u16,
            }),
            reserved96: [16]u8,
            ///  TIM alternate function option register 1
            AF1: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  ETR source selection
                ETRSEL: u4,
                padding: u14,
            }),
            reserved104: [4]u8,
            ///  TIM timer input selection register
            TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1[0] to TI1[15] input selection
                TI1SEL: u4,
                reserved8: u4,
                ///  TI2[0] to TI2[15] input selection
                TI2SEL: u4,
                reserved16: u4,
                ///  TI3[0] to TI3[15] input selection
                TI3SEL: u4,
                reserved24: u4,
                ///  TI4[0] to TI4[15] input selection
                TI4SEL: u4,
                padding: u4,
            }),
        };

        ///  Single Wire Protocol Master Interface
        pub const SWPMI = extern struct {
            ///  SWPMI Configuration/Control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Reception DMA enable
                RXDMA: u1,
                ///  Transmission DMA enable
                TXDMA: u1,
                ///  Reception buffering mode
                RXMODE: u1,
                ///  Transmission buffering mode
                TXMODE: u1,
                ///  Loopback mode enable
                LPBK: u1,
                ///  Single wire protocol master interface activate
                SWPACT: u1,
                reserved10: u4,
                ///  Single wire protocol master interface deactivate
                DEACT: u1,
                ///  Single wire protocol master transceiver enable
                SWPTEN: u1,
                padding: u20,
            }),
            ///  SWPMI Bitrate register
            BRR: mmio.Mmio(packed struct(u32) {
                ///  Bitrate prescaler
                BR: u8,
                padding: u24,
            }),
            reserved12: [4]u8,
            ///  SWPMI Interrupt and Status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Receive buffer full flag
                RXBFF: u1,
                ///  Transmit buffer empty flag
                TXBEF: u1,
                ///  Receive CRC error flag
                RXBERF: u1,
                ///  Receive overrun error flag
                RXOVRF: u1,
                ///  Transmit underrun error flag
                TXUNRF: u1,
                ///  Receive data register not empty
                RXNE: u1,
                ///  Transmit data register empty
                TXE: u1,
                ///  Transfer complete flag
                TCF: u1,
                ///  Slave resume flag
                SRF: u1,
                ///  SUSPEND flag
                SUSP: u1,
                ///  DEACTIVATED flag
                DEACTF: u1,
                ///  transceiver ready flag
                RDYF: u1,
                padding: u20,
            }),
            ///  SWPMI Interrupt Flag Clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Clear receive buffer full flag
                CRXBFF: u1,
                ///  Clear transmit buffer empty flag
                CTXBEF: u1,
                ///  Clear receive CRC error flag
                CRXBERF: u1,
                ///  Clear receive overrun error flag
                CRXOVRF: u1,
                ///  Clear transmit underrun error flag
                CTXUNRF: u1,
                reserved7: u2,
                ///  Clear transfer complete flag
                CTCF: u1,
                ///  Clear slave resume flag
                CSRF: u1,
                reserved11: u2,
                ///  Clear transceiver ready flag
                CRDYF: u1,
                padding: u20,
            }),
            ///  SWPMI Interrupt Enable register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Receive buffer full interrupt enable
                RXBFIE: u1,
                ///  Transmit buffer empty interrupt enable
                TXBEIE: u1,
                ///  Receive CRC error interrupt enable
                RXBERIE: u1,
                ///  Receive overrun error interrupt enable
                RXOVRIE: u1,
                ///  Transmit underrun error interrupt enable
                TXUNRIE: u1,
                ///  Receive interrupt enable
                RIE: u1,
                ///  Transmit interrupt enable
                TIE: u1,
                ///  Transmit complete interrupt enable
                TCIE: u1,
                ///  Slave resume interrupt enable
                SRIE: u1,
                reserved11: u2,
                ///  Transceiver ready interrupt enable
                RDYIE: u1,
                padding: u20,
            }),
            ///  SWPMI Receive Frame Length register
            RFL: mmio.Mmio(packed struct(u32) {
                ///  Receive frame length
                RFL: u5,
                padding: u27,
            }),
            ///  SWPMI Transmit data register
            TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data
                TD: u32,
            }),
            ///  SWPMI Receive data register
            RDR: mmio.Mmio(packed struct(u32) {
                ///  received data
                RD: u32,
            }),
            ///  SWPMI Option register
            OR: mmio.Mmio(packed struct(u32) {
                ///  SWP transceiver bypass
                SWP_TBYP: u1,
                ///  SWP class selection
                SWP_CLASS: u1,
                padding: u30,
            }),
        };

        ///  Operational amplifiers
        pub const OPAMP = extern struct {
            ///  OPAMP1 control/status register
            OPAMP1_CSR: mmio.Mmio(packed struct(u32) {
                ///  Operational amplifier Enable
                OPAEN: u1,
                ///  Force internal reference on VP (reserved for test
                FORCE_VP: u1,
                ///  Operational amplifier PGA mode
                VP_SEL: u2,
                reserved5: u1,
                ///  Inverting input selection
                VM_SEL: u2,
                reserved8: u1,
                ///  Operational amplifier high-speed mode
                OPAHSM: u1,
                reserved11: u2,
                ///  Calibration mode enabled
                CALON: u1,
                ///  Calibration selection
                CALSEL: u2,
                ///  allows to switch from AOP offset trimmed values to AOP offset
                PGA_GAIN: u4,
                ///  User trimming enable
                USERTRIM: u1,
                reserved29: u10,
                ///  OPAMP calibration reference voltage output control (reserved for test)
                TSTREF: u1,
                ///  Operational amplifier calibration output
                CALOUT: u1,
                padding: u1,
            }),
            ///  OPAMP1 offset trimming register in normal mode
            OPAMP1_OTR: mmio.Mmio(packed struct(u32) {
                ///  Trim for NMOS differential pairs
                TRIMOFFSETN: u5,
                reserved8: u3,
                ///  Trim for PMOS differential pairs
                TRIMOFFSETP: u5,
                padding: u19,
            }),
            ///  OPAMP1 offset trimming register in low-power mode
            OPAMP1_HSOTR: mmio.Mmio(packed struct(u32) {
                ///  Trim for NMOS differential pairs
                TRIMLPOFFSETN: u5,
                reserved8: u3,
                ///  Trim for PMOS differential pairs
                TRIMLPOFFSETP: u5,
                padding: u19,
            }),
            reserved16: [4]u8,
            ///  OPAMP2 control/status register
            OPAMP2_CSR: mmio.Mmio(packed struct(u32) {
                ///  Operational amplifier Enable
                OPAEN: u1,
                ///  Force internal reference on VP (reserved for test)
                FORCE_VP: u1,
                reserved5: u3,
                ///  Inverting input selection
                VM_SEL: u2,
                reserved8: u1,
                ///  Operational amplifier high-speed mode
                OPAHSM: u1,
                reserved11: u2,
                ///  Calibration mode enabled
                CALON: u1,
                ///  Calibration selection
                CALSEL: u2,
                ///  Operational amplifier Programmable amplifier gain value
                PGA_GAIN: u4,
                ///  User trimming enable
                USERTRIM: u1,
                reserved29: u10,
                ///  OPAMP calibration reference voltage output control (reserved for test)
                TSTREF: u1,
                ///  Operational amplifier calibration output
                CALOUT: u1,
                padding: u1,
            }),
            ///  OPAMP2 offset trimming register in normal mode
            OPAMP2_OTR: mmio.Mmio(packed struct(u32) {
                ///  Trim for NMOS differential pairs
                TRIMOFFSETN: u5,
                reserved8: u3,
                ///  Trim for PMOS differential pairs
                TRIMOFFSETP: u5,
                padding: u19,
            }),
            ///  OPAMP2 offset trimming register in low-power mode
            OPAMP2_HSOTR: mmio.Mmio(packed struct(u32) {
                ///  Trim for NMOS differential pairs
                TRIMLPOFFSETN: u5,
                reserved8: u3,
                ///  Trim for PMOS differential pairs
                TRIMLPOFFSETP: u5,
                padding: u19,
            }),
        };

        ///  Management data input/output slave
        pub const MDIOS = extern struct {
            ///  MDIOS configuration register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral enable
                EN: u1,
                ///  Register write interrupt enable
                WRIE: u1,
                ///  Register Read Interrupt Enable
                RDIE: u1,
                ///  Error interrupt enable
                EIE: u1,
                reserved7: u3,
                ///  Disable Preamble Check
                DPC: u1,
                ///  Slaves's address
                PORT_ADDRESS: u5,
                padding: u19,
            }),
            ///  MDIOS write flag register
            WRFR: mmio.Mmio(packed struct(u32) {
                ///  Write flags for MDIO registers 0 to 31
                WRF: u32,
            }),
            ///  MDIOS clear write flag register
            CWRFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the write flag
                CWRF: u32,
            }),
            ///  MDIOS read flag register
            RDFR: mmio.Mmio(packed struct(u32) {
                ///  Read flags for MDIO registers 0 to 31
                RDF: u32,
            }),
            ///  MDIOS clear read flag register
            CRDFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the read flag
                CRDF: u32,
            }),
            ///  MDIOS status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Preamble error flag
                PERF: u1,
                ///  Start error flag
                SERF: u1,
                ///  Turnaround error flag
                TERF: u1,
                padding: u29,
            }),
            ///  MDIOS clear flag register
            CLRFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the preamble error flag
                CPERF: u1,
                ///  Clear the start error flag
                CSERF: u1,
                ///  Clear the turnaround error flag
                CTERF: u1,
                padding: u29,
            }),
            ///  MDIOS input data register 0
            DINR0: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN0: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 1
            DINR1: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN1: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 2
            DINR2: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN2: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 3
            DINR3: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN3: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 4
            DINR4: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN4: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 5
            DINR5: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN5: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 6
            DINR6: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN6: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 7
            DINR7: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN7: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 8
            DINR8: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN8: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 9
            DINR9: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN9: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 10
            DINR10: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN10: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 11
            DINR11: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN11: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 12
            DINR12: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN12: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 13
            DINR13: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN13: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 14
            DINR14: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN14: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 15
            DINR15: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN15: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 16
            DINR16: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN16: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 17
            DINR17: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN17: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 18
            DINR18: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN18: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 19
            DINR19: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN19: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 20
            DINR20: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN20: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 21
            DINR21: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN21: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 22
            DINR22: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN22: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 23
            DINR23: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN23: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 24
            DINR24: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN24: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 25
            DINR25: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN25: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 26
            DINR26: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN26: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 27
            DINR27: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN27: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 28
            DINR28: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN28: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 29
            DINR29: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN29: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 30
            DINR30: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN30: u16,
                padding: u16,
            }),
            ///  MDIOS input data register 31
            DINR31: mmio.Mmio(packed struct(u32) {
                ///  Input data received from MDIO Master during write frames
                DIN31: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 0
            DOUTR0: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT0: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 1
            DOUTR1: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT1: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 2
            DOUTR2: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT2: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 3
            DOUTR3: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT3: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 4
            DOUTR4: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT4: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 5
            DOUTR5: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT5: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 6
            DOUTR6: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT6: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 7
            DOUTR7: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT7: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 8
            DOUTR8: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT8: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 9
            DOUTR9: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT9: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 10
            DOUTR10: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT10: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 11
            DOUTR11: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT11: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 12
            DOUTR12: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT12: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 13
            DOUTR13: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT13: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 14
            DOUTR14: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT14: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 15
            DOUTR15: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT15: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 16
            DOUTR16: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT16: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 17
            DOUTR17: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT17: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 18
            DOUTR18: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT18: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 19
            DOUTR19: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT19: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 20
            DOUTR20: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT20: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 21
            DOUTR21: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT21: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 22
            DOUTR22: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT22: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 23
            DOUTR23: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT23: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 24
            DOUTR24: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT24: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 25
            DOUTR25: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT25: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 26
            DOUTR26: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT26: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 27
            DOUTR27: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT27: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 28
            DOUTR28: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT28: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 29
            DOUTR29: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT29: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 30
            DOUTR30: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT30: u16,
                padding: u16,
            }),
            ///  MDIOS output data register 31
            DOUTR31: mmio.Mmio(packed struct(u32) {
                ///  Output data sent to MDIO Master during read frames
                DOUT31: u16,
                padding: u16,
            }),
        };

        ///  LCD-TFT Controller
        pub const LTDC = extern struct {
            reserved8: [8]u8,
            ///  Synchronization Size Configuration Register
            SSCR: mmio.Mmio(packed struct(u32) {
                ///  Vertical Synchronization Height (in units of horizontal scan line)
                VSH: u11,
                reserved16: u5,
                ///  Horizontal Synchronization Width (in units of pixel clock period)
                HSW: u10,
                padding: u6,
            }),
            ///  Back Porch Configuration Register
            BPCR: mmio.Mmio(packed struct(u32) {
                ///  Accumulated Vertical back porch (in units of horizontal scan line)
                AVBP: u11,
                reserved16: u5,
                ///  Accumulated Horizontal back porch (in units of pixel clock period)
                AHBP: u12,
                padding: u4,
            }),
            ///  Active Width Configuration Register
            AWCR: mmio.Mmio(packed struct(u32) {
                ///  Accumulated Active Height (in units of horizontal scan line)
                AAH: u11,
                reserved16: u5,
                ///  AAV
                AAV: u12,
                padding: u4,
            }),
            ///  Total Width Configuration Register
            TWCR: mmio.Mmio(packed struct(u32) {
                ///  Total Height (in units of horizontal scan line)
                TOTALH: u11,
                reserved16: u5,
                ///  Total Width (in units of pixel clock period)
                TOTALW: u12,
                padding: u4,
            }),
            ///  Global Control Register
            GCR: mmio.Mmio(packed struct(u32) {
                ///  LCD-TFT controller enable bit
                LTDCEN: u1,
                reserved4: u3,
                ///  Dither Blue Width
                DBW: u3,
                reserved8: u1,
                ///  Dither Green Width
                DGW: u3,
                reserved12: u1,
                ///  Dither Red Width
                DRW: u3,
                reserved16: u1,
                ///  Dither Enable
                DEN: u1,
                reserved28: u11,
                ///  Pixel Clock Polarity
                PCPOL: u1,
                ///  Data Enable Polarity
                DEPOL: u1,
                ///  Vertical Synchronization Polarity
                VSPOL: u1,
                ///  Horizontal Synchronization Polarity
                HSPOL: u1,
            }),
            reserved36: [8]u8,
            ///  Shadow Reload Configuration Register
            SRCR: mmio.Mmio(packed struct(u32) {
                ///  Immediate Reload
                IMR: u1,
                ///  Vertical Blanking Reload
                VBR: u1,
                padding: u30,
            }),
            reserved44: [4]u8,
            ///  Background Color Configuration Register
            BCCR: mmio.Mmio(packed struct(u32) {
                ///  Background Color Blue value
                BCBLUE: u8,
                ///  Background Color Green value
                BCGREEN: u8,
                ///  Background Color Red value
                BCRED: u8,
                padding: u8,
            }),
            reserved52: [4]u8,
            ///  Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Line Interrupt Enable
                LIE: u1,
                ///  FIFO Underrun Interrupt Enable
                FUIE: u1,
                ///  Transfer Error Interrupt Enable
                TERRIE: u1,
                ///  Register Reload interrupt enable
                RRIE: u1,
                padding: u28,
            }),
            ///  Interrupt Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Line Interrupt flag
                LIF: u1,
                ///  FIFO Underrun Interrupt flag
                FUIF: u1,
                ///  Transfer Error interrupt flag
                TERRIF: u1,
                ///  Register Reload Interrupt Flag
                RRIF: u1,
                padding: u28,
            }),
            ///  Interrupt Clear Register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Clears the Line Interrupt Flag
                CLIF: u1,
                ///  Clears the FIFO Underrun Interrupt flag
                CFUIF: u1,
                ///  Clears the Transfer Error Interrupt Flag
                CTERRIF: u1,
                ///  Clears Register Reload Interrupt Flag
                CRRIF: u1,
                padding: u28,
            }),
            ///  Line Interrupt Position Configuration Register
            LIPCR: mmio.Mmio(packed struct(u32) {
                ///  Line Interrupt Position
                LIPOS: u11,
                padding: u21,
            }),
            ///  Current Position Status Register
            CPSR: mmio.Mmio(packed struct(u32) {
                ///  Current Y Position
                CYPOS: u16,
                ///  Current X Position
                CXPOS: u16,
            }),
            ///  Current Display Status Register
            CDSR: mmio.Mmio(packed struct(u32) {
                ///  Vertical Data Enable display Status
                VDES: u1,
                ///  Horizontal Data Enable display Status
                HDES: u1,
                ///  Vertical Synchronization display Status
                VSYNCS: u1,
                ///  Horizontal Synchronization display Status
                HSYNCS: u1,
                padding: u28,
            }),
            reserved132: [56]u8,
            ///  Layerx Control Register
            L1CR: mmio.Mmio(packed struct(u32) {
                ///  Layer Enable
                LEN: u1,
                ///  Color Keying Enable
                COLKEN: u1,
                reserved4: u2,
                ///  Color Look-Up Table Enable
                CLUTEN: u1,
                padding: u27,
            }),
            ///  Layerx Window Horizontal Position Configuration Register
            L1WHPCR: mmio.Mmio(packed struct(u32) {
                ///  Window Horizontal Start Position
                WHSTPOS: u12,
                reserved16: u4,
                ///  Window Horizontal Stop Position
                WHSPPOS: u12,
                padding: u4,
            }),
            ///  Layerx Window Vertical Position Configuration Register
            L1WVPCR: mmio.Mmio(packed struct(u32) {
                ///  Window Vertical Start Position
                WVSTPOS: u11,
                reserved16: u5,
                ///  Window Vertical Stop Position
                WVSPPOS: u11,
                padding: u5,
            }),
            ///  Layerx Color Keying Configuration Register
            L1CKCR: mmio.Mmio(packed struct(u32) {
                ///  Color Key Blue value
                CKBLUE: u8,
                ///  Color Key Green value
                CKGREEN: u8,
                ///  Color Key Red value
                CKRED: u8,
                padding: u8,
            }),
            ///  Layerx Pixel Format Configuration Register
            L1PFCR: mmio.Mmio(packed struct(u32) {
                ///  Pixel Format
                PF: u3,
                padding: u29,
            }),
            ///  Layerx Constant Alpha Configuration Register
            L1CACR: mmio.Mmio(packed struct(u32) {
                ///  Constant Alpha
                CONSTA: u8,
                padding: u24,
            }),
            ///  Layerx Default Color Configuration Register
            L1DCCR: mmio.Mmio(packed struct(u32) {
                ///  Default Color Blue
                DCBLUE: u8,
                ///  Default Color Green
                DCGREEN: u8,
                ///  Default Color Red
                DCRED: u8,
                ///  Default Color Alpha
                DCALPHA: u8,
            }),
            ///  Layerx Blending Factors Configuration Register
            L1BFCR: mmio.Mmio(packed struct(u32) {
                ///  Blending Factor 2
                BF2: u3,
                reserved8: u5,
                ///  Blending Factor 1
                BF1: u3,
                padding: u21,
            }),
            reserved172: [8]u8,
            ///  Layerx Color Frame Buffer Address Register
            L1CFBAR: mmio.Mmio(packed struct(u32) {
                ///  Color Frame Buffer Start Address
                CFBADD: u32,
            }),
            ///  Layerx Color Frame Buffer Length Register
            L1CFBLR: mmio.Mmio(packed struct(u32) {
                ///  Color Frame Buffer Line Length
                CFBLL: u13,
                reserved16: u3,
                ///  Color Frame Buffer Pitch in bytes
                CFBP: u13,
                padding: u3,
            }),
            ///  Layerx ColorFrame Buffer Line Number Register
            L1CFBLNR: mmio.Mmio(packed struct(u32) {
                ///  Frame Buffer Line Number
                CFBLNBR: u11,
                padding: u21,
            }),
            reserved196: [12]u8,
            ///  Layerx CLUT Write Register
            L1CLUTWR: mmio.Mmio(packed struct(u32) {
                ///  Blue value
                BLUE: u8,
                ///  Green value
                GREEN: u8,
                ///  Red value
                RED: u8,
                ///  CLUT Address
                CLUTADD: u8,
            }),
            reserved260: [60]u8,
            ///  Layerx Control Register
            L2CR: mmio.Mmio(packed struct(u32) {
                ///  Layer Enable
                LEN: u1,
                ///  Color Keying Enable
                COLKEN: u1,
                reserved4: u2,
                ///  Color Look-Up Table Enable
                CLUTEN: u1,
                padding: u27,
            }),
            ///  Layerx Window Horizontal Position Configuration Register
            L2WHPCR: mmio.Mmio(packed struct(u32) {
                ///  Window Horizontal Start Position
                WHSTPOS: u12,
                reserved16: u4,
                ///  Window Horizontal Stop Position
                WHSPPOS: u12,
                padding: u4,
            }),
            ///  Layerx Window Vertical Position Configuration Register
            L2WVPCR: mmio.Mmio(packed struct(u32) {
                ///  Window Vertical Start Position
                WVSTPOS: u11,
                reserved16: u5,
                ///  Window Vertical Stop Position
                WVSPPOS: u11,
                padding: u5,
            }),
            ///  Layerx Color Keying Configuration Register
            L2CKCR: mmio.Mmio(packed struct(u32) {
                ///  Color Key Blue value
                CKBLUE: u8,
                ///  Color Key Green value
                CKGREEN: u8,
                ///  Color Key Red value
                CKRED: u8,
                padding: u8,
            }),
            ///  Layerx Pixel Format Configuration Register
            L2PFCR: mmio.Mmio(packed struct(u32) {
                ///  Pixel Format
                PF: u3,
                padding: u29,
            }),
            ///  Layerx Constant Alpha Configuration Register
            L2CACR: mmio.Mmio(packed struct(u32) {
                ///  Constant Alpha
                CONSTA: u8,
                padding: u24,
            }),
            ///  Layerx Default Color Configuration Register
            L2DCCR: mmio.Mmio(packed struct(u32) {
                ///  Default Color Blue
                DCBLUE: u8,
                ///  Default Color Green
                DCGREEN: u8,
                ///  Default Color Red
                DCRED: u8,
                ///  Default Color Alpha
                DCALPHA: u8,
            }),
            ///  Layerx Blending Factors Configuration Register
            L2BFCR: mmio.Mmio(packed struct(u32) {
                ///  Blending Factor 2
                BF2: u3,
                reserved8: u5,
                ///  Blending Factor 1
                BF1: u3,
                padding: u21,
            }),
            reserved300: [8]u8,
            ///  Layerx Color Frame Buffer Address Register
            L2CFBAR: mmio.Mmio(packed struct(u32) {
                ///  Color Frame Buffer Start Address
                CFBADD: u32,
            }),
            ///  Layerx Color Frame Buffer Length Register
            L2CFBLR: mmio.Mmio(packed struct(u32) {
                ///  Color Frame Buffer Line Length
                CFBLL: u13,
                reserved16: u3,
                ///  Color Frame Buffer Pitch in bytes
                CFBP: u13,
                padding: u3,
            }),
            ///  Layerx ColorFrame Buffer Line Number Register
            L2CFBLNR: mmio.Mmio(packed struct(u32) {
                ///  Frame Buffer Line Number
                CFBLNBR: u11,
                padding: u21,
            }),
            reserved324: [12]u8,
            ///  Layerx CLUT Write Register
            L2CLUTWR: mmio.Mmio(packed struct(u32) {
                ///  Blue value
                BLUE: u8,
                ///  Green value
                GREEN: u8,
                ///  Red value
                RED: u8,
                ///  CLUT Address
                CLUTADD: u8,
            }),
        };

        ///  Receiver Interface
        pub const SPDIFRX = extern struct {
            ///  Control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Peripheral Block Enable
                SPDIFRXEN: u2,
                ///  Receiver DMA ENable for data flow
                RXDMAEN: u1,
                ///  STerEO Mode
                RXSTEO: u1,
                ///  RX Data format
                DRFMT: u2,
                ///  Mask Parity error bit
                PMSK: u1,
                ///  Mask of Validity bit
                VMSK: u1,
                ///  Mask of channel status and user bits
                CUMSK: u1,
                ///  Mask of Preamble Type bits
                PTMSK: u1,
                ///  Control Buffer DMA ENable for control flow
                CBDMAEN: u1,
                ///  Channel Selection
                CHSEL: u1,
                ///  Maximum allowed re-tries during synchronization phase
                NBTR: u2,
                ///  Wait For Activity
                WFA: u1,
                reserved16: u1,
                ///  input selection
                INSEL: u3,
                reserved20: u1,
                ///  Symbol Clock Enable
                CKSEN: u1,
                ///  Backup Symbol Clock Enable
                CKSBKPEN: u1,
                padding: u10,
            }),
            ///  Interrupt mask register
            IMR: mmio.Mmio(packed struct(u32) {
                ///  RXNE interrupt enable
                RXNEIE: u1,
                ///  Control Buffer Ready Interrupt Enable
                CSRNEIE: u1,
                ///  Parity error interrupt enable
                PERRIE: u1,
                ///  Overrun error Interrupt Enable
                OVRIE: u1,
                ///  Synchronization Block Detected Interrupt Enable
                SBLKIE: u1,
                ///  Synchronization Done
                SYNCDIE: u1,
                ///  Serial Interface Error Interrupt Enable
                IFEIE: u1,
                padding: u25,
            }),
            ///  Status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Read data register not empty
                RXNE: u1,
                ///  Control Buffer register is not empty
                CSRNE: u1,
                ///  Parity error
                PERR: u1,
                ///  Overrun error
                OVR: u1,
                ///  Synchronization Block Detected
                SBD: u1,
                ///  Synchronization Done
                SYNCD: u1,
                ///  Framing error
                FERR: u1,
                ///  Synchronization error
                SERR: u1,
                ///  Time-out error
                TERR: u1,
                reserved16: u7,
                ///  Duration of 5 symbols counted with SPDIF_CLK
                WIDTH5: u15,
                padding: u1,
            }),
            ///  Interrupt Flag Clear register
            IFCR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Clears the Parity error flag
                PERRCF: u1,
                ///  Clears the Overrun error flag
                OVRCF: u1,
                ///  Clears the Synchronization Block Detected flag
                SBDCF: u1,
                ///  Clears the Synchronization Done flag
                SYNCDCF: u1,
                padding: u26,
            }),
            ///  Data input register
            DR_00: mmio.Mmio(packed struct(u32) {
                ///  Parity Error bit
                DR: u24,
                ///  Parity Error bit
                PE: u1,
                ///  Validity bit
                V: u1,
                ///  User bit
                U: u1,
                ///  Channel Status bit
                C: u1,
                ///  Preamble Type
                PT: u2,
                padding: u2,
            }),
            ///  Channel Status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  User data information
                USR: u16,
                ///  Channel A status information
                CS: u8,
                ///  Start Of Block
                SOB: u1,
                padding: u7,
            }),
            ///  Debug Information register
            DIR: mmio.Mmio(packed struct(u32) {
                ///  Threshold HIGH
                THI: u13,
                reserved16: u3,
                ///  Threshold LOW
                TLO: u13,
                padding: u3,
            }),
            reserved1012: [984]u8,
            ///  SPDIFRX version register
            VERR: mmio.Mmio(packed struct(u32) {
                ///  Minor revision
                MINREV: u4,
                ///  Major revision
                MAJREV: u4,
                padding: u24,
            }),
            ///  SPDIFRX identification register
            IDR: mmio.Mmio(packed struct(u32) {
                ///  SPDIFRX identifier
                ID: u32,
            }),
            ///  SPDIFRX size identification register
            SIDR: mmio.Mmio(packed struct(u32) {
                ///  Size identification
                SID: u32,
            }),
        };

        ///  Analog to Digital Converter
        pub const ADC3 = extern struct {
            ///  ADC interrupt and status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  ADC ready flag
                ADRDY: u1,
                ///  ADC group regular end of sampling flag
                EOSMP: u1,
                ///  ADC group regular end of unitary conversion flag
                EOC: u1,
                ///  ADC group regular end of sequence conversions flag
                EOS: u1,
                ///  ADC group regular overrun flag
                OVR: u1,
                ///  ADC group injected end of unitary conversion flag
                JEOC: u1,
                ///  ADC group injected end of sequence conversions flag
                JEOS: u1,
                ///  ADC analog watchdog 1 flag
                AWD1: u1,
                ///  ADC analog watchdog 2 flag
                AWD2: u1,
                ///  ADC analog watchdog 3 flag
                AWD3: u1,
                ///  ADC group injected contexts queue overflow flag
                JQOVF: u1,
                padding: u21,
            }),
            ///  ADC interrupt enable register
            IER: mmio.Mmio(packed struct(u32) {
                ///  ADC ready interrupt
                ADRDYIE: u1,
                ///  ADC group regular end of sampling interrupt
                EOSMPIE: u1,
                ///  ADC group regular end of unitary conversion interrupt
                EOCIE: u1,
                ///  ADC group regular end of sequence conversions interrupt
                EOSIE: u1,
                ///  ADC group regular overrun interrupt
                OVRIE: u1,
                ///  ADC group injected end of unitary conversion interrupt
                JEOCIE: u1,
                ///  ADC group injected end of sequence conversions interrupt
                JEOSIE: u1,
                ///  ADC analog watchdog 1 interrupt
                AWD1IE: u1,
                ///  ADC analog watchdog 2 interrupt
                AWD2IE: u1,
                ///  ADC analog watchdog 3 interrupt
                AWD3IE: u1,
                ///  ADC group injected contexts queue overflow interrupt
                JQOVFIE: u1,
                padding: u21,
            }),
            ///  ADC control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  ADC enable
                ADEN: u1,
                ///  ADC disable
                ADDIS: u1,
                ///  ADC group regular conversion start
                ADSTART: u1,
                ///  ADC group injected conversion start
                JADSTART: u1,
                ///  ADC group regular conversion stop
                ADSTP: u1,
                ///  ADC group injected conversion stop
                JADSTP: u1,
                reserved8: u2,
                ///  Boost mode control
                BOOST: u1,
                reserved16: u7,
                ///  Linearity calibration
                ADCALLIN: u1,
                reserved22: u5,
                ///  Linearity calibration ready Word 1
                LINCALRDYW1: u1,
                ///  Linearity calibration ready Word 2
                LINCALRDYW2: u1,
                ///  Linearity calibration ready Word 3
                LINCALRDYW3: u1,
                ///  Linearity calibration ready Word 4
                LINCALRDYW4: u1,
                ///  Linearity calibration ready Word 5
                LINCALRDYW5: u1,
                ///  Linearity calibration ready Word 6
                LINCALRDYW6: u1,
                ///  ADC voltage regulator enable
                ADVREGEN: u1,
                ///  ADC deep power down enable
                DEEPPWD: u1,
                ///  ADC differential mode for calibration
                ADCALDIF: u1,
                ///  ADC calibration
                ADCAL: u1,
            }),
            ///  ADC configuration register 1
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  ADC DMA transfer enable
                DMNGT: u2,
                ///  ADC data resolution
                RES: u3,
                ///  ADC group regular external trigger source
                EXTSEL: u5,
                ///  ADC group regular external trigger polarity
                EXTEN: u2,
                ///  ADC group regular overrun configuration
                OVRMOD: u1,
                ///  ADC group regular continuous conversion mode
                CONT: u1,
                ///  ADC low power auto wait
                AUTDLY: u1,
                reserved16: u1,
                ///  ADC group regular sequencer discontinuous mode
                DISCEN: u1,
                ///  ADC group regular sequencer discontinuous number of ranks
                DISCNUM: u3,
                ///  ADC group injected sequencer discontinuous mode
                JDISCEN: u1,
                ///  ADC group injected contexts queue mode
                JQM: u1,
                ///  ADC analog watchdog 1 monitoring a single channel or all channels
                AWD1SGL: u1,
                ///  ADC analog watchdog 1 enable on scope ADC group regular
                AWD1EN: u1,
                ///  ADC analog watchdog 1 enable on scope ADC group injected
                JAWD1EN: u1,
                ///  ADC group injected automatic trigger mode
                JAUTO: u1,
                ///  ADC analog watchdog 1 monitored channel selection
                AWDCH1CH: u5,
                ///  ADC group injected contexts queue disable
                JQDIS: u1,
            }),
            ///  ADC configuration register 2
            CFGR2: mmio.Mmio(packed struct(u32) {
                ///  ADC oversampler enable on scope ADC group regular
                ROVSE: u1,
                ///  ADC oversampler enable on scope ADC group injected
                JOVSE: u1,
                reserved5: u3,
                ///  ADC oversampling shift
                OVSS: u4,
                ///  ADC oversampling discontinuous mode (triggered mode) for ADC group regular
                TROVS: u1,
                ///  Regular Oversampling mode
                ROVSM: u1,
                ///  Right-shift data after Offset 1 correction
                RSHIFT1: u1,
                ///  Right-shift data after Offset 2 correction
                RSHIFT2: u1,
                ///  Right-shift data after Offset 3 correction
                RSHIFT3: u1,
                ///  Right-shift data after Offset 4 correction
                RSHIFT4: u1,
                reserved16: u1,
                ///  Oversampling ratio
                OSR: u10,
                reserved28: u2,
                ///  Left shift factor
                LSHIFT: u4,
            }),
            ///  ADC sampling time register 1
            SMPR1: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  ADC channel 1 sampling time selection
                SMP1: u3,
                ///  ADC channel 2 sampling time selection
                SMP2: u3,
                ///  ADC channel 3 sampling time selection
                SMP3: u3,
                ///  ADC channel 4 sampling time selection
                SMP4: u3,
                ///  ADC channel 5 sampling time selection
                SMP5: u3,
                ///  ADC channel 6 sampling time selection
                SMP6: u3,
                ///  ADC channel 7 sampling time selection
                SMP7: u3,
                ///  ADC channel 8 sampling time selection
                SMP8: u3,
                ///  ADC channel 9 sampling time selection
                SMP9: u3,
                padding: u2,
            }),
            ///  ADC sampling time register 2
            SMPR2: mmio.Mmio(packed struct(u32) {
                ///  ADC channel 10 sampling time selection
                SMP10: u3,
                ///  ADC channel 11 sampling time selection
                SMP11: u3,
                ///  ADC channel 12 sampling time selection
                SMP12: u3,
                ///  ADC channel 13 sampling time selection
                SMP13: u3,
                ///  ADC channel 14 sampling time selection
                SMP14: u3,
                ///  ADC channel 15 sampling time selection
                SMP15: u3,
                ///  ADC channel 16 sampling time selection
                SMP16: u3,
                ///  ADC channel 17 sampling time selection
                SMP17: u3,
                ///  ADC channel 18 sampling time selection
                SMP18: u3,
                ///  ADC channel 18 sampling time selection
                SMP19: u3,
                padding: u2,
            }),
            ///  ADC pre channel selection register
            PCSEL: mmio.Mmio(packed struct(u32) {
                ///  Channel x (VINP[i]) pre selection
                PCSEL: u20,
                padding: u12,
            }),
            ///  ADC analog watchdog 1 threshold register
            LTR1: mmio.Mmio(packed struct(u32) {
                ///  ADC analog watchdog 1 threshold low
                LTR1: u26,
                padding: u6,
            }),
            ///  ADC analog watchdog 2 threshold register
            LHTR1: mmio.Mmio(packed struct(u32) {
                ///  ADC analog watchdog 2 threshold low
                LHTR1: u26,
                padding: u6,
            }),
            reserved48: [8]u8,
            ///  ADC group regular sequencer ranks register 1
            SQR1: mmio.Mmio(packed struct(u32) {
                ///  L3
                L3: u4,
                reserved6: u2,
                ///  ADC group regular sequencer rank 1
                SQ1: u5,
                reserved12: u1,
                ///  ADC group regular sequencer rank 2
                SQ2: u5,
                reserved18: u1,
                ///  ADC group regular sequencer rank 3
                SQ3: u5,
                reserved24: u1,
                ///  ADC group regular sequencer rank 4
                SQ4: u5,
                padding: u3,
            }),
            ///  ADC group regular sequencer ranks register 2
            SQR2: mmio.Mmio(packed struct(u32) {
                ///  ADC group regular sequencer rank 5
                SQ5: u5,
                reserved6: u1,
                ///  ADC group regular sequencer rank 6
                SQ6: u5,
                reserved12: u1,
                ///  ADC group regular sequencer rank 7
                SQ7: u5,
                reserved18: u1,
                ///  ADC group regular sequencer rank 8
                SQ8: u5,
                reserved24: u1,
                ///  ADC group regular sequencer rank 9
                SQ9: u5,
                padding: u3,
            }),
            ///  ADC group regular sequencer ranks register 3
            SQR3: mmio.Mmio(packed struct(u32) {
                ///  ADC group regular sequencer rank 10
                SQ10: u5,
                reserved6: u1,
                ///  ADC group regular sequencer rank 11
                SQ11: u5,
                reserved12: u1,
                ///  ADC group regular sequencer rank 12
                SQ12: u5,
                reserved18: u1,
                ///  ADC group regular sequencer rank 13
                SQ13: u5,
                reserved24: u1,
                ///  ADC group regular sequencer rank 14
                SQ14: u5,
                padding: u3,
            }),
            ///  ADC group regular sequencer ranks register 4
            SQR4: mmio.Mmio(packed struct(u32) {
                ///  ADC group regular sequencer rank 15
                SQ15: u5,
                reserved6: u1,
                ///  ADC group regular sequencer rank 16
                SQ16: u5,
                padding: u21,
            }),
            ///  ADC group regular conversion data register
            DR: mmio.Mmio(packed struct(u32) {
                ///  ADC group regular conversion data
                RDATA: u16,
                padding: u16,
            }),
            reserved76: [8]u8,
            ///  ADC group injected sequencer register
            JSQR: mmio.Mmio(packed struct(u32) {
                ///  ADC group injected sequencer scan length
                JL: u2,
                ///  ADC group injected external trigger source
                JEXTSEL: u5,
                ///  ADC group injected external trigger polarity
                JEXTEN: u2,
                ///  ADC group injected sequencer rank 1
                JSQ1: u5,
                reserved15: u1,
                ///  ADC group injected sequencer rank 2
                JSQ2: u5,
                reserved21: u1,
                ///  ADC group injected sequencer rank 3
                JSQ3: u5,
                reserved27: u1,
                ///  ADC group injected sequencer rank 4
                JSQ4: u5,
            }),
            reserved96: [16]u8,
            ///  ADC offset number 1 register
            OFR1: mmio.Mmio(packed struct(u32) {
                ///  ADC offset number 1 offset level
                OFFSET1: u26,
                ///  ADC offset number 1 channel selection
                OFFSET1_CH: u5,
                ///  ADC offset number 1 enable
                SSATE: u1,
            }),
            ///  ADC offset number 2 register
            OFR2: mmio.Mmio(packed struct(u32) {
                ///  ADC offset number 1 offset level
                OFFSET1: u26,
                ///  ADC offset number 1 channel selection
                OFFSET1_CH: u5,
                ///  ADC offset number 1 enable
                SSATE: u1,
            }),
            ///  ADC offset number 3 register
            OFR3: mmio.Mmio(packed struct(u32) {
                ///  ADC offset number 1 offset level
                OFFSET1: u26,
                ///  ADC offset number 1 channel selection
                OFFSET1_CH: u5,
                ///  ADC offset number 1 enable
                SSATE: u1,
            }),
            ///  ADC offset number 4 register
            OFR4: mmio.Mmio(packed struct(u32) {
                ///  ADC offset number 1 offset level
                OFFSET1: u26,
                ///  ADC offset number 1 channel selection
                OFFSET1_CH: u5,
                ///  ADC offset number 1 enable
                SSATE: u1,
            }),
            reserved128: [16]u8,
            ///  ADC group injected sequencer rank 1 register
            JDR1: mmio.Mmio(packed struct(u32) {
                ///  ADC group injected sequencer rank 1 conversion data
                JDATA1: u32,
            }),
            ///  ADC group injected sequencer rank 2 register
            JDR2: mmio.Mmio(packed struct(u32) {
                ///  ADC group injected sequencer rank 2 conversion data
                JDATA2: u32,
            }),
            ///  ADC group injected sequencer rank 3 register
            JDR3: mmio.Mmio(packed struct(u32) {
                ///  ADC group injected sequencer rank 3 conversion data
                JDATA3: u32,
            }),
            ///  ADC group injected sequencer rank 4 register
            JDR4: mmio.Mmio(packed struct(u32) {
                ///  ADC group injected sequencer rank 4 conversion data
                JDATA4: u32,
            }),
            reserved160: [16]u8,
            ///  ADC analog watchdog 2 configuration register
            AWD2CR: mmio.Mmio(packed struct(u32) {
                ///  ADC analog watchdog 2 monitored channel selection
                AWD2CH: u20,
                padding: u12,
            }),
            ///  ADC analog watchdog 3 configuration register
            AWD3CR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  ADC analog watchdog 3 monitored channel selection
                AWD3CH: u20,
                padding: u11,
            }),
            reserved176: [8]u8,
            ///  ADC watchdog lower threshold register 2
            LTR2: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 2 lower threshold
                LTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 2
            HTR2: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 2 higher threshold
                HTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog lower threshold register 3
            LTR3: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 3 lower threshold
                LTR3: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 3
            HTR3: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 3 higher threshold
                HTR3: u26,
                padding: u6,
            }),
            ///  ADC channel differential or single-ended mode selection register
            DIFSEL: mmio.Mmio(packed struct(u32) {
                ///  ADC channel differential or single-ended mode for channel
                DIFSEL: u20,
                padding: u12,
            }),
            ///  ADC calibration factors register
            CALFACT: mmio.Mmio(packed struct(u32) {
                ///  ADC calibration factor in single-ended mode
                CALFACT_S: u11,
                reserved16: u5,
                ///  ADC calibration factor in differential mode
                CALFACT_D: u11,
                padding: u5,
            }),
            ///  ADC Calibration Factor register 2
            CALFACT2: mmio.Mmio(packed struct(u32) {
                ///  Linearity Calibration Factor
                LINCALFACT: u30,
                padding: u2,
            }),
        };

        ///  CCU registers
        pub const CAN_CCU = extern struct {
            ///  Clock Calibration Unit Core Release Register
            CREL: mmio.Mmio(packed struct(u32) {
                ///  Time Stamp Day
                DAY: u8,
                ///  Time Stamp Month
                MON: u8,
                ///  Time Stamp Year
                YEAR: u4,
                ///  Sub-step of Core Release
                SUBSTEP: u4,
                ///  Step of Core Release
                STEP: u4,
                ///  Core Release
                REL: u4,
            }),
            ///  Calibration Configuration Register
            CCFG: mmio.Mmio(packed struct(u32) {
                ///  Time Quanta per Bit Time
                TQBT: u5,
                reserved6: u1,
                ///  Bypass Clock Calibration
                BCC: u1,
                ///  Calibration Field Length
                CFL: u1,
                ///  Oscillator Clock Periods Minimum
                OCPM: u8,
                ///  Clock Divider
                CDIV: u4,
                reserved31: u11,
                ///  Software Reset
                SWR: u1,
            }),
            ///  Calibration Status Register
            CSTAT: mmio.Mmio(packed struct(u32) {
                ///  Oscillator Clock Period Counter
                OCPC: u18,
                ///  Time Quanta Counter
                TQC: u11,
                reserved30: u1,
                ///  Calibration State
                CALS: u2,
            }),
            ///  Calibration Watchdog Register
            CWD: mmio.Mmio(packed struct(u32) {
                ///  WDC
                WDC: u16,
                ///  WDV
                WDV: u16,
            }),
            ///  Clock Calibration Unit Interrupt Register
            IR: mmio.Mmio(packed struct(u32) {
                ///  Calibration Watchdog Event
                CWE: u1,
                ///  Calibration State Changed
                CSC: u1,
                padding: u30,
            }),
            ///  Clock Calibration Unit Interrupt Enable Register
            IE: mmio.Mmio(packed struct(u32) {
                ///  Calibration Watchdog Event Enable
                CWEE: u1,
                ///  Calibration State Changed Enable
                CSCE: u1,
                padding: u30,
            }),
        };

        ///  High Resolution Timer: TIMB
        pub const HRTIM_TIMB = extern struct {
            ///  Timerx Control Register
            TIMBCR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Timer x Clock prescaler
                CK_PSCx: u3,
                ///  Continuous mode
                CONT: u1,
                ///  Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                ///  Push-Pull mode enable
                PSHPLL: u1,
                reserved10: u3,
                ///  Synchronization Resets Timer x
                SYNCRSTx: u1,
                ///  Synchronization Starts Timer x
                SYNCSTRTx: u1,
                ///  Delayed CMP2 mode
                DELCMP2: u2,
                ///  Delayed CMP4 mode
                DELCMP4: u2,
                reserved17: u1,
                ///  Timer x Repetition update
                TxREPU: u1,
                ///  Timerx reset update
                TxRSTU: u1,
                reserved20: u1,
                ///  TBU
                TBU: u1,
                ///  TCU
                TCU: u1,
                ///  TDU
                TDU: u1,
                ///  TEU
                TEU: u1,
                ///  Master Timer update
                MSTU: u1,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                ///  Update Gating
                UPDGAT: u4,
            }),
            ///  Timerx Interrupt Status Register
            TIMBISR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt Flag
                CMP1: u1,
                ///  Compare 2 Interrupt Flag
                CMP2: u1,
                ///  Compare 3 Interrupt Flag
                CMP3: u1,
                ///  Compare 4 Interrupt Flag
                CMP4: u1,
                ///  Repetition Interrupt Flag
                REP: u1,
                reserved6: u1,
                ///  Update Interrupt Flag
                UPD: u1,
                ///  Capture1 Interrupt Flag
                CPT1: u1,
                ///  Capture2 Interrupt Flag
                CPT2: u1,
                ///  Output 1 Set Interrupt Flag
                SETx1: u1,
                ///  Output 1 Reset Interrupt Flag
                RSTx1: u1,
                ///  Output 2 Set Interrupt Flag
                SETx2: u1,
                ///  Output 2 Reset Interrupt Flag
                RSTx2: u1,
                ///  Reset Interrupt Flag
                RST: u1,
                ///  Delayed Protection Flag
                DLYPRT: u1,
                reserved16: u1,
                ///  Current Push Pull Status
                CPPSTAT: u1,
                ///  Idle Push Pull Status
                IPPSTAT: u1,
                ///  Output 1 State
                O1STAT: u1,
                ///  Output 2 State
                O2STAT: u1,
                padding: u12,
            }),
            ///  Timerx Interrupt Clear Register
            TIMBICR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt flag Clear
                CMP1C: u1,
                ///  Compare 2 Interrupt flag Clear
                CMP2C: u1,
                ///  Compare 3 Interrupt flag Clear
                CMP3C: u1,
                ///  Compare 4 Interrupt flag Clear
                CMP4C: u1,
                ///  Repetition Interrupt flag Clear
                REPC: u1,
                reserved6: u1,
                ///  Update Interrupt flag Clear
                UPDC: u1,
                ///  Capture1 Interrupt flag Clear
                CPT1C: u1,
                ///  Capture2 Interrupt flag Clear
                CPT2C: u1,
                ///  Output 1 Set flag Clear
                SET1xC: u1,
                ///  Output 1 Reset flag Clear
                RSTx1C: u1,
                ///  Output 2 Set flag Clear
                SET2xC: u1,
                ///  Output 2 Reset flag Clear
                RSTx2C: u1,
                ///  Reset Interrupt flag Clear
                RSTC: u1,
                ///  Delayed Protection Flag Clear
                DLYPRTC: u1,
                padding: u17,
            }),
            ///  TIMxDIER5
            TIMBDIER5: mmio.Mmio(packed struct(u32) {
                ///  CMP1IE
                CMP1IE: u1,
                ///  CMP2IE
                CMP2IE: u1,
                ///  CMP3IE
                CMP3IE: u1,
                ///  CMP4IE
                CMP4IE: u1,
                ///  REPIE
                REPIE: u1,
                reserved6: u1,
                ///  UPDIE
                UPDIE: u1,
                ///  CPT1IE
                CPT1IE: u1,
                ///  CPT2IE
                CPT2IE: u1,
                ///  SET1xIE
                SET1xIE: u1,
                ///  RSTx1IE
                RSTx1IE: u1,
                ///  SETx2IE
                SETx2IE: u1,
                ///  RSTx2IE
                RSTx2IE: u1,
                ///  RSTIE
                RSTIE: u1,
                ///  DLYPRTIE
                DLYPRTIE: u1,
                reserved16: u1,
                ///  CMP1DE
                CMP1DE: u1,
                ///  CMP2DE
                CMP2DE: u1,
                ///  CMP3DE
                CMP3DE: u1,
                ///  CMP4DE
                CMP4DE: u1,
                ///  REPDE
                REPDE: u1,
                reserved22: u1,
                ///  UPDDE
                UPDDE: u1,
                ///  CPT1DE
                CPT1DE: u1,
                ///  CPT2DE
                CPT2DE: u1,
                ///  SET1xDE
                SET1xDE: u1,
                ///  RSTx1DE
                RSTx1DE: u1,
                ///  SETx2DE
                SETx2DE: u1,
                ///  RSTx2DE
                RSTx2DE: u1,
                ///  RSTDE
                RSTDE: u1,
                ///  DLYPRTDE
                DLYPRTDE: u1,
                padding: u1,
            }),
            ///  Timerx Counter Register
            CNTR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Counter value
                CNTx: u16,
                padding: u16,
            }),
            ///  Timerx Period Register
            PERBR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Period value
                PERx: u16,
                padding: u16,
            }),
            ///  Timerx Repetition Register
            REPBR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Repetition counter value
                REPx: u8,
                padding: u24,
            }),
            ///  Timerx Compare 1 Register
            CMP1BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 1 Compound Register
            CMP1CBR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                ///  Timerx Repetition value (aliased from HRTIM_REPx register)
                REPx: u8,
                padding: u8,
            }),
            ///  Timerx Compare 2 Register
            CMP2BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 2 value
                CMP2x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 3 Register
            CMP3BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 3 value
                CMP3x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 4 Register
            CMP4BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 4 value
                CMP4x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 1 Register
            CPT1BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 1 value
                CPT1x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 2 Register
            CPT2BR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 2 value
                CPT2x: u16,
                padding: u16,
            }),
            ///  Timerx Deadtime Register
            DTBR: mmio.Mmio(packed struct(u32) {
                ///  Deadtime Rising value
                DTRx: u9,
                ///  Sign Deadtime Rising value
                SDTRx: u1,
                ///  Deadtime Prescaler
                DTPRSC: u3,
                reserved14: u1,
                ///  Deadtime Rising Sign Lock
                DTRSLKx: u1,
                ///  Deadtime Rising Lock
                DTRLKx: u1,
                ///  Deadtime Falling value
                DTFx: u9,
                ///  Sign Deadtime Falling value
                SDTFx: u1,
                reserved30: u4,
                ///  Deadtime Falling Sign Lock
                DTFSLKx: u1,
                ///  Deadtime Falling Lock
                DTFLKx: u1,
            }),
            ///  Timerx Output1 Set Register
            SETB1R: mmio.Mmio(packed struct(u32) {
                ///  Software Set trigger
                SST: u1,
                ///  Timer A resynchronizaton
                RESYNC: u1,
                ///  Timer A Period
                PER: u1,
                ///  Timer A compare 1
                CMP1: u1,
                ///  Timer A compare 2
                CMP2: u1,
                ///  Timer A compare 3
                CMP3: u1,
                ///  Timer A compare 4
                CMP4: u1,
                ///  Master Period
                MSTPER: u1,
                ///  Master Compare 1
                MSTCMP1: u1,
                ///  Master Compare 2
                MSTCMP2: u1,
                ///  Master Compare 3
                MSTCMP3: u1,
                ///  Master Compare 4
                MSTCMP4: u1,
                ///  Timer Event 1
                TIMEVNT1: u1,
                ///  Timer Event 2
                TIMEVNT2: u1,
                ///  Timer Event 3
                TIMEVNT3: u1,
                ///  Timer Event 4
                TIMEVNT4: u1,
                ///  Timer Event 5
                TIMEVNT5: u1,
                ///  Timer Event 6
                TIMEVNT6: u1,
                ///  Timer Event 7
                TIMEVNT7: u1,
                ///  Timer Event 8
                TIMEVNT8: u1,
                ///  Timer Event 9
                TIMEVNT9: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Registers update (transfer preload to active)
                UPDATE: u1,
            }),
            ///  Timerx Output1 Reset Register
            RSTB1R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Set Register
            SETB2R: mmio.Mmio(packed struct(u32) {
                ///  SST
                SST: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Reset Register
            RSTB2R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx External Event Filtering Register 1
            EEFBR1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 latch
                EE1LTCH: u1,
                ///  External Event 1 filter
                EE1FLTR: u4,
                reserved6: u1,
                ///  External Event 2 latch
                EE2LTCH: u1,
                ///  External Event 2 filter
                EE2FLTR: u4,
                reserved12: u1,
                ///  External Event 3 latch
                EE3LTCH: u1,
                ///  External Event 3 filter
                EE3FLTR: u4,
                reserved18: u1,
                ///  External Event 4 latch
                EE4LTCH: u1,
                ///  External Event 4 filter
                EE4FLTR: u4,
                reserved24: u1,
                ///  External Event 5 latch
                EE5LTCH: u1,
                ///  External Event 5 filter
                EE5FLTR: u4,
                padding: u3,
            }),
            ///  Timerx External Event Filtering Register 2
            EEFBR2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 latch
                EE6LTCH: u1,
                ///  External Event 6 filter
                EE6FLTR: u4,
                reserved6: u1,
                ///  External Event 7 latch
                EE7LTCH: u1,
                ///  External Event 7 filter
                EE7FLTR: u4,
                reserved12: u1,
                ///  External Event 8 latch
                EE8LTCH: u1,
                ///  External Event 8 filter
                EE8FLTR: u4,
                reserved18: u1,
                ///  External Event 9 latch
                EE9LTCH: u1,
                ///  External Event 9 filter
                EE9FLTR: u4,
                reserved24: u1,
                ///  External Event 10 latch
                EE10LTCH: u1,
                ///  External Event 10 filter
                EE10FLTR: u4,
                padding: u3,
            }),
            ///  TimerA Reset Register
            RSTBR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Timer A Update reset
                UPDT: u1,
                ///  Timer A compare 2 reset
                CMP2: u1,
                ///  Timer A compare 4 reset
                CMP4: u1,
                ///  Master timer Period
                MSTPER: u1,
                ///  Master compare 1
                MSTCMP1: u1,
                ///  Master compare 2
                MSTCMP2: u1,
                ///  Master compare 3
                MSTCMP3: u1,
                ///  Master compare 4
                MSTCMP4: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Timer A Compare 1
                TIMACMP1: u1,
                ///  Timer A Compare 2
                TIMACMP2: u1,
                ///  Timer A Compare 4
                TIMACMP4: u1,
                ///  Timer C Compare 1
                TIMCCMP1: u1,
                ///  Timer C Compare 2
                TIMCCMP2: u1,
                ///  Timer C Compare 4
                TIMCCMP4: u1,
                ///  Timer D Compare 1
                TIMDCMP1: u1,
                ///  Timer D Compare 2
                TIMDCMP2: u1,
                ///  Timer D Compare 4
                TIMDCMP4: u1,
                ///  Timer E Compare 1
                TIMECMP1: u1,
                ///  Timer E Compare 2
                TIMECMP2: u1,
                ///  Timer E Compare 4
                TIMECMP4: u1,
                padding: u1,
            }),
            ///  Timerx Chopper Register
            CHPBR: mmio.Mmio(packed struct(u32) {
                ///  Timerx carrier frequency value
                CHPFRQ: u4,
                ///  Timerx chopper duty cycle value
                CHPDTY: u3,
                ///  STRTPW
                STRTPW: u4,
                padding: u21,
            }),
            ///  Timerx Capture 2 Control Register
            CPT1BCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                reserved20: u4,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  CPT2xCR
            CPT2BCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                reserved20: u4,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  Timerx Output Register
            OUTBR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Output 1 polarity
                POL1: u1,
                ///  Output 1 Idle mode
                IDLEM1: u1,
                ///  Output 1 Idle State
                IDLES1: u1,
                ///  Output 1 Fault state
                FAULT1: u2,
                ///  Output 1 Chopper enable
                CHP1: u1,
                ///  Output 1 Deadtime upon burst mode Idle entry
                DIDL1: u1,
                ///  Deadtime enable
                DTEN: u1,
                ///  Delayed Protection Enable
                DLYPRTEN: u1,
                ///  Delayed Protection
                DLYPRT: u3,
                reserved17: u4,
                ///  Output 2 polarity
                POL2: u1,
                ///  Output 2 Idle mode
                IDLEM2: u1,
                ///  Output 2 Idle State
                IDLES2: u1,
                ///  Output 2 Fault state
                FAULT2: u2,
                ///  Output 2 Chopper enable
                CHP2: u1,
                ///  Output 2 Deadtime upon burst mode Idle entry
                DIDL2: u1,
                padding: u8,
            }),
            ///  Timerx Fault Register
            FLTBR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 enable
                FLT1EN: u1,
                ///  Fault 2 enable
                FLT2EN: u1,
                ///  Fault 3 enable
                FLT3EN: u1,
                ///  Fault 4 enable
                FLT4EN: u1,
                ///  Fault 5 enable
                FLT5EN: u1,
                reserved31: u26,
                ///  Fault sources Lock
                FLTLCK: u1,
            }),
        };

        ///  Analog-to-Digital Converter
        pub const ADC3_Common = extern struct {
            ///  ADC Common status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  Master ADC ready
                ADRDY_MST: u1,
                ///  End of Sampling phase flag of the master ADC
                EOSMP_MST: u1,
                ///  End of regular conversion of the master ADC
                EOC_MST: u1,
                ///  End of regular sequence flag of the master ADC
                EOS_MST: u1,
                ///  Overrun flag of the master ADC
                OVR_MST: u1,
                ///  End of injected conversion flag of the master ADC
                JEOC_MST: u1,
                ///  End of injected sequence flag of the master ADC
                JEOS_MST: u1,
                ///  Analog watchdog 1 flag of the master ADC
                AWD1_MST: u1,
                ///  Analog watchdog 2 flag of the master ADC
                AWD2_MST: u1,
                ///  Analog watchdog 3 flag of the master ADC
                AWD3_MST: u1,
                ///  Injected Context Queue Overflow flag of the master ADC
                JQOVF_MST: u1,
                reserved16: u5,
                ///  Slave ADC ready
                ADRDY_SLV: u1,
                ///  End of Sampling phase flag of the slave ADC
                EOSMP_SLV: u1,
                ///  End of regular conversion of the slave ADC
                EOC_SLV: u1,
                ///  End of regular sequence flag of the slave ADC
                EOS_SLV: u1,
                ///  Overrun flag of the slave ADC
                OVR_SLV: u1,
                ///  End of injected conversion flag of the slave ADC
                JEOC_SLV: u1,
                ///  End of injected sequence flag of the slave ADC
                JEOS_SLV: u1,
                ///  Analog watchdog 1 flag of the slave ADC
                AWD1_SLV: u1,
                ///  Analog watchdog 2 flag of the slave ADC
                AWD2_SLV: u1,
                ///  Analog watchdog 3 flag of the slave ADC
                AWD3_SLV: u1,
                ///  Injected Context Queue Overflow flag of the slave ADC
                JQOVF_SLV: u1,
                padding: u5,
            }),
            reserved8: [4]u8,
            ///  ADC common control register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  Dual ADC mode selection
                DUAL: u5,
                reserved8: u3,
                ///  Delay between 2 sampling phases
                DELAY: u4,
                reserved14: u2,
                ///  Dual ADC Mode Data Format
                DAMDF: u2,
                ///  ADC clock mode
                CKMODE: u2,
                ///  ADC prescaler
                PRESC: u4,
                ///  VREFINT enable
                VREFEN: u1,
                ///  Temperature sensor enable
                TSEN: u1,
                ///  VBAT enable
                VBATEN: u1,
                padding: u7,
            }),
            ///  ADC common regular data register for dual and triple modes
            CDR: mmio.Mmio(packed struct(u32) {
                ///  Regular data of the master ADC
                RDATA_MST: u16,
                ///  Regular data of the slave ADC
                RDATA_SLV: u16,
            }),
            ///  ADC x common regular data register for 32-bit dual mode
            CDR2: mmio.Mmio(packed struct(u32) {
                ///  Regular data of the master/slave alternated ADCs
                RDATA_ALT: u32,
            }),
        };

        ///  FDCAN1
        pub const FDCAN1 = extern struct {
            ///  FDCAN Core Release Register
            FDCAN_CREL: mmio.Mmio(packed struct(u32) {
                ///  Timestamp Day
                DAY: u8,
                ///  Timestamp Month
                MON: u8,
                ///  Timestamp Year
                YEAR: u4,
                ///  Sub-step of Core release
                SUBSTEP: u4,
                ///  Step of Core release
                STEP: u4,
                ///  Core release
                REL: u4,
            }),
            ///  FDCAN Core Release Register
            FDCAN_ENDN: mmio.Mmio(packed struct(u32) {
                ///  Endiannes Test Value
                ETV: u32,
            }),
            reserved12: [4]u8,
            ///  FDCAN Data Bit Timing and Prescaler Register
            FDCAN_DBTP: mmio.Mmio(packed struct(u32) {
                ///  Synchronization Jump Width
                DSJW: u4,
                ///  Data time segment after sample point
                DTSEG2: u4,
                ///  Data time segment after sample point
                DTSEG1: u5,
                reserved16: u3,
                ///  Data BIt Rate Prescaler
                DBRP: u5,
                reserved23: u2,
                ///  Transceiver Delay Compensation
                TDC: u1,
                padding: u8,
            }),
            ///  FDCAN Test Register
            FDCAN_TEST: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  Loop Back mode
                LBCK: u1,
                ///  Loop Back mode
                TX: u2,
                ///  Control of Transmit Pin
                RX: u1,
                padding: u24,
            }),
            ///  FDCAN RAM Watchdog Register
            FDCAN_RWD: mmio.Mmio(packed struct(u32) {
                ///  Watchdog configuration
                WDC: u8,
                ///  Watchdog value
                WDV: u8,
                padding: u16,
            }),
            ///  FDCAN CC Control Register
            FDCAN_CCCR: mmio.Mmio(packed struct(u32) {
                ///  Initialization
                INIT: u1,
                ///  Configuration Change Enable
                CCE: u1,
                ///  ASM Restricted Operation Mode
                ASM: u1,
                ///  Clock Stop Acknowledge
                CSA: u1,
                ///  Clock Stop Request
                CSR: u1,
                ///  Bus Monitoring Mode
                MON: u1,
                ///  Disable Automatic Retransmission
                DAR: u1,
                ///  Test Mode Enable
                TEST: u1,
                ///  FD Operation Enable
                FDOE: u1,
                ///  FDCAN Bit Rate Switching
                BSE: u1,
                reserved12: u2,
                ///  Protocol Exception Handling Disable
                PXHD: u1,
                ///  Edge Filtering during Bus Integration
                EFBI: u1,
                ///  TXP
                TXP: u1,
                ///  Non ISO Operation
                NISO: u1,
                padding: u16,
            }),
            ///  FDCAN Nominal Bit Timing and Prescaler Register
            FDCAN_NBTP: mmio.Mmio(packed struct(u32) {
                ///  Nominal Time segment after sample point
                TSEG2: u7,
                reserved8: u1,
                ///  Nominal Time segment before sample point
                NTSEG1: u8,
                ///  Bit Rate Prescaler
                NBRP: u9,
                ///  NSJW: Nominal (Re)Synchronization Jump Width
                NSJW: u7,
            }),
            ///  FDCAN Timestamp Counter Configuration Register
            FDCAN_TSCC: mmio.Mmio(packed struct(u32) {
                ///  Timestamp Select
                TSS: u2,
                reserved16: u14,
                ///  Timestamp Counter Prescaler
                TCP: u4,
                padding: u12,
            }),
            ///  FDCAN Timestamp Counter Value Register
            FDCAN_TSCV: mmio.Mmio(packed struct(u32) {
                ///  Timestamp Counter
                TSC: u16,
                padding: u16,
            }),
            ///  FDCAN Timeout Counter Configuration Register
            FDCAN_TOCC: mmio.Mmio(packed struct(u32) {
                ///  Enable Timeout Counter
                ETOC: u1,
                ///  Timeout Select
                TOS: u2,
                reserved16: u13,
                ///  Timeout Period
                TOP: u16,
            }),
            ///  FDCAN Timeout Counter Value Register
            FDCAN_TOCV: mmio.Mmio(packed struct(u32) {
                ///  Timeout Counter
                TOC: u16,
                padding: u16,
            }),
            reserved64: [16]u8,
            ///  FDCAN Error Counter Register
            FDCAN_ECR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Error Counter
                TEC: u8,
                ///  Receive Error Counter
                TREC: u7,
                ///  Receive Error Passive
                RP: u1,
                ///  AN Error Logging
                CEL: u8,
                padding: u8,
            }),
            ///  FDCAN Protocol Status Register
            FDCAN_PSR: mmio.Mmio(packed struct(u32) {
                ///  Last Error Code
                LEC: u3,
                ///  Activity
                ACT: u2,
                ///  Error Passive
                EP: u1,
                ///  Warning Status
                EW: u1,
                ///  Bus_Off Status
                BO: u1,
                ///  Data Last Error Code
                DLEC: u3,
                ///  ESI flag of last received FDCAN Message
                RESI: u1,
                ///  BRS flag of last received FDCAN Message
                RBRS: u1,
                ///  Received FDCAN Message
                REDL: u1,
                ///  Protocol Exception Event
                PXE: u1,
                reserved16: u1,
                ///  Transmitter Delay Compensation Value
                TDCV: u7,
                padding: u9,
            }),
            ///  FDCAN Transmitter Delay Compensation Register
            FDCAN_TDCR: mmio.Mmio(packed struct(u32) {
                ///  Transmitter Delay Compensation Filter Window Length
                TDCF: u7,
                reserved8: u1,
                ///  Transmitter Delay Compensation Offset
                TDCO: u7,
                padding: u17,
            }),
            reserved80: [4]u8,
            ///  FDCAN Interrupt Register
            FDCAN_IR: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 0 New Message
                RF0N: u1,
                ///  Rx FIFO 0 Full
                RF0W: u1,
                ///  Rx FIFO 0 Full
                RF0F: u1,
                ///  Rx FIFO 0 Message Lost
                RF0L: u1,
                ///  Rx FIFO 1 New Message
                RF1N: u1,
                ///  Rx FIFO 1 Watermark Reached
                RF1W: u1,
                ///  Rx FIFO 1 Watermark Reached
                RF1F: u1,
                ///  Rx FIFO 1 Message Lost
                RF1L: u1,
                ///  High Priority Message
                HPM: u1,
                ///  Transmission Completed
                TC: u1,
                ///  Transmission Cancellation Finished
                TCF: u1,
                ///  Tx FIFO Empty
                TEF: u1,
                ///  Tx Event FIFO New Entry
                TEFN: u1,
                ///  Tx Event FIFO Watermark Reached
                TEFW: u1,
                ///  Tx Event FIFO Full
                TEFF: u1,
                ///  Tx Event FIFO Element Lost
                TEFL: u1,
                ///  Timestamp Wraparound
                TSW: u1,
                ///  Message RAM Access Failure
                MRAF: u1,
                ///  Timeout Occurred
                TOO: u1,
                ///  Message stored to Dedicated Rx Buffer
                DRX: u1,
                reserved22: u2,
                ///  Error Logging Overflow
                ELO: u1,
                ///  Error Passive
                EP: u1,
                ///  Warning Status
                EW: u1,
                ///  Bus_Off Status
                BO: u1,
                ///  Watchdog Interrupt
                WDI: u1,
                ///  Protocol Error in Arbitration Phase (Nominal Bit Time is used)
                PEA: u1,
                ///  Protocol Error in Data Phase (Data Bit Time is used)
                PED: u1,
                ///  Access to Reserved Address
                ARA: u1,
                padding: u2,
            }),
            ///  FDCAN Interrupt Enable Register
            FDCAN_IE: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 0 New Message Enable
                RF0NE: u1,
                ///  Rx FIFO 0 Full Enable
                RF0WE: u1,
                ///  Rx FIFO 0 Full Enable
                RF0FE: u1,
                ///  Rx FIFO 0 Message Lost Enable
                RF0LE: u1,
                ///  Rx FIFO 1 New Message Enable
                RF1NE: u1,
                ///  Rx FIFO 1 Watermark Reached Enable
                RF1WE: u1,
                ///  Rx FIFO 1 Watermark Reached Enable
                RF1FE: u1,
                ///  Rx FIFO 1 Message Lost Enable
                RF1LE: u1,
                ///  High Priority Message Enable
                HPME: u1,
                ///  Transmission Completed Enable
                TCE: u1,
                ///  Transmission Cancellation Finished Enable
                TCFE: u1,
                ///  Tx FIFO Empty Enable
                TEFE: u1,
                ///  Tx Event FIFO New Entry Enable
                TEFNE: u1,
                ///  Tx Event FIFO Watermark Reached Enable
                TEFWE: u1,
                ///  Tx Event FIFO Full Enable
                TEFFE: u1,
                ///  Tx Event FIFO Element Lost Enable
                TEFLE: u1,
                ///  Timestamp Wraparound Enable
                TSWE: u1,
                ///  Message RAM Access Failure Enable
                MRAFE: u1,
                ///  Timeout Occurred Enable
                TOOE: u1,
                ///  Message stored to Dedicated Rx Buffer Enable
                DRXE: u1,
                ///  Bit Error Corrected Interrupt Enable
                BECE: u1,
                ///  Bit Error Uncorrected Interrupt Enable
                BEUE: u1,
                ///  Error Logging Overflow Enable
                ELOE: u1,
                ///  Error Passive Enable
                EPE: u1,
                ///  Warning Status Enable
                EWE: u1,
                ///  Bus_Off Status Enable
                BOE: u1,
                ///  Watchdog Interrupt Enable
                WDIE: u1,
                ///  Protocol Error in Arbitration Phase Enable
                PEAE: u1,
                ///  Protocol Error in Data Phase Enable
                PEDE: u1,
                ///  Access to Reserved Address Enable
                ARAE: u1,
                padding: u2,
            }),
            ///  FDCAN Interrupt Line Select Register
            FDCAN_ILS: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 0 New Message Interrupt Line
                RF0NL: u1,
                ///  Rx FIFO 0 Watermark Reached Interrupt Line
                RF0WL: u1,
                ///  Rx FIFO 0 Full Interrupt Line
                RF0FL: u1,
                ///  Rx FIFO 0 Message Lost Interrupt Line
                RF0LL: u1,
                ///  Rx FIFO 1 New Message Interrupt Line
                RF1NL: u1,
                ///  Rx FIFO 1 Watermark Reached Interrupt Line
                RF1WL: u1,
                ///  Rx FIFO 1 Full Interrupt Line
                RF1FL: u1,
                ///  Rx FIFO 1 Message Lost Interrupt Line
                RF1LL: u1,
                ///  High Priority Message Interrupt Line
                HPML: u1,
                ///  Transmission Completed Interrupt Line
                TCL: u1,
                ///  Transmission Cancellation Finished Interrupt Line
                TCFL: u1,
                ///  Tx FIFO Empty Interrupt Line
                TEFL: u1,
                ///  Tx Event FIFO New Entry Interrupt Line
                TEFNL: u1,
                ///  Tx Event FIFO Watermark Reached Interrupt Line
                TEFWL: u1,
                ///  Tx Event FIFO Full Interrupt Line
                TEFFL: u1,
                ///  Tx Event FIFO Element Lost Interrupt Line
                TEFLL: u1,
                ///  Timestamp Wraparound Interrupt Line
                TSWL: u1,
                ///  Message RAM Access Failure Interrupt Line
                MRAFL: u1,
                ///  Timeout Occurred Interrupt Line
                TOOL: u1,
                ///  Message stored to Dedicated Rx Buffer Interrupt Line
                DRXL: u1,
                ///  Bit Error Corrected Interrupt Line
                BECL: u1,
                ///  Bit Error Uncorrected Interrupt Line
                BEUL: u1,
                ///  Error Logging Overflow Interrupt Line
                ELOL: u1,
                ///  Error Passive Interrupt Line
                EPL: u1,
                ///  Warning Status Interrupt Line
                EWL: u1,
                ///  Bus_Off Status
                BOL: u1,
                ///  Watchdog Interrupt Line
                WDIL: u1,
                ///  Protocol Error in Arbitration Phase Line
                PEAL: u1,
                ///  Protocol Error in Data Phase Line
                PEDL: u1,
                ///  Access to Reserved Address Line
                ARAL: u1,
                padding: u2,
            }),
            ///  FDCAN Interrupt Line Enable Register
            FDCAN_ILE: mmio.Mmio(packed struct(u32) {
                ///  Enable Interrupt Line 0
                EINT0: u1,
                ///  Enable Interrupt Line 1
                EINT1: u1,
                padding: u30,
            }),
            reserved128: [32]u8,
            ///  FDCAN Global Filter Configuration Register
            FDCAN_GFC: mmio.Mmio(packed struct(u32) {
                ///  Reject Remote Frames Extended
                RRFE: u1,
                ///  Reject Remote Frames Standard
                RRFS: u1,
                ///  Accept Non-matching Frames Extended
                ANFE: u2,
                ///  Accept Non-matching Frames Standard
                ANFS: u2,
                padding: u26,
            }),
            ///  FDCAN Standard ID Filter Configuration Register
            FDCAN_SIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Filter List Standard Start Address
                FLSSA: u14,
                ///  List Size Standard
                LSS: u8,
                padding: u8,
            }),
            ///  FDCAN Extended ID Filter Configuration Register
            FDCAN_XIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Filter List Standard Start Address
                FLESA: u14,
                ///  List Size Extended
                LSE: u8,
                padding: u8,
            }),
            reserved144: [4]u8,
            ///  FDCAN Extended ID and Mask Register
            FDCAN_XIDAM: mmio.Mmio(packed struct(u32) {
                ///  Extended ID Mask
                EIDM: u29,
                padding: u3,
            }),
            ///  FDCAN High Priority Message Status Register
            FDCAN_HPMS: mmio.Mmio(packed struct(u32) {
                ///  Buffer Index
                BIDX: u6,
                ///  Message Storage Indicator
                MSI: u2,
                ///  Filter Index
                FIDX: u7,
                ///  Filter List
                FLST: u1,
                padding: u16,
            }),
            ///  FDCAN New Data 1 Register
            FDCAN_NDAT1: mmio.Mmio(packed struct(u32) {
                ///  New data
                ND0: u1,
                ///  New data
                ND1: u1,
                ///  New data
                ND2: u1,
                ///  New data
                ND3: u1,
                ///  New data
                ND4: u1,
                ///  New data
                ND5: u1,
                ///  New data
                ND6: u1,
                ///  New data
                ND7: u1,
                ///  New data
                ND8: u1,
                ///  New data
                ND9: u1,
                ///  New data
                ND10: u1,
                ///  New data
                ND11: u1,
                ///  New data
                ND12: u1,
                ///  New data
                ND13: u1,
                ///  New data
                ND14: u1,
                ///  New data
                ND15: u1,
                ///  New data
                ND16: u1,
                ///  New data
                ND17: u1,
                ///  New data
                ND18: u1,
                ///  New data
                ND19: u1,
                ///  New data
                ND20: u1,
                ///  New data
                ND21: u1,
                ///  New data
                ND22: u1,
                ///  New data
                ND23: u1,
                ///  New data
                ND24: u1,
                ///  New data
                ND25: u1,
                ///  New data
                ND26: u1,
                ///  New data
                ND27: u1,
                ///  New data
                ND28: u1,
                ///  New data
                ND29: u1,
                ///  New data
                ND30: u1,
                ///  New data
                ND31: u1,
            }),
            ///  FDCAN New Data 2 Register
            FDCAN_NDAT2: mmio.Mmio(packed struct(u32) {
                ///  New data
                ND32: u1,
                ///  New data
                ND33: u1,
                ///  New data
                ND34: u1,
                ///  New data
                ND35: u1,
                ///  New data
                ND36: u1,
                ///  New data
                ND37: u1,
                ///  New data
                ND38: u1,
                ///  New data
                ND39: u1,
                ///  New data
                ND40: u1,
                ///  New data
                ND41: u1,
                ///  New data
                ND42: u1,
                ///  New data
                ND43: u1,
                ///  New data
                ND44: u1,
                ///  New data
                ND45: u1,
                ///  New data
                ND46: u1,
                ///  New data
                ND47: u1,
                ///  New data
                ND48: u1,
                ///  New data
                ND49: u1,
                ///  New data
                ND50: u1,
                ///  New data
                ND51: u1,
                ///  New data
                ND52: u1,
                ///  New data
                ND53: u1,
                ///  New data
                ND54: u1,
                ///  New data
                ND55: u1,
                ///  New data
                ND56: u1,
                ///  New data
                ND57: u1,
                ///  New data
                ND58: u1,
                ///  New data
                ND59: u1,
                ///  New data
                ND60: u1,
                ///  New data
                ND61: u1,
                ///  New data
                ND62: u1,
                ///  New data
                ND63: u1,
            }),
            ///  FDCAN Rx FIFO 0 Configuration Register
            FDCAN_RXF0C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Rx FIFO 0 Start Address
                F0SA: u14,
                ///  Rx FIFO 0 Size
                F0S: u8,
                ///  FIFO 0 Watermark
                F0WM: u8,
            }),
            ///  FDCAN Rx FIFO 0 Status Register
            FDCAN_RXF0S: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 0 Fill Level
                F0FL: u7,
                reserved8: u1,
                ///  Rx FIFO 0 Get Index
                F0G: u6,
                reserved16: u2,
                ///  Rx FIFO 0 Put Index
                F0P: u6,
                reserved24: u2,
                ///  Rx FIFO 0 Full
                F0F: u1,
                ///  Rx FIFO 0 Message Lost
                RF0L: u1,
                padding: u6,
            }),
            ///  CAN Rx FIFO 0 Acknowledge Register
            FDCAN_RXF0A: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 0 Acknowledge Index
                FA01: u6,
                padding: u26,
            }),
            ///  FDCAN Rx Buffer Configuration Register
            FDCAN_RXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Rx Buffer Start Address
                RBSA: u14,
                padding: u16,
            }),
            ///  FDCAN Rx FIFO 1 Configuration Register
            FDCAN_RXF1C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Rx FIFO 1 Start Address
                F1SA: u14,
                ///  Rx FIFO 1 Size
                F1S: u7,
                reserved24: u1,
                ///  Rx FIFO 1 Watermark
                F1WM: u7,
                padding: u1,
            }),
            ///  FDCAN Rx FIFO 1 Status Register
            FDCAN_RXF1S: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 1 Fill Level
                F1FL: u7,
                reserved8: u1,
                ///  Rx FIFO 1 Get Index
                F1GI: u7,
                reserved16: u1,
                ///  Rx FIFO 1 Put Index
                F1PI: u7,
                reserved24: u1,
                ///  Rx FIFO 1 Full
                F1F: u1,
                ///  Rx FIFO 1 Message Lost
                RF1L: u1,
                reserved30: u4,
                ///  Debug Message Status
                DMS: u2,
            }),
            ///  FDCAN Rx FIFO 1 Acknowledge Register
            FDCAN_RXF1A: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 1 Acknowledge Index
                F1AI: u6,
                padding: u26,
            }),
            ///  FDCAN Rx Buffer Element Size Configuration Register
            FDCAN_RXESC: mmio.Mmio(packed struct(u32) {
                ///  Rx FIFO 1 Data Field Size:
                F0DS: u3,
                reserved4: u1,
                ///  Rx FIFO 0 Data Field Size:
                F1DS: u3,
                reserved8: u1,
                ///  Rx Buffer Data Field Size:
                RBDS: u3,
                padding: u21,
            }),
            ///  FDCAN Tx Buffer Configuration Register
            FDCAN_TXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Tx Buffers Start Address
                TBSA: u14,
                ///  Number of Dedicated Transmit Buffers
                NDTB: u6,
                reserved24: u2,
                ///  Transmit FIFO/Queue Size
                TFQS: u6,
                ///  Tx FIFO/Queue Mode
                TFQM: u1,
                padding: u1,
            }),
            ///  FDCAN Tx FIFO/Queue Status Register
            FDCAN_TXFQS: mmio.Mmio(packed struct(u32) {
                ///  Tx FIFO Free Level
                TFFL: u6,
                reserved8: u2,
                ///  TFGI
                TFGI: u5,
                reserved16: u3,
                ///  Tx FIFO/Queue Put Index
                TFQPI: u5,
                ///  Tx FIFO/Queue Full
                TFQF: u1,
                padding: u10,
            }),
            ///  FDCAN Tx Buffer Element Size Configuration Register
            FDCAN_TXESC: mmio.Mmio(packed struct(u32) {
                ///  Tx Buffer Data Field Size:
                TBDS: u3,
                padding: u29,
            }),
            ///  FDCAN Tx Buffer Request Pending Register
            FDCAN_TXBRP: mmio.Mmio(packed struct(u32) {
                ///  Transmission Request Pending
                TRP: u32,
            }),
            ///  FDCAN Tx Buffer Add Request Register
            FDCAN_TXBAR: mmio.Mmio(packed struct(u32) {
                ///  Add Request
                AR: u32,
            }),
            ///  FDCAN Tx Buffer Cancellation Request Register
            FDCAN_TXBCR: mmio.Mmio(packed struct(u32) {
                ///  Cancellation Request
                CR: u32,
            }),
            ///  FDCAN Tx Buffer Transmission Occurred Register
            FDCAN_TXBTO: mmio.Mmio(packed struct(u32) {
                ///  Transmission Occurred.
                TO: u32,
            }),
            ///  FDCAN Tx Buffer Cancellation Finished Register
            FDCAN_TXBCF: mmio.Mmio(packed struct(u32) {
                ///  Cancellation Finished
                CF: u32,
            }),
            ///  FDCAN Tx Buffer Transmission Interrupt Enable Register
            FDCAN_TXBTIE: mmio.Mmio(packed struct(u32) {
                ///  Transmission Interrupt Enable
                TIE: u32,
            }),
            ///  FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
            FDCAN_TXBCIE: mmio.Mmio(packed struct(u32) {
                ///  Cancellation Finished Interrupt Enable
                CF: u32,
            }),
            reserved240: [8]u8,
            ///  FDCAN Tx Event FIFO Configuration Register
            FDCAN_TXEFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Event FIFO Start Address
                EFSA: u14,
                ///  Event FIFO Size
                EFS: u6,
                reserved24: u2,
                ///  Event FIFO Watermark
                EFWM: u6,
                padding: u2,
            }),
            ///  FDCAN Tx Event FIFO Status Register
            FDCAN_TXEFS: mmio.Mmio(packed struct(u32) {
                ///  Event FIFO Fill Level
                EFFL: u6,
                reserved8: u2,
                ///  Event FIFO Get Index.
                EFGI: u5,
                reserved24: u11,
                ///  Event FIFO Full.
                EFF: u1,
                ///  Tx Event FIFO Element Lost.
                TEFL: u1,
                padding: u6,
            }),
            ///  FDCAN Tx Event FIFO Acknowledge Register
            FDCAN_TXEFA: mmio.Mmio(packed struct(u32) {
                ///  Event FIFO Acknowledge Index
                EFAI: u5,
                padding: u27,
            }),
            reserved256: [4]u8,
            ///  FDCAN TT Trigger Memory Configuration Register
            FDCAN_TTTMC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Trigger Memory Start Address
                TMSA: u14,
                ///  Trigger Memory Elements
                TME: u7,
                padding: u9,
            }),
            ///  FDCAN TT Reference Message Configuration Register
            FDCAN_TTRMC: mmio.Mmio(packed struct(u32) {
                ///  Reference Identifier.
                RID: u29,
                reserved30: u1,
                ///  Extended Identifier
                XTD: u1,
                ///  Reference Message Payload Select
                RMPS: u1,
            }),
            ///  FDCAN TT Operation Configuration Register
            FDCAN_TTOCF: mmio.Mmio(packed struct(u32) {
                ///  Operation Mode
                OM: u2,
                reserved3: u1,
                ///  Gap Enable
                GEN: u1,
                ///  Time Master
                TM: u1,
                ///  LD of Synchronization Deviation Limit
                LDSDL: u3,
                ///  Initial Reference Trigger Offset
                IRTO: u7,
                ///  Enable External Clock Synchronization
                EECS: u1,
                ///  Application Watchdog Limit
                AWL: u8,
                ///  Enable Global Time Filtering
                EGTF: u1,
                ///  Enable Clock Calibration
                ECC: u1,
                ///  Event Trigger Polarity
                EVTP: u1,
                padding: u5,
            }),
            ///  FDCAN TT Matrix Limits Register
            FDCAN_TTMLM: mmio.Mmio(packed struct(u32) {
                ///  Cycle Count Max
                CCM: u6,
                ///  Cycle Start Synchronization
                CSS: u2,
                ///  Tx Enable Window
                TXEW: u4,
                reserved16: u4,
                ///  Expected Number of Tx Triggers
                ENTT: u12,
                padding: u4,
            }),
            ///  FDCAN TUR Configuration Register
            FDCAN_TURCF: mmio.Mmio(packed struct(u32) {
                ///  Numerator Configuration Low.
                NCL: u16,
                ///  Denominator Configuration.
                DC: u14,
                reserved31: u1,
                ///  Enable Local Time
                ELT: u1,
            }),
            ///  FDCAN TT Operation Control Register
            FDCAN_TTOCN: mmio.Mmio(packed struct(u32) {
                ///  Set Global time
                SGT: u1,
                ///  External Clock Synchronization
                ECS: u1,
                ///  Stop Watch Polarity
                SWP: u1,
                ///  Stop Watch Source.
                SWS: u2,
                ///  Register Time Mark Interrupt Pulse Enable
                RTIE: u1,
                ///  Register Time Mark Compare
                TMC: u2,
                ///  Trigger Time Mark Interrupt Pulse Enable
                TTIE: u1,
                ///  Gap Control Select
                GCS: u1,
                ///  Finish Gap.
                FGP: u1,
                ///  Time Mark Gap
                TMG: u1,
                ///  Next is Gap
                NIG: u1,
                ///  External Synchronization Control
                ESCN: u1,
                reserved15: u1,
                ///  TT Operation Control Register Locked
                LCKC: u1,
                padding: u16,
            }),
            ///  FDCAN TT Global Time Preset Register
            CAN_TTGTP: mmio.Mmio(packed struct(u32) {
                ///  Time Preset
                NCL: u16,
                ///  Cycle Time Target Phase
                CTP: u16,
            }),
            ///  FDCAN TT Time Mark Register
            FDCAN_TTTMK: mmio.Mmio(packed struct(u32) {
                ///  Time Mark
                TM: u16,
                ///  Time Mark Cycle Code
                TICC: u7,
                reserved31: u8,
                ///  TT Time Mark Register Locked
                LCKM: u1,
            }),
            ///  FDCAN TT Interrupt Register
            FDCAN_TTIR: mmio.Mmio(packed struct(u32) {
                ///  Start of Basic Cycle
                SBC: u1,
                ///  Start of Matrix Cycle
                SMC: u1,
                ///  Change of Synchronization Mode
                CSM: u1,
                ///  Start of Gap
                SOG: u1,
                ///  Register Time Mark Interrupt.
                RTMI: u1,
                ///  Trigger Time Mark Event Internal
                TTMI: u1,
                ///  Stop Watch Event
                SWE: u1,
                ///  Global Time Wrap
                GTW: u1,
                ///  Global Time Discontinuity
                GTD: u1,
                ///  Global Time Error
                GTE: u1,
                ///  Tx Count Underflow
                TXU: u1,
                ///  Tx Count Overflow
                TXO: u1,
                ///  Scheduling Error 1
                SE1: u1,
                ///  Scheduling Error 2
                SE2: u1,
                ///  Error Level Changed.
                ELC: u1,
                ///  Initialization Watch Trigger
                IWTG: u1,
                ///  Watch Trigger
                WT: u1,
                ///  Application Watchdog
                AW: u1,
                ///  Configuration Error
                CER: u1,
                padding: u13,
            }),
            ///  FDCAN TT Interrupt Enable Register
            FDCAN_TTIE: mmio.Mmio(packed struct(u32) {
                ///  Start of Basic Cycle Interrupt Enable
                SBCE: u1,
                ///  Start of Matrix Cycle Interrupt Enable
                SMCE: u1,
                ///  Change of Synchronization Mode Interrupt Enable
                CSME: u1,
                ///  Start of Gap Interrupt Enable
                SOGE: u1,
                ///  Register Time Mark Interrupt Enable
                RTMIE: u1,
                ///  Trigger Time Mark Event Internal Interrupt Enable
                TTMIE: u1,
                ///  Stop Watch Event Interrupt Enable
                SWEE: u1,
                ///  Global Time Wrap Interrupt Enable
                GTWE: u1,
                ///  Global Time Discontinuity Interrupt Enable
                GTDE: u1,
                ///  Global Time Error Interrupt Enable
                GTEE: u1,
                ///  Tx Count Underflow Interrupt Enable
                TXUE: u1,
                ///  Tx Count Overflow Interrupt Enable
                TXOE: u1,
                ///  Scheduling Error 1 Interrupt Enable
                SE1E: u1,
                ///  Scheduling Error 2 Interrupt Enable
                SE2E: u1,
                ///  Change Error Level Interrupt Enable
                ELCE: u1,
                ///  Initialization Watch Trigger Interrupt Enable
                IWTGE: u1,
                ///  Watch Trigger Interrupt Enable
                WTE: u1,
                ///  Application Watchdog Interrupt Enable
                AWE: u1,
                ///  Configuration Error Interrupt Enable
                CERE: u1,
                padding: u13,
            }),
            ///  FDCAN TT Interrupt Line Select Register
            FDCAN_TTILS: mmio.Mmio(packed struct(u32) {
                ///  Start of Basic Cycle Interrupt Line
                SBCL: u1,
                ///  Start of Matrix Cycle Interrupt Line
                SMCL: u1,
                ///  Change of Synchronization Mode Interrupt Line
                CSML: u1,
                ///  Start of Gap Interrupt Line
                SOGL: u1,
                ///  Register Time Mark Interrupt Line
                RTMIL: u1,
                ///  Trigger Time Mark Event Internal Interrupt Line
                TTMIL: u1,
                ///  Stop Watch Event Interrupt Line
                SWEL: u1,
                ///  Global Time Wrap Interrupt Line
                GTWL: u1,
                ///  Global Time Discontinuity Interrupt Line
                GTDL: u1,
                ///  Global Time Error Interrupt Line
                GTEL: u1,
                ///  Tx Count Underflow Interrupt Line
                TXUL: u1,
                ///  Tx Count Overflow Interrupt Line
                TXOL: u1,
                ///  Scheduling Error 1 Interrupt Line
                SE1L: u1,
                ///  Scheduling Error 2 Interrupt Line
                SE2L: u1,
                ///  Change Error Level Interrupt Line
                ELCL: u1,
                ///  Initialization Watch Trigger Interrupt Line
                IWTGL: u1,
                ///  Watch Trigger Interrupt Line
                WTL: u1,
                ///  Application Watchdog Interrupt Line
                AWL: u1,
                ///  Configuration Error Interrupt Line
                CERL: u1,
                padding: u13,
            }),
            ///  FDCAN TT Operation Status Register
            FDCAN_TTOST: mmio.Mmio(packed struct(u32) {
                ///  Error Level
                EL: u2,
                ///  Master State.
                MS: u2,
                ///  Synchronization State
                SYS: u2,
                ///  Quality of Global Time Phase
                GTP: u1,
                ///  Quality of Clock Speed
                QCS: u1,
                ///  Reference Trigger Offset
                RTO: u8,
                reserved22: u6,
                ///  Wait for Global Time Discontinuity
                WGTD: u1,
                ///  Gap Finished Indicator.
                GFI: u1,
                ///  Time Master Priority
                TMP: u3,
                ///  Gap Started Indicator.
                GSI: u1,
                ///  Wait for Event
                WFE: u1,
                ///  Application Watchdog Event
                AWE: u1,
                ///  Wait for External Clock Synchronization
                WECS: u1,
                ///  Schedule Phase Lock
                SPL: u1,
            }),
            ///  FDCAN TUR Numerator Actual Register
            FDCAN_TURNA: mmio.Mmio(packed struct(u32) {
                ///  Numerator Actual Value
                NAV: u18,
                padding: u14,
            }),
            ///  FDCAN TT Local and Global Time Register
            FDCAN_TTLGT: mmio.Mmio(packed struct(u32) {
                ///  Local Time
                LT: u16,
                ///  Global Time
                GT: u16,
            }),
            ///  FDCAN TT Cycle Time and Count Register
            FDCAN_TTCTC: mmio.Mmio(packed struct(u32) {
                ///  Cycle Time
                CT: u16,
                ///  Cycle Count
                CC: u6,
                padding: u10,
            }),
            ///  FDCAN TT Capture Time Register
            FDCAN_TTCPT: mmio.Mmio(packed struct(u32) {
                ///  Cycle Count Value
                CT: u6,
                reserved16: u10,
                ///  Stop Watch Value
                SWV: u16,
            }),
            ///  FDCAN TT Cycle Sync Mark Register
            FDCAN_TTCSM: mmio.Mmio(packed struct(u32) {
                ///  Cycle Sync Mark
                CSM: u16,
                padding: u16,
            }),
            reserved768: [444]u8,
            ///  FDCAN TT Trigger Select Register
            FDCAN_TTTS: mmio.Mmio(packed struct(u32) {
                ///  Stop watch trigger input selection
                SWTDEL: u2,
                reserved4: u2,
                ///  Event trigger input selection
                EVTSEL: u2,
                padding: u26,
            }),
        };

        ///  DMAMUX
        pub const DMAMUX1 = extern struct {
            ///  DMAMux - DMA request line multiplexer channel x control register
            C0CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C1CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C2CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C3CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C4CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C5CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C6CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C7CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C8CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C9CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C10CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C11CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C12CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C13CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C14CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMux - DMA request line multiplexer channel x control register
            C15CR: mmio.Mmio(packed struct(u32) {
                ///  Input DMA request line selected
                DMAREQ_ID: u8,
                ///  Interrupt enable at synchronization event overrun
                SOIE: u1,
                ///  Event generation enable/disable
                EGE: u1,
                reserved16: u6,
                ///  Synchronous operating mode enable/disable
                SE: u1,
                ///  Synchronization event type selector Defines the synchronization event on the selected synchronization input:
                SPOL: u2,
                ///  Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
                NBREQ: u5,
                ///  Synchronization input selected
                SYNC_ID: u5,
                padding: u3,
            }),
            reserved128: [64]u8,
            ///  DMAMUX request line multiplexer interrupt channel status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  Synchronization overrun event flag
                SOF: u16,
                padding: u16,
            }),
            ///  DMAMUX request line multiplexer interrupt clear flag register
            CFR: mmio.Mmio(packed struct(u32) {
                ///  Clear synchronization overrun event flag
                CSOF: u16,
                padding: u16,
            }),
            reserved256: [120]u8,
            ///  DMAMux - DMA request generator channel x control register
            RG0CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG1CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG2CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG3CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG4CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG5CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG6CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMux - DMA request generator channel x control register
            RG7CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request trigger input selected
                SIG_ID: u5,
                reserved8: u3,
                ///  Interrupt enable at trigger event overrun
                OIE: u1,
                reserved16: u7,
                ///  DMA request generator channel enable/disable
                GE: u1,
                ///  DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
                GPOL: u2,
                ///  Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
                GNBREQ: u5,
                padding: u8,
            }),
            reserved320: [32]u8,
            ///  DMAMux - DMA request generator status register
            RGSR: mmio.Mmio(packed struct(u32) {
                ///  Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
                OF: u8,
                padding: u24,
            }),
            ///  DMAMux - DMA request generator clear flag register
            RGCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
                COF: u8,
                padding: u24,
            }),
        };

        ///  Cryptographic processor
        pub const CRC = extern struct {
            ///  Data register
            DR: mmio.Mmio(packed struct(u32) {
                ///  Data Register
                DR: u32,
            }),
            ///  Independent Data register
            IDR: mmio.Mmio(packed struct(u32) {
                ///  Independent Data register
                IDR: u32,
            }),
            ///  Control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  RESET bit
                RESET: u1,
                reserved3: u2,
                ///  Polynomial size
                POLYSIZE: u2,
                ///  Reverse input data
                REV_IN: u2,
                ///  Reverse output data
                REV_OUT: u1,
                padding: u24,
            }),
            ///  Initial CRC value
            INIT: mmio.Mmio(packed struct(u32) {
                ///  Programmable initial CRC value
                CRC_INIT: u32,
            }),
            ///  CRC polynomial
            POL: mmio.Mmio(packed struct(u32) {
                ///  Programmable polynomial
                POL: u32,
            }),
        };

        ///  Reset and clock control
        pub const RCC = extern struct {
            ///  clock control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Internal high-speed clock enable
                HSION: u1,
                ///  High Speed Internal clock enable in Stop mode
                HSIKERON: u1,
                ///  HSI clock ready flag
                HSIRDY: u1,
                ///  HSI clock divider
                HSIDIV: u2,
                ///  HSI divider flag
                HSIDIVF: u1,
                reserved7: u1,
                ///  CSI clock enable
                CSION: u1,
                ///  CSI clock ready flag
                CSIRDY: u1,
                ///  CSI clock enable in Stop mode
                CSIKERON: u1,
                reserved12: u2,
                ///  RC48 clock enable
                RC48ON: u1,
                ///  RC48 clock ready flag
                RC48RDY: u1,
                ///  D1 domain clocks ready flag
                D1CKRDY: u1,
                ///  D2 domain clocks ready flag
                D2CKRDY: u1,
                ///  HSE clock enable
                HSEON: u1,
                ///  HSE clock ready flag
                HSERDY: u1,
                ///  HSE clock bypass
                HSEBYP: u1,
                ///  HSE Clock Security System enable
                HSECSSON: u1,
                reserved24: u4,
                ///  PLL1 enable
                PLL1ON: u1,
                ///  PLL1 clock ready flag
                PLL1RDY: u1,
                ///  PLL2 enable
                PLL2ON: u1,
                ///  PLL2 clock ready flag
                PLL2RDY: u1,
                ///  PLL3 enable
                PLL3ON: u1,
                ///  PLL3 clock ready flag
                PLL3RDY: u1,
                padding: u2,
            }),
            ///  RCC Internal Clock Source Calibration Register
            ICSCR: mmio.Mmio(packed struct(u32) {
                ///  HSI clock calibration
                HSICAL: u12,
                ///  HSI clock trimming
                HSITRIM: u6,
                ///  CSI clock calibration
                CSICAL: u8,
                ///  CSI clock trimming
                CSITRIM: u5,
                padding: u1,
            }),
            ///  RCC Clock Recovery RC Register
            CRRCR: mmio.Mmio(packed struct(u32) {
                ///  Internal RC 48 MHz clock calibration
                RC48CAL: u10,
                padding: u22,
            }),
            reserved16: [4]u8,
            ///  RCC Clock Configuration Register
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  System clock switch
                SW: u3,
                ///  System clock switch status
                SWS: u3,
                ///  System clock selection after a wake up from system Stop
                STOPWUCK: u1,
                ///  Kernel clock selection after a wake up from system Stop
                STOPKERWUCK: u1,
                ///  HSE division factor for RTC clock
                RTCPRE: u6,
                ///  High Resolution Timer clock prescaler selection
                HRTIMSEL: u1,
                ///  Timers clocks prescaler selection
                TIMPRE: u1,
                reserved18: u2,
                ///  MCO1 prescaler
                MCO1PRE: u4,
                ///  Micro-controller clock output 1
                MCO1SEL: u3,
                ///  MCO2 prescaler
                MCO2PRE: u4,
                ///  Micro-controller clock output 2
                MCO2SEL: u3,
            }),
            reserved24: [4]u8,
            ///  RCC Domain 1 Clock Configuration Register
            D1CFGR: mmio.Mmio(packed struct(u32) {
                ///  D1 domain AHB prescaler
                HPRE: u4,
                ///  D1 domain APB3 prescaler
                D1PPRE: u3,
                reserved8: u1,
                ///  D1 domain Core prescaler
                D1CPRE: u4,
                padding: u20,
            }),
            ///  RCC Domain 2 Clock Configuration Register
            D2CFGR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  D2 domain APB1 prescaler
                D2PPRE1: u3,
                reserved8: u1,
                ///  D2 domain APB2 prescaler
                D2PPRE2: u3,
                padding: u21,
            }),
            ///  RCC Domain 3 Clock Configuration Register
            D3CFGR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  D3 domain APB4 prescaler
                D3PPRE: u3,
                padding: u25,
            }),
            reserved40: [4]u8,
            ///  RCC PLLs Clock Source Selection Register
            PLLCKSELR: mmio.Mmio(packed struct(u32) {
                ///  DIVMx and PLLs clock source selection
                PLLSRC: u2,
                reserved4: u2,
                ///  Prescaler for PLL1
                DIVM1: u6,
                reserved12: u2,
                ///  Prescaler for PLL2
                DIVM2: u6,
                reserved20: u2,
                ///  Prescaler for PLL3
                DIVM3: u6,
                padding: u6,
            }),
            ///  RCC PLLs Configuration Register
            PLLCFGR: mmio.Mmio(packed struct(u32) {
                ///  PLL1 fractional latch enable
                PLL1FRACEN: u1,
                ///  PLL1 VCO selection
                PLL1VCOSEL: u1,
                ///  PLL1 input frequency range
                PLL1RGE: u2,
                ///  PLL2 fractional latch enable
                PLL2FRACEN: u1,
                ///  PLL2 VCO selection
                PLL2VCOSEL: u1,
                ///  PLL2 input frequency range
                PLL2RGE: u2,
                ///  PLL3 fractional latch enable
                PLL3FRACEN: u1,
                ///  PLL3 VCO selection
                PLL3VCOSEL: u1,
                ///  PLL3 input frequency range
                PLL3RGE: u2,
                reserved16: u4,
                ///  PLL1 DIVP divider output enable
                DIVP1EN: u1,
                ///  PLL1 DIVQ divider output enable
                DIVQ1EN: u1,
                ///  PLL1 DIVR divider output enable
                DIVR1EN: u1,
                ///  PLL2 DIVP divider output enable
                DIVP2EN: u1,
                ///  PLL2 DIVQ divider output enable
                DIVQ2EN: u1,
                ///  PLL2 DIVR divider output enable
                DIVR2EN: u1,
                ///  PLL3 DIVP divider output enable
                DIVP3EN: u1,
                ///  PLL3 DIVQ divider output enable
                DIVQ3EN: u1,
                ///  PLL3 DIVR divider output enable
                DIVR3EN: u1,
                padding: u7,
            }),
            ///  RCC PLL1 Dividers Configuration Register
            PLL1DIVR: mmio.Mmio(packed struct(u32) {
                ///  Multiplication factor for PLL1 VCO
                DIVN1: u9,
                ///  PLL1 DIVP division factor
                DIVP1: u7,
                ///  PLL1 DIVQ division factor
                DIVQ1: u7,
                reserved24: u1,
                ///  PLL1 DIVR division factor
                DIVR1: u7,
                padding: u1,
            }),
            ///  RCC PLL1 Fractional Divider Register
            PLL1FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Fractional part of the multiplication factor for PLL1 VCO
                FRACN1: u13,
                padding: u16,
            }),
            ///  RCC PLL2 Dividers Configuration Register
            PLL2DIVR: mmio.Mmio(packed struct(u32) {
                ///  Multiplication factor for PLL1 VCO
                DIVN1: u9,
                ///  PLL1 DIVP division factor
                DIVP1: u7,
                ///  PLL1 DIVQ division factor
                DIVQ1: u7,
                reserved24: u1,
                ///  PLL1 DIVR division factor
                DIVR1: u7,
                padding: u1,
            }),
            ///  RCC PLL2 Fractional Divider Register
            PLL2FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Fractional part of the multiplication factor for PLL VCO
                FRACN2: u13,
                padding: u16,
            }),
            ///  RCC PLL3 Dividers Configuration Register
            PLL3DIVR: mmio.Mmio(packed struct(u32) {
                ///  Multiplication factor for PLL1 VCO
                DIVN3: u9,
                ///  PLL DIVP division factor
                DIVP3: u7,
                ///  PLL DIVQ division factor
                DIVQ3: u7,
                reserved24: u1,
                ///  PLL DIVR division factor
                DIVR3: u7,
                padding: u1,
            }),
            ///  RCC PLL3 Fractional Divider Register
            PLL3FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Fractional part of the multiplication factor for PLL3 VCO
                FRACN3: u13,
                padding: u16,
            }),
            reserved76: [4]u8,
            ///  RCC Domain 1 Kernel Clock Configuration Register
            D1CCIPR: mmio.Mmio(packed struct(u32) {
                ///  FMC kernel clock source selection
                FMCSRC: u2,
                reserved4: u2,
                ///  QUADSPI kernel clock source selection
                QSPISRC: u2,
                reserved16: u10,
                ///  SDMMC kernel clock source selection
                SDMMCSRC: u1,
                reserved28: u11,
                ///  per_ck clock source selection
                CKPERSRC: u2,
                padding: u2,
            }),
            ///  RCC Domain 2 Kernel Clock Configuration Register
            D2CCIP1R: mmio.Mmio(packed struct(u32) {
                ///  SAI1 and DFSDM1 kernel Aclk clock source selection
                SAI1SRC: u3,
                reserved6: u3,
                ///  SAI2 and SAI3 kernel clock source selection
                SAI23SRC: u3,
                reserved12: u3,
                ///  SPI/I2S1,2 and 3 kernel clock source selection
                SPI123SRC: u3,
                reserved16: u1,
                ///  SPI4 and 5 kernel clock source selection
                SPI45SRC: u3,
                reserved20: u1,
                ///  SPDIFRX kernel clock source selection
                SPDIFSRC: u2,
                reserved24: u2,
                ///  DFSDM1 kernel Clk clock source selection
                DFSDM1SRC: u1,
                reserved28: u3,
                ///  FDCAN kernel clock source selection
                FDCANSRC: u2,
                reserved31: u1,
                ///  SWPMI kernel clock source selection
                SWPSRC: u1,
            }),
            ///  RCC Domain 2 Kernel Clock Configuration Register
            D2CCIP2R: mmio.Mmio(packed struct(u32) {
                ///  USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection
                USART234578SRC: u3,
                ///  USART1 and 6 kernel clock source selection
                USART16SRC: u3,
                reserved8: u2,
                ///  RNG kernel clock source selection
                RNGSRC: u2,
                reserved12: u2,
                ///  I2C1,2,3 kernel clock source selection
                I2C123SRC: u2,
                reserved20: u6,
                ///  USBOTG 1 and 2 kernel clock source selection
                USBSRC: u2,
                ///  HDMI-CEC kernel clock source selection
                CECSRC: u2,
                reserved28: u4,
                ///  LPTIM1 kernel clock source selection
                LPTIM1SRC: u3,
                padding: u1,
            }),
            ///  RCC Domain 3 Kernel Clock Configuration Register
            D3CCIPR: mmio.Mmio(packed struct(u32) {
                ///  LPUART1 kernel clock source selection
                LPUART1SRC: u3,
                reserved8: u5,
                ///  I2C4 kernel clock source selection
                I2C4SRC: u2,
                ///  LPTIM2 kernel clock source selection
                LPTIM2SRC: u3,
                ///  LPTIM3,4,5 kernel clock source selection
                LPTIM345SRC: u3,
                ///  SAR ADC kernel clock source selection
                ADCSRC: u2,
                reserved21: u3,
                ///  Sub-Block A of SAI4 kernel clock source selection
                SAI4ASRC: u3,
                ///  Sub-Block B of SAI4 kernel clock source selection
                SAI4BSRC: u3,
                reserved28: u1,
                ///  SPI6 kernel clock source selection
                SPI6SRC: u3,
                padding: u1,
            }),
            reserved96: [4]u8,
            ///  RCC Clock Source Interrupt Enable Register
            CIER: mmio.Mmio(packed struct(u32) {
                ///  LSI ready Interrupt Enable
                LSIRDYIE: u1,
                ///  LSE ready Interrupt Enable
                LSERDYIE: u1,
                ///  HSI ready Interrupt Enable
                HSIRDYIE: u1,
                ///  HSE ready Interrupt Enable
                HSERDYIE: u1,
                ///  CSI ready Interrupt Enable
                CSIRDYIE: u1,
                ///  RC48 ready Interrupt Enable
                RC48RDYIE: u1,
                ///  PLL1 ready Interrupt Enable
                PLL1RDYIE: u1,
                ///  PLL2 ready Interrupt Enable
                PLL2RDYIE: u1,
                ///  PLL3 ready Interrupt Enable
                PLL3RDYIE: u1,
                ///  LSE clock security system Interrupt Enable
                LSECSSIE: u1,
                padding: u22,
            }),
            ///  RCC Clock Source Interrupt Flag Register
            CIFR: mmio.Mmio(packed struct(u32) {
                ///  LSI ready Interrupt Flag
                LSIRDYF: u1,
                ///  LSE ready Interrupt Flag
                LSERDYF: u1,
                ///  HSI ready Interrupt Flag
                HSIRDYF: u1,
                ///  HSE ready Interrupt Flag
                HSERDYF: u1,
                ///  CSI ready Interrupt Flag
                CSIRDY: u1,
                ///  RC48 ready Interrupt Flag
                RC48RDYF: u1,
                ///  PLL1 ready Interrupt Flag
                PLL1RDYF: u1,
                ///  PLL2 ready Interrupt Flag
                PLL2RDYF: u1,
                ///  PLL3 ready Interrupt Flag
                PLL3RDYF: u1,
                ///  LSE clock security system Interrupt Flag
                LSECSSF: u1,
                ///  HSE clock security system Interrupt Flag
                HSECSSF: u1,
                padding: u21,
            }),
            ///  RCC Clock Source Interrupt Clear Register
            CICR: mmio.Mmio(packed struct(u32) {
                ///  LSI ready Interrupt Clear
                LSIRDYC: u1,
                ///  LSE ready Interrupt Clear
                LSERDYC: u1,
                ///  HSI ready Interrupt Clear
                HSIRDYC: u1,
                ///  HSE ready Interrupt Clear
                HSERDYC: u1,
                ///  CSI ready Interrupt Clear
                HSE_ready_Interrupt_Clear: u1,
                ///  RC48 ready Interrupt Clear
                RC48RDYC: u1,
                ///  PLL1 ready Interrupt Clear
                PLL1RDYC: u1,
                ///  PLL2 ready Interrupt Clear
                PLL2RDYC: u1,
                ///  PLL3 ready Interrupt Clear
                PLL3RDYC: u1,
                ///  LSE clock security system Interrupt Clear
                LSECSSC: u1,
                ///  HSE clock security system Interrupt Clear
                HSECSSC: u1,
                padding: u21,
            }),
            reserved112: [4]u8,
            ///  RCC Backup Domain Control Register
            BDCR: mmio.Mmio(packed struct(u32) {
                ///  LSE oscillator enabled
                LSEON: u1,
                ///  LSE oscillator ready
                LSERDY: u1,
                ///  LSE oscillator bypass
                LSEBYP: u1,
                ///  LSE oscillator driving capability
                LSEDRV: u2,
                ///  LSE clock security system enable
                LSECSSON: u1,
                ///  LSE clock security system failure detection
                LSECSSD: u1,
                reserved8: u1,
                ///  RTC clock source selection
                RTCSRC: u2,
                reserved15: u5,
                ///  RTC clock enable
                RTCEN: u1,
                ///  VSwitch domain software reset
                VSWRST: u1,
                padding: u15,
            }),
            ///  RCC Clock Control and Status Register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  LSI oscillator enable
                LSION: u1,
                ///  LSI oscillator ready
                LSIRDY: u1,
                padding: u30,
            }),
            reserved124: [4]u8,
            ///  RCC AHB3 Reset Register
            AHB3RSTR: mmio.Mmio(packed struct(u32) {
                ///  MDMA block reset
                MDMARST: u1,
                reserved4: u3,
                ///  DMA2D block reset
                DMA2DRST: u1,
                ///  JPGDEC block reset
                JPGDECRST: u1,
                reserved12: u6,
                ///  FMC block reset
                FMCRST: u1,
                reserved14: u1,
                ///  QUADSPI and QUADSPI delay block reset
                QSPIRST: u1,
                reserved16: u1,
                ///  SDMMC1 and SDMMC1 delay block reset
                SDMMC1RST: u1,
                reserved31: u14,
                ///  CPU reset
                CPURST: u1,
            }),
            ///  RCC AHB1 Peripheral Reset Register
            AHB1RSTR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 block reset
                DMA1RST: u1,
                ///  DMA2 block reset
                DMA2RST: u1,
                reserved5: u3,
                ///  ADC1&2 block reset
                ADC12RST: u1,
                reserved15: u9,
                ///  ETH1MAC block reset
                ETH1MACRST: u1,
                reserved25: u9,
                ///  USB1OTG block reset
                USB1OTGRST: u1,
                reserved27: u1,
                ///  USB2OTG block reset
                USB2OTGRST: u1,
                padding: u4,
            }),
            ///  RCC AHB2 Peripheral Reset Register
            AHB2RSTR: mmio.Mmio(packed struct(u32) {
                ///  CAMITF block reset
                CAMITFRST: u1,
                reserved4: u3,
                ///  Cryptography block reset
                CRYPTRST: u1,
                ///  Hash block reset
                HASHRST: u1,
                ///  Random Number Generator block reset
                RNGRST: u1,
                reserved9: u2,
                ///  SDMMC2 and SDMMC2 Delay block reset
                SDMMC2RST: u1,
                padding: u22,
            }),
            ///  RCC AHB4 Peripheral Reset Register
            AHB4RSTR: mmio.Mmio(packed struct(u32) {
                ///  GPIO block reset
                GPIOARST: u1,
                ///  GPIO block reset
                GPIOBRST: u1,
                ///  GPIO block reset
                GPIOCRST: u1,
                ///  GPIO block reset
                GPIODRST: u1,
                ///  GPIO block reset
                GPIOERST: u1,
                ///  GPIO block reset
                GPIOFRST: u1,
                ///  GPIO block reset
                GPIOGRST: u1,
                ///  GPIO block reset
                GPIOHRST: u1,
                ///  GPIO block reset
                GPIOIRST: u1,
                ///  GPIO block reset
                GPIOJRST: u1,
                ///  GPIO block reset
                GPIOKRST: u1,
                reserved19: u8,
                ///  CRC block reset
                CRCRST: u1,
                reserved21: u1,
                ///  BDMA block reset
                BDMARST: u1,
                reserved24: u2,
                ///  ADC3 block reset
                ADC3RST: u1,
                ///  HSEM block reset
                HSEMRST: u1,
                padding: u6,
            }),
            ///  RCC APB3 Peripheral Reset Register
            APB3RSTR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LTDC block reset
                LTDCRST: u1,
                padding: u28,
            }),
            ///  RCC APB1 Peripheral Reset Register
            APB1LRSTR: mmio.Mmio(packed struct(u32) {
                ///  TIM block reset
                TIM2RST: u1,
                ///  TIM block reset
                TIM3RST: u1,
                ///  TIM block reset
                TIM4RST: u1,
                ///  TIM block reset
                TIM5RST: u1,
                ///  TIM block reset
                TIM6RST: u1,
                ///  TIM block reset
                TIM7RST: u1,
                ///  TIM block reset
                TIM12RST: u1,
                ///  TIM block reset
                TIM13RST: u1,
                ///  TIM block reset
                TIM14RST: u1,
                ///  TIM block reset
                LPTIM1RST: u1,
                reserved14: u4,
                ///  SPI2 block reset
                SPI2RST: u1,
                ///  SPI3 block reset
                SPI3RST: u1,
                ///  SPDIFRX block reset
                SPDIFRXRST: u1,
                ///  USART2 block reset
                USART2RST: u1,
                ///  USART3 block reset
                USART3RST: u1,
                ///  UART4 block reset
                UART4RST: u1,
                ///  UART5 block reset
                UART5RST: u1,
                ///  I2C1 block reset
                I2C1RST: u1,
                ///  I2C2 block reset
                I2C2RST: u1,
                ///  I2C3 block reset
                I2C3RST: u1,
                reserved27: u3,
                ///  HDMI-CEC block reset
                CECRST: u1,
                reserved29: u1,
                ///  DAC1 and 2 Blocks Reset
                DAC12RST: u1,
                ///  USART7 block reset
                USART7RST: u1,
                ///  USART8 block reset
                USART8RST: u1,
            }),
            ///  RCC APB1 Peripheral Reset Register
            APB1HRSTR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Clock Recovery System reset
                CRSRST: u1,
                ///  SWPMI block reset
                SWPRST: u1,
                reserved4: u1,
                ///  OPAMP block reset
                OPAMPRST: u1,
                ///  MDIOS block reset
                MDIOSRST: u1,
                reserved8: u2,
                ///  FDCAN block reset
                FDCANRST: u1,
                padding: u23,
            }),
            ///  RCC APB2 Peripheral Reset Register
            APB2RSTR: mmio.Mmio(packed struct(u32) {
                ///  TIM1 block reset
                TIM1RST: u1,
                ///  TIM8 block reset
                TIM8RST: u1,
                reserved4: u2,
                ///  USART1 block reset
                USART1RST: u1,
                ///  USART6 block reset
                USART6RST: u1,
                reserved12: u6,
                ///  SPI1 block reset
                SPI1RST: u1,
                ///  SPI4 block reset
                SPI4RST: u1,
                reserved16: u2,
                ///  TIM15 block reset
                TIM15RST: u1,
                ///  TIM16 block reset
                TIM16RST: u1,
                ///  TIM17 block reset
                TIM17RST: u1,
                reserved20: u1,
                ///  SPI5 block reset
                SPI5RST: u1,
                reserved22: u1,
                ///  SAI1 block reset
                SAI1RST: u1,
                ///  SAI2 block reset
                SAI2RST: u1,
                ///  SAI3 block reset
                SAI3RST: u1,
                reserved28: u3,
                ///  DFSDM1 block reset
                DFSDM1RST: u1,
                ///  HRTIM block reset
                HRTIMRST: u1,
                padding: u2,
            }),
            ///  RCC APB4 Peripheral Reset Register
            APB4RSTR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SYSCFG block reset
                SYSCFGRST: u1,
                reserved3: u1,
                ///  LPUART1 block reset
                LPUART1RST: u1,
                reserved5: u1,
                ///  SPI6 block reset
                SPI6RST: u1,
                reserved7: u1,
                ///  I2C4 block reset
                I2C4RST: u1,
                reserved9: u1,
                ///  LPTIM2 block reset
                LPTIM2RST: u1,
                ///  LPTIM3 block reset
                LPTIM3RST: u1,
                ///  LPTIM4 block reset
                LPTIM4RST: u1,
                ///  LPTIM5 block reset
                LPTIM5RST: u1,
                reserved14: u1,
                ///  COMP12 Blocks Reset
                COMP12RST: u1,
                ///  VREF block reset
                VREFRST: u1,
                reserved21: u5,
                ///  SAI4 block reset
                SAI4RST: u1,
                padding: u10,
            }),
            ///  RCC Global Control Register
            GCR: mmio.Mmio(packed struct(u32) {
                ///  WWDG1 reset scope control
                WW1RSC: u1,
                padding: u31,
            }),
            reserved168: [4]u8,
            ///  RCC D3 Autonomous mode Register
            D3AMR: mmio.Mmio(packed struct(u32) {
                ///  BDMA and DMAMUX Autonomous mode enable
                BDMAAMEN: u1,
                reserved3: u2,
                ///  LPUART1 Autonomous mode enable
                LPUART1AMEN: u1,
                reserved5: u1,
                ///  SPI6 Autonomous mode enable
                SPI6AMEN: u1,
                reserved7: u1,
                ///  I2C4 Autonomous mode enable
                I2C4AMEN: u1,
                reserved9: u1,
                ///  LPTIM2 Autonomous mode enable
                LPTIM2AMEN: u1,
                ///  LPTIM3 Autonomous mode enable
                LPTIM3AMEN: u1,
                ///  LPTIM4 Autonomous mode enable
                LPTIM4AMEN: u1,
                ///  LPTIM5 Autonomous mode enable
                LPTIM5AMEN: u1,
                reserved14: u1,
                ///  COMP12 Autonomous mode enable
                COMP12AMEN: u1,
                ///  VREF Autonomous mode enable
                VREFAMEN: u1,
                ///  RTC Autonomous mode enable
                RTCAMEN: u1,
                reserved19: u2,
                ///  CRC Autonomous mode enable
                CRCAMEN: u1,
                reserved21: u1,
                ///  SAI4 Autonomous mode enable
                SAI4AMEN: u1,
                reserved24: u2,
                ///  ADC3 Autonomous mode enable
                ADC3AMEN: u1,
                reserved28: u3,
                ///  Backup RAM Autonomous mode enable
                BKPRAMAMEN: u1,
                ///  SRAM4 Autonomous mode enable
                SRAM4AMEN: u1,
                padding: u2,
            }),
            reserved208: [36]u8,
            ///  RCC Reset Status Register
            RSR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Remove reset flag
                RMVF: u1,
                ///  CPU reset flag
                CPURSTF: u1,
                reserved19: u1,
                ///  D1 domain power switch reset flag
                D1RSTF: u1,
                ///  D2 domain power switch reset flag
                D2RSTF: u1,
                ///  BOR reset flag
                BORRSTF: u1,
                ///  Pin reset flag (NRST)
                PINRSTF: u1,
                ///  POR/PDR reset flag
                PORRSTF: u1,
                ///  System reset from CPU reset flag
                SFTRSTF: u1,
                reserved26: u1,
                ///  Independent Watchdog reset flag
                IWDG1RSTF: u1,
                reserved28: u1,
                ///  Window Watchdog reset flag
                WWDG1RSTF: u1,
                reserved30: u1,
                ///  Reset due to illegal D1 DStandby or CPU CStop flag
                LPWRRSTF: u1,
                padding: u1,
            }),
            ///  RCC AHB3 Clock Register
            AHB3ENR: mmio.Mmio(packed struct(u32) {
                ///  MDMA Peripheral Clock Enable
                MDMAEN: u1,
                reserved4: u3,
                ///  DMA2D Peripheral Clock Enable
                DMA2DEN: u1,
                ///  JPGDEC Peripheral Clock Enable
                JPGDECEN: u1,
                reserved12: u6,
                ///  FMC Peripheral Clocks Enable
                FMCEN: u1,
                reserved14: u1,
                ///  QUADSPI and QUADSPI Delay Clock Enable
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1 and SDMMC1 Delay Clock Enable
                SDMMC1EN: u1,
                padding: u15,
            }),
            ///  RCC AHB1 Clock Register
            AHB1ENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 Clock Enable
                DMA1EN: u1,
                ///  DMA2 Clock Enable
                DMA2EN: u1,
                reserved5: u3,
                ///  ADC1/2 Peripheral Clocks Enable
                ADC12EN: u1,
                reserved15: u9,
                ///  Ethernet MAC bus interface Clock Enable
                ETH1MACEN: u1,
                ///  Ethernet Transmission Clock Enable
                ETH1TXEN: u1,
                ///  Ethernet Reception Clock Enable
                ETH1RXEN: u1,
                ///  Enable USB_PHY2 clocks
                USB2OTGHSULPIEN: u1,
                reserved25: u6,
                ///  USB1OTG Peripheral Clocks Enable
                USB1OTGEN: u1,
                ///  USB_PHY1 Clocks Enable
                USB1ULPIEN: u1,
                ///  USB2OTG Peripheral Clocks Enable
                USB2OTGEN: u1,
                ///  USB_PHY2 Clocks Enable
                USB2ULPIEN: u1,
                padding: u3,
            }),
            ///  RCC AHB2 Clock Register
            AHB2ENR: mmio.Mmio(packed struct(u32) {
                ///  CAMITF peripheral clock enable
                CAMITFEN: u1,
                reserved4: u3,
                ///  CRYPT peripheral clock enable
                CRYPTEN: u1,
                ///  HASH peripheral clock enable
                HASHEN: u1,
                ///  RNG peripheral clocks enable
                RNGEN: u1,
                reserved9: u2,
                ///  SDMMC2 and SDMMC2 delay clock enable
                SDMMC2EN: u1,
                reserved29: u19,
                ///  SRAM1 block enable
                SRAM1EN: u1,
                ///  SRAM2 block enable
                SRAM2EN: u1,
                ///  SRAM3 block enable
                SRAM3EN: u1,
            }),
            ///  RCC AHB4 Clock Register
            AHB4ENR: mmio.Mmio(packed struct(u32) {
                ///  0GPIO peripheral clock enable
                GPIOAEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOBEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOCEN: u1,
                ///  0GPIO peripheral clock enable
                GPIODEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOEEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOFEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOGEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOHEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOIEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOJEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOKEN: u1,
                reserved19: u8,
                ///  CRC peripheral clock enable
                CRCEN: u1,
                reserved21: u1,
                ///  BDMA and DMAMUX2 Clock Enable
                BDMAEN: u1,
                reserved24: u2,
                ///  ADC3 Peripheral Clocks Enable
                ADC3EN: u1,
                ///  HSEM peripheral clock enable
                HSEMEN: u1,
                reserved28: u2,
                ///  Backup RAM Clock Enable
                BKPRAMEN: u1,
                padding: u3,
            }),
            ///  RCC APB3 Clock Register
            APB3ENR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LTDC peripheral clock enable
                LTDCEN: u1,
                reserved6: u2,
                ///  WWDG1 Clock Enable
                WWDG1EN: u1,
                padding: u25,
            }),
            ///  RCC APB1 Clock Register
            APB1LENR: mmio.Mmio(packed struct(u32) {
                ///  TIM peripheral clock enable
                TIM2EN: u1,
                ///  TIM peripheral clock enable
                TIM3EN: u1,
                ///  TIM peripheral clock enable
                TIM4EN: u1,
                ///  TIM peripheral clock enable
                TIM5EN: u1,
                ///  TIM peripheral clock enable
                TIM6EN: u1,
                ///  TIM peripheral clock enable
                TIM7EN: u1,
                ///  TIM peripheral clock enable
                TIM12EN: u1,
                ///  TIM peripheral clock enable
                TIM13EN: u1,
                ///  TIM peripheral clock enable
                TIM14EN: u1,
                ///  LPTIM1 Peripheral Clocks Enable
                LPTIM1EN: u1,
                reserved14: u4,
                ///  SPI2 Peripheral Clocks Enable
                SPI2EN: u1,
                ///  SPI3 Peripheral Clocks Enable
                SPI3EN: u1,
                ///  SPDIFRX Peripheral Clocks Enable
                SPDIFRXEN: u1,
                ///  USART2 Peripheral Clocks Enable
                USART2EN: u1,
                ///  USART3 Peripheral Clocks Enable
                USART3EN: u1,
                ///  UART4 Peripheral Clocks Enable
                UART4EN: u1,
                ///  UART5 Peripheral Clocks Enable
                UART5EN: u1,
                ///  I2C1 Peripheral Clocks Enable
                I2C1EN: u1,
                ///  I2C2 Peripheral Clocks Enable
                I2C2EN: u1,
                ///  I2C3 Peripheral Clocks Enable
                I2C3EN: u1,
                reserved27: u3,
                ///  HDMI-CEC peripheral clock enable
                CECEN: u1,
                reserved29: u1,
                ///  DAC1&2 peripheral clock enable
                DAC12EN: u1,
                ///  USART7 Peripheral Clocks Enable
                USART7EN: u1,
                ///  USART8 Peripheral Clocks Enable
                USART8EN: u1,
            }),
            ///  RCC APB1 Clock Register
            APB1HENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Clock Recovery System peripheral clock enable
                CRSEN: u1,
                ///  SWPMI Peripheral Clocks Enable
                SWPEN: u1,
                reserved4: u1,
                ///  OPAMP peripheral clock enable
                OPAMPEN: u1,
                ///  MDIOS peripheral clock enable
                MDIOSEN: u1,
                reserved8: u2,
                ///  FDCAN Peripheral Clocks Enable
                FDCANEN: u1,
                padding: u23,
            }),
            ///  RCC APB2 Clock Register
            APB2ENR: mmio.Mmio(packed struct(u32) {
                ///  TIM1 peripheral clock enable
                TIM1EN: u1,
                ///  TIM8 peripheral clock enable
                TIM8EN: u1,
                reserved4: u2,
                ///  USART1 Peripheral Clocks Enable
                USART1EN: u1,
                ///  USART6 Peripheral Clocks Enable
                USART6EN: u1,
                reserved12: u6,
                ///  SPI1 Peripheral Clocks Enable
                SPI1EN: u1,
                ///  SPI4 Peripheral Clocks Enable
                SPI4EN: u1,
                reserved16: u2,
                ///  TIM15 peripheral clock enable
                TIM15EN: u1,
                ///  TIM16 peripheral clock enable
                TIM16EN: u1,
                ///  TIM17 peripheral clock enable
                TIM17EN: u1,
                reserved20: u1,
                ///  SPI5 Peripheral Clocks Enable
                SPI5EN: u1,
                reserved22: u1,
                ///  SAI1 Peripheral Clocks Enable
                SAI1EN: u1,
                ///  SAI2 Peripheral Clocks Enable
                SAI2EN: u1,
                ///  SAI3 Peripheral Clocks Enable
                SAI3EN: u1,
                reserved28: u3,
                ///  DFSDM1 Peripheral Clocks Enable
                DFSDM1EN: u1,
                ///  HRTIM peripheral clock enable
                HRTIMEN: u1,
                padding: u2,
            }),
            ///  RCC APB4 Clock Register
            APB4ENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SYSCFG peripheral clock enable
                SYSCFGEN: u1,
                reserved3: u1,
                ///  LPUART1 Peripheral Clocks Enable
                LPUART1EN: u1,
                reserved5: u1,
                ///  SPI6 Peripheral Clocks Enable
                SPI6EN: u1,
                reserved7: u1,
                ///  I2C4 Peripheral Clocks Enable
                I2C4EN: u1,
                reserved9: u1,
                ///  LPTIM2 Peripheral Clocks Enable
                LPTIM2EN: u1,
                ///  LPTIM3 Peripheral Clocks Enable
                LPTIM3EN: u1,
                ///  LPTIM4 Peripheral Clocks Enable
                LPTIM4EN: u1,
                ///  LPTIM5 Peripheral Clocks Enable
                LPTIM5EN: u1,
                reserved14: u1,
                ///  COMP1/2 peripheral clock enable
                COMP12EN: u1,
                ///  VREF peripheral clock enable
                VREFEN: u1,
                ///  RTC APB Clock Enable
                RTCAPBEN: u1,
                reserved21: u4,
                ///  SAI4 Peripheral Clocks Enable
                SAI4EN: u1,
                padding: u10,
            }),
            reserved252: [4]u8,
            ///  RCC AHB3 Sleep Clock Register
            AHB3LPENR: mmio.Mmio(packed struct(u32) {
                ///  MDMA Clock Enable During CSleep Mode
                MDMALPEN: u1,
                reserved4: u3,
                ///  DMA2D Clock Enable During CSleep Mode
                DMA2DLPEN: u1,
                ///  JPGDEC Clock Enable During CSleep Mode
                JPGDECLPEN: u1,
                reserved8: u2,
                ///  FLITF Clock Enable During CSleep Mode
                FLASHLPEN: u1,
                reserved12: u3,
                ///  FMC Peripheral Clocks Enable During CSleep Mode
                FMCLPEN: u1,
                reserved14: u1,
                ///  QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
                SDMMC1LPEN: u1,
                reserved28: u11,
                ///  D1DTCM1 Block Clock Enable During CSleep mode
                D1DTCM1LPEN: u1,
                ///  D1 DTCM2 Block Clock Enable During CSleep mode
                DTCM2LPEN: u1,
                ///  D1ITCM Block Clock Enable During CSleep mode
                ITCMLPEN: u1,
                ///  AXISRAM Block Clock Enable During CSleep mode
                AXISRAMLPEN: u1,
            }),
            ///  RCC AHB1 Sleep Clock Register
            AHB1LPENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 Clock Enable During CSleep Mode
                DMA1LPEN: u1,
                ///  DMA2 Clock Enable During CSleep Mode
                DMA2LPEN: u1,
                reserved5: u3,
                ///  ADC1/2 Peripheral Clocks Enable During CSleep Mode
                ADC12LPEN: u1,
                reserved15: u9,
                ///  Ethernet MAC bus interface Clock Enable During CSleep Mode
                ETH1MACLPEN: u1,
                ///  Ethernet Transmission Clock Enable During CSleep Mode
                ETH1TXLPEN: u1,
                ///  Ethernet Reception Clock Enable During CSleep Mode
                ETH1RXLPEN: u1,
                reserved25: u7,
                ///  USB1OTG peripheral clock enable during CSleep mode
                USB1OTGHSLPEN: u1,
                ///  USB_PHY1 clock enable during CSleep mode
                USB1OTGHSULPILPEN: u1,
                ///  USB2OTG peripheral clock enable during CSleep mode
                USB2OTGHSLPEN: u1,
                ///  USB_PHY2 clocks enable during CSleep mode
                USB2OTGHSULPILPEN: u1,
                padding: u3,
            }),
            ///  RCC AHB2 Sleep Clock Register
            AHB2LPENR: mmio.Mmio(packed struct(u32) {
                ///  CAMITF peripheral clock enable during CSleep mode
                CAMITFLPEN: u1,
                reserved4: u3,
                ///  CRYPT peripheral clock enable during CSleep mode
                CRYPTLPEN: u1,
                ///  HASH peripheral clock enable during CSleep mode
                HASHLPEN: u1,
                ///  RNG peripheral clock enable during CSleep mode
                RNGLPEN: u1,
                reserved9: u2,
                ///  SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
                SDMMC2LPEN: u1,
                reserved29: u19,
                ///  SRAM1 Clock Enable During CSleep Mode
                SRAM1LPEN: u1,
                ///  SRAM2 Clock Enable During CSleep Mode
                SRAM2LPEN: u1,
                ///  SRAM3 Clock Enable During CSleep Mode
                SRAM3LPEN: u1,
            }),
            ///  RCC AHB4 Sleep Clock Register
            AHB4LPENR: mmio.Mmio(packed struct(u32) {
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOALPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOBLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOCLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIODLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOELPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOFLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOGLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOHLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOILPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOJLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOKLPEN: u1,
                reserved19: u8,
                ///  CRC peripheral clock enable during CSleep mode
                CRCLPEN: u1,
                reserved21: u1,
                ///  BDMA Clock Enable During CSleep Mode
                BDMALPEN: u1,
                reserved24: u2,
                ///  ADC3 Peripheral Clocks Enable During CSleep Mode
                ADC3LPEN: u1,
                reserved28: u3,
                ///  Backup RAM Clock Enable During CSleep Mode
                BKPRAMLPEN: u1,
                ///  SRAM4 Clock Enable During CSleep Mode
                SRAM4LPEN: u1,
                padding: u2,
            }),
            ///  RCC APB3 Sleep Clock Register
            APB3LPENR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LTDC peripheral clock enable during CSleep mode
                LTDCLPEN: u1,
                reserved6: u2,
                ///  WWDG1 Clock Enable During CSleep Mode
                WWDG1LPEN: u1,
                padding: u25,
            }),
            ///  RCC APB1 Low Sleep Clock Register
            APB1LLPENR: mmio.Mmio(packed struct(u32) {
                ///  TIM2 peripheral clock enable during CSleep mode
                TIM2LPEN: u1,
                ///  TIM3 peripheral clock enable during CSleep mode
                TIM3LPEN: u1,
                ///  TIM4 peripheral clock enable during CSleep mode
                TIM4LPEN: u1,
                ///  TIM5 peripheral clock enable during CSleep mode
                TIM5LPEN: u1,
                ///  TIM6 peripheral clock enable during CSleep mode
                TIM6LPEN: u1,
                ///  TIM7 peripheral clock enable during CSleep mode
                TIM7LPEN: u1,
                ///  TIM12 peripheral clock enable during CSleep mode
                TIM12LPEN: u1,
                ///  TIM13 peripheral clock enable during CSleep mode
                TIM13LPEN: u1,
                ///  TIM14 peripheral clock enable during CSleep mode
                TIM14LPEN: u1,
                ///  LPTIM1 Peripheral Clocks Enable During CSleep Mode
                LPTIM1LPEN: u1,
                reserved14: u4,
                ///  SPI2 Peripheral Clocks Enable During CSleep Mode
                SPI2LPEN: u1,
                ///  SPI3 Peripheral Clocks Enable During CSleep Mode
                SPI3LPEN: u1,
                ///  SPDIFRX Peripheral Clocks Enable During CSleep Mode
                SPDIFRXLPEN: u1,
                ///  USART2 Peripheral Clocks Enable During CSleep Mode
                USART2LPEN: u1,
                ///  USART3 Peripheral Clocks Enable During CSleep Mode
                USART3LPEN: u1,
                ///  UART4 Peripheral Clocks Enable During CSleep Mode
                UART4LPEN: u1,
                ///  UART5 Peripheral Clocks Enable During CSleep Mode
                UART5LPEN: u1,
                ///  I2C1 Peripheral Clocks Enable During CSleep Mode
                I2C1LPEN: u1,
                ///  I2C2 Peripheral Clocks Enable During CSleep Mode
                I2C2LPEN: u1,
                ///  I2C3 Peripheral Clocks Enable During CSleep Mode
                I2C3LPEN: u1,
                reserved27: u3,
                ///  HDMI-CEC Peripheral Clocks Enable During CSleep Mode
                HDMICECLPEN: u1,
                reserved29: u1,
                ///  DAC1/2 peripheral clock enable during CSleep mode
                DAC12LPEN: u1,
                ///  USART7 Peripheral Clocks Enable During CSleep Mode
                USART7LPEN: u1,
                ///  USART8 Peripheral Clocks Enable During CSleep Mode
                USART8LPEN: u1,
            }),
            ///  RCC APB1 High Sleep Clock Register
            APB1HLPENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Clock Recovery System peripheral clock enable during CSleep mode
                CRSLPEN: u1,
                ///  SWPMI Peripheral Clocks Enable During CSleep Mode
                SWPLPEN: u1,
                reserved4: u1,
                ///  OPAMP peripheral clock enable during CSleep mode
                OPAMPLPEN: u1,
                ///  MDIOS peripheral clock enable during CSleep mode
                MDIOSLPEN: u1,
                reserved8: u2,
                ///  FDCAN Peripheral Clocks Enable During CSleep Mode
                FDCANLPEN: u1,
                padding: u23,
            }),
            ///  RCC APB2 Sleep Clock Register
            APB2LPENR: mmio.Mmio(packed struct(u32) {
                ///  TIM1 peripheral clock enable during CSleep mode
                TIM1LPEN: u1,
                ///  TIM8 peripheral clock enable during CSleep mode
                TIM8LPEN: u1,
                reserved4: u2,
                ///  USART1 Peripheral Clocks Enable During CSleep Mode
                USART1LPEN: u1,
                ///  USART6 Peripheral Clocks Enable During CSleep Mode
                USART6LPEN: u1,
                reserved12: u6,
                ///  SPI1 Peripheral Clocks Enable During CSleep Mode
                SPI1LPEN: u1,
                ///  SPI4 Peripheral Clocks Enable During CSleep Mode
                SPI4LPEN: u1,
                reserved16: u2,
                ///  TIM15 peripheral clock enable during CSleep mode
                TIM15LPEN: u1,
                ///  TIM16 peripheral clock enable during CSleep mode
                TIM16LPEN: u1,
                ///  TIM17 peripheral clock enable during CSleep mode
                TIM17LPEN: u1,
                reserved20: u1,
                ///  SPI5 Peripheral Clocks Enable During CSleep Mode
                SPI5LPEN: u1,
                reserved22: u1,
                ///  SAI1 Peripheral Clocks Enable During CSleep Mode
                SAI1LPEN: u1,
                ///  SAI2 Peripheral Clocks Enable During CSleep Mode
                SAI2LPEN: u1,
                ///  SAI3 Peripheral Clocks Enable During CSleep Mode
                SAI3LPEN: u1,
                reserved28: u3,
                ///  DFSDM1 Peripheral Clocks Enable During CSleep Mode
                DFSDM1LPEN: u1,
                ///  HRTIM peripheral clock enable during CSleep mode
                HRTIMLPEN: u1,
                padding: u2,
            }),
            ///  RCC APB4 Sleep Clock Register
            APB4LPENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SYSCFG peripheral clock enable during CSleep mode
                SYSCFGLPEN: u1,
                reserved3: u1,
                ///  LPUART1 Peripheral Clocks Enable During CSleep Mode
                LPUART1LPEN: u1,
                reserved5: u1,
                ///  SPI6 Peripheral Clocks Enable During CSleep Mode
                SPI6LPEN: u1,
                reserved7: u1,
                ///  I2C4 Peripheral Clocks Enable During CSleep Mode
                I2C4LPEN: u1,
                reserved9: u1,
                ///  LPTIM2 Peripheral Clocks Enable During CSleep Mode
                LPTIM2LPEN: u1,
                ///  LPTIM3 Peripheral Clocks Enable During CSleep Mode
                LPTIM3LPEN: u1,
                ///  LPTIM4 Peripheral Clocks Enable During CSleep Mode
                LPTIM4LPEN: u1,
                ///  LPTIM5 Peripheral Clocks Enable During CSleep Mode
                LPTIM5LPEN: u1,
                reserved14: u1,
                ///  COMP1/2 peripheral clock enable during CSleep mode
                COMP12LPEN: u1,
                ///  VREF peripheral clock enable during CSleep mode
                VREFLPEN: u1,
                ///  RTC APB Clock Enable During CSleep Mode
                RTCAPBLPEN: u1,
                reserved21: u4,
                ///  SAI4 Peripheral Clocks Enable During CSleep Mode
                SAI4LPEN: u1,
                padding: u10,
            }),
            reserved304: [16]u8,
            ///  RCC Reset Status Register
            C1_RSR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Remove reset flag
                RMVF: u1,
                ///  CPU reset flag
                CPURSTF: u1,
                reserved19: u1,
                ///  D1 domain power switch reset flag
                D1RSTF: u1,
                ///  D2 domain power switch reset flag
                D2RSTF: u1,
                ///  BOR reset flag
                BORRSTF: u1,
                ///  Pin reset flag (NRST)
                PINRSTF: u1,
                ///  POR/PDR reset flag
                PORRSTF: u1,
                ///  System reset from CPU reset flag
                SFTRSTF: u1,
                reserved26: u1,
                ///  Independent Watchdog reset flag
                IWDG1RSTF: u1,
                reserved28: u1,
                ///  Window Watchdog reset flag
                WWDG1RSTF: u1,
                reserved30: u1,
                ///  Reset due to illegal D1 DStandby or CPU CStop flag
                LPWRRSTF: u1,
                padding: u1,
            }),
            ///  RCC AHB3 Clock Register
            C1_AHB3ENR: mmio.Mmio(packed struct(u32) {
                ///  MDMA Peripheral Clock Enable
                MDMAEN: u1,
                reserved4: u3,
                ///  DMA2D Peripheral Clock Enable
                DMA2DEN: u1,
                ///  JPGDEC Peripheral Clock Enable
                JPGDECEN: u1,
                reserved12: u6,
                ///  FMC Peripheral Clocks Enable
                FMCEN: u1,
                reserved14: u1,
                ///  QUADSPI and QUADSPI Delay Clock Enable
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1 and SDMMC1 Delay Clock Enable
                SDMMC1EN: u1,
                padding: u15,
            }),
            ///  RCC AHB1 Clock Register
            C1_AHB1ENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 Clock Enable
                DMA1EN: u1,
                ///  DMA2 Clock Enable
                DMA2EN: u1,
                reserved5: u3,
                ///  ADC1/2 Peripheral Clocks Enable
                ADC12EN: u1,
                reserved15: u9,
                ///  Ethernet MAC bus interface Clock Enable
                ETH1MACEN: u1,
                ///  Ethernet Transmission Clock Enable
                ETH1TXEN: u1,
                ///  Ethernet Reception Clock Enable
                ETH1RXEN: u1,
                reserved25: u7,
                ///  USB1OTG Peripheral Clocks Enable
                USB1OTGEN: u1,
                ///  USB_PHY1 Clocks Enable
                USB1ULPIEN: u1,
                ///  USB2OTG Peripheral Clocks Enable
                USB2OTGEN: u1,
                ///  USB_PHY2 Clocks Enable
                USB2ULPIEN: u1,
                padding: u3,
            }),
            ///  RCC AHB2 Clock Register
            C1_AHB2ENR: mmio.Mmio(packed struct(u32) {
                ///  CAMITF peripheral clock enable
                CAMITFEN: u1,
                reserved4: u3,
                ///  CRYPT peripheral clock enable
                CRYPTEN: u1,
                ///  HASH peripheral clock enable
                HASHEN: u1,
                ///  RNG peripheral clocks enable
                RNGEN: u1,
                reserved9: u2,
                ///  SDMMC2 and SDMMC2 delay clock enable
                SDMMC2EN: u1,
                reserved29: u19,
                ///  SRAM1 block enable
                SRAM1EN: u1,
                ///  SRAM2 block enable
                SRAM2EN: u1,
                ///  SRAM3 block enable
                SRAM3EN: u1,
            }),
            ///  RCC AHB4 Clock Register
            C1_AHB4ENR: mmio.Mmio(packed struct(u32) {
                ///  0GPIO peripheral clock enable
                GPIOAEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOBEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOCEN: u1,
                ///  0GPIO peripheral clock enable
                GPIODEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOEEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOFEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOGEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOHEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOIEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOJEN: u1,
                ///  0GPIO peripheral clock enable
                GPIOKEN: u1,
                reserved19: u8,
                ///  CRC peripheral clock enable
                CRCEN: u1,
                reserved21: u1,
                ///  BDMA and DMAMUX2 Clock Enable
                BDMAEN: u1,
                reserved24: u2,
                ///  ADC3 Peripheral Clocks Enable
                ADC3EN: u1,
                ///  HSEM peripheral clock enable
                HSEMEN: u1,
                reserved28: u2,
                ///  Backup RAM Clock Enable
                BKPRAMEN: u1,
                padding: u3,
            }),
            ///  RCC APB3 Clock Register
            C1_APB3ENR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LTDC peripheral clock enable
                LTDCEN: u1,
                reserved6: u2,
                ///  WWDG1 Clock Enable
                WWDG1EN: u1,
                padding: u25,
            }),
            ///  RCC APB1 Clock Register
            C1_APB1LENR: mmio.Mmio(packed struct(u32) {
                ///  TIM peripheral clock enable
                TIM2EN: u1,
                ///  TIM peripheral clock enable
                TIM3EN: u1,
                ///  TIM peripheral clock enable
                TIM4EN: u1,
                ///  TIM peripheral clock enable
                TIM5EN: u1,
                ///  TIM peripheral clock enable
                TIM6EN: u1,
                ///  TIM peripheral clock enable
                TIM7EN: u1,
                ///  TIM peripheral clock enable
                TIM12EN: u1,
                ///  TIM peripheral clock enable
                TIM13EN: u1,
                ///  TIM peripheral clock enable
                TIM14EN: u1,
                ///  LPTIM1 Peripheral Clocks Enable
                LPTIM1EN: u1,
                reserved14: u4,
                ///  SPI2 Peripheral Clocks Enable
                SPI2EN: u1,
                ///  SPI3 Peripheral Clocks Enable
                SPI3EN: u1,
                ///  SPDIFRX Peripheral Clocks Enable
                SPDIFRXEN: u1,
                ///  USART2 Peripheral Clocks Enable
                USART2EN: u1,
                ///  USART3 Peripheral Clocks Enable
                USART3EN: u1,
                ///  UART4 Peripheral Clocks Enable
                UART4EN: u1,
                ///  UART5 Peripheral Clocks Enable
                UART5EN: u1,
                ///  I2C1 Peripheral Clocks Enable
                I2C1EN: u1,
                ///  I2C2 Peripheral Clocks Enable
                I2C2EN: u1,
                ///  I2C3 Peripheral Clocks Enable
                I2C3EN: u1,
                reserved27: u3,
                ///  HDMI-CEC peripheral clock enable
                HDMICECEN: u1,
                reserved29: u1,
                ///  DAC1&2 peripheral clock enable
                DAC12EN: u1,
                ///  USART7 Peripheral Clocks Enable
                USART7EN: u1,
                ///  USART8 Peripheral Clocks Enable
                USART8EN: u1,
            }),
            ///  RCC APB1 Clock Register
            C1_APB1HENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Clock Recovery System peripheral clock enable
                CRSEN: u1,
                ///  SWPMI Peripheral Clocks Enable
                SWPEN: u1,
                reserved4: u1,
                ///  OPAMP peripheral clock enable
                OPAMPEN: u1,
                ///  MDIOS peripheral clock enable
                MDIOSEN: u1,
                reserved8: u2,
                ///  FDCAN Peripheral Clocks Enable
                FDCANEN: u1,
                padding: u23,
            }),
            ///  RCC APB2 Clock Register
            C1_APB2ENR: mmio.Mmio(packed struct(u32) {
                ///  TIM1 peripheral clock enable
                TIM1EN: u1,
                ///  TIM8 peripheral clock enable
                TIM8EN: u1,
                reserved4: u2,
                ///  USART1 Peripheral Clocks Enable
                USART1EN: u1,
                ///  USART6 Peripheral Clocks Enable
                USART6EN: u1,
                reserved12: u6,
                ///  SPI1 Peripheral Clocks Enable
                SPI1EN: u1,
                ///  SPI4 Peripheral Clocks Enable
                SPI4EN: u1,
                reserved16: u2,
                ///  TIM15 peripheral clock enable
                TIM15EN: u1,
                ///  TIM16 peripheral clock enable
                TIM16EN: u1,
                ///  TIM17 peripheral clock enable
                TIM17EN: u1,
                reserved20: u1,
                ///  SPI5 Peripheral Clocks Enable
                SPI5EN: u1,
                reserved22: u1,
                ///  SAI1 Peripheral Clocks Enable
                SAI1EN: u1,
                ///  SAI2 Peripheral Clocks Enable
                SAI2EN: u1,
                ///  SAI3 Peripheral Clocks Enable
                SAI3EN: u1,
                reserved28: u3,
                ///  DFSDM1 Peripheral Clocks Enable
                DFSDM1EN: u1,
                ///  HRTIM peripheral clock enable
                HRTIMEN: u1,
                padding: u2,
            }),
            ///  RCC APB4 Clock Register
            C1_APB4ENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SYSCFG peripheral clock enable
                SYSCFGEN: u1,
                reserved3: u1,
                ///  LPUART1 Peripheral Clocks Enable
                LPUART1EN: u1,
                reserved5: u1,
                ///  SPI6 Peripheral Clocks Enable
                SPI6EN: u1,
                reserved7: u1,
                ///  I2C4 Peripheral Clocks Enable
                I2C4EN: u1,
                reserved9: u1,
                ///  LPTIM2 Peripheral Clocks Enable
                LPTIM2EN: u1,
                ///  LPTIM3 Peripheral Clocks Enable
                LPTIM3EN: u1,
                ///  LPTIM4 Peripheral Clocks Enable
                LPTIM4EN: u1,
                ///  LPTIM5 Peripheral Clocks Enable
                LPTIM5EN: u1,
                reserved14: u1,
                ///  COMP1/2 peripheral clock enable
                COMP12EN: u1,
                ///  VREF peripheral clock enable
                VREFEN: u1,
                ///  RTC APB Clock Enable
                RTCAPBEN: u1,
                reserved21: u4,
                ///  SAI4 Peripheral Clocks Enable
                SAI4EN: u1,
                padding: u10,
            }),
            reserved348: [4]u8,
            ///  RCC AHB3 Sleep Clock Register
            C1_AHB3LPENR: mmio.Mmio(packed struct(u32) {
                ///  MDMA Clock Enable During CSleep Mode
                MDMALPEN: u1,
                reserved4: u3,
                ///  DMA2D Clock Enable During CSleep Mode
                DMA2DLPEN: u1,
                ///  JPGDEC Clock Enable During CSleep Mode
                JPGDECLPEN: u1,
                reserved8: u2,
                ///  FLITF Clock Enable During CSleep Mode
                FLITFLPEN: u1,
                reserved12: u3,
                ///  FMC Peripheral Clocks Enable During CSleep Mode
                FMCLPEN: u1,
                reserved14: u1,
                ///  QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
                SDMMC1LPEN: u1,
                reserved28: u11,
                ///  D1DTCM1 Block Clock Enable During CSleep mode
                D1DTCM1LPEN: u1,
                ///  D1 DTCM2 Block Clock Enable During CSleep mode
                DTCM2LPEN: u1,
                ///  D1ITCM Block Clock Enable During CSleep mode
                ITCMLPEN: u1,
                ///  AXISRAM Block Clock Enable During CSleep mode
                AXISRAMLPEN: u1,
            }),
            ///  RCC AHB1 Sleep Clock Register
            C1_AHB1LPENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 Clock Enable During CSleep Mode
                DMA1LPEN: u1,
                ///  DMA2 Clock Enable During CSleep Mode
                DMA2LPEN: u1,
                reserved5: u3,
                ///  ADC1/2 Peripheral Clocks Enable During CSleep Mode
                ADC12LPEN: u1,
                reserved15: u9,
                ///  Ethernet MAC bus interface Clock Enable During CSleep Mode
                ETH1MACLPEN: u1,
                ///  Ethernet Transmission Clock Enable During CSleep Mode
                ETH1TXLPEN: u1,
                ///  Ethernet Reception Clock Enable During CSleep Mode
                ETH1RXLPEN: u1,
                reserved25: u7,
                ///  USB1OTG peripheral clock enable during CSleep mode
                USB1OTGLPEN: u1,
                ///  USB_PHY1 clock enable during CSleep mode
                USB1ULPILPEN: u1,
                ///  USB2OTG peripheral clock enable during CSleep mode
                USB2OTGLPEN: u1,
                ///  USB_PHY2 clocks enable during CSleep mode
                USB2ULPILPEN: u1,
                padding: u3,
            }),
            ///  RCC AHB2 Sleep Clock Register
            C1_AHB2LPENR: mmio.Mmio(packed struct(u32) {
                ///  CAMITF peripheral clock enable during CSleep mode
                CAMITFLPEN: u1,
                reserved4: u3,
                ///  CRYPT peripheral clock enable during CSleep mode
                CRYPTLPEN: u1,
                ///  HASH peripheral clock enable during CSleep mode
                HASHLPEN: u1,
                ///  RNG peripheral clock enable during CSleep mode
                RNGLPEN: u1,
                reserved9: u2,
                ///  SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
                SDMMC2LPEN: u1,
                reserved29: u19,
                ///  SRAM1 Clock Enable During CSleep Mode
                SRAM1LPEN: u1,
                ///  SRAM2 Clock Enable During CSleep Mode
                SRAM2LPEN: u1,
                ///  SRAM3 Clock Enable During CSleep Mode
                SRAM3LPEN: u1,
            }),
            ///  RCC AHB4 Sleep Clock Register
            C1_AHB4LPENR: mmio.Mmio(packed struct(u32) {
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOALPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOBLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOCLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIODLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOELPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOFLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOGLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOHLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOILPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOJLPEN: u1,
                ///  GPIO peripheral clock enable during CSleep mode
                GPIOKLPEN: u1,
                reserved19: u8,
                ///  CRC peripheral clock enable during CSleep mode
                CRCLPEN: u1,
                reserved21: u1,
                ///  BDMA Clock Enable During CSleep Mode
                BDMALPEN: u1,
                reserved24: u2,
                ///  ADC3 Peripheral Clocks Enable During CSleep Mode
                ADC3LPEN: u1,
                reserved28: u3,
                ///  Backup RAM Clock Enable During CSleep Mode
                BKPRAMLPEN: u1,
                ///  SRAM4 Clock Enable During CSleep Mode
                SRAM4LPEN: u1,
                padding: u2,
            }),
            ///  RCC APB3 Sleep Clock Register
            C1_APB3LPENR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LTDC peripheral clock enable during CSleep mode
                LTDCLPEN: u1,
                reserved6: u2,
                ///  WWDG1 Clock Enable During CSleep Mode
                WWDG1LPEN: u1,
                padding: u25,
            }),
            ///  RCC APB1 Low Sleep Clock Register
            C1_APB1LLPENR: mmio.Mmio(packed struct(u32) {
                ///  TIM2 peripheral clock enable during CSleep mode
                TIM2LPEN: u1,
                ///  TIM3 peripheral clock enable during CSleep mode
                TIM3LPEN: u1,
                ///  TIM4 peripheral clock enable during CSleep mode
                TIM4LPEN: u1,
                ///  TIM5 peripheral clock enable during CSleep mode
                TIM5LPEN: u1,
                ///  TIM6 peripheral clock enable during CSleep mode
                TIM6LPEN: u1,
                ///  TIM7 peripheral clock enable during CSleep mode
                TIM7LPEN: u1,
                ///  TIM12 peripheral clock enable during CSleep mode
                TIM12LPEN: u1,
                ///  TIM13 peripheral clock enable during CSleep mode
                TIM13LPEN: u1,
                ///  TIM14 peripheral clock enable during CSleep mode
                TIM14LPEN: u1,
                ///  LPTIM1 Peripheral Clocks Enable During CSleep Mode
                LPTIM1LPEN: u1,
                reserved14: u4,
                ///  SPI2 Peripheral Clocks Enable During CSleep Mode
                SPI2LPEN: u1,
                ///  SPI3 Peripheral Clocks Enable During CSleep Mode
                SPI3LPEN: u1,
                ///  SPDIFRX Peripheral Clocks Enable During CSleep Mode
                SPDIFRXLPEN: u1,
                ///  USART2 Peripheral Clocks Enable During CSleep Mode
                USART2LPEN: u1,
                ///  USART3 Peripheral Clocks Enable During CSleep Mode
                USART3LPEN: u1,
                ///  UART4 Peripheral Clocks Enable During CSleep Mode
                UART4LPEN: u1,
                ///  UART5 Peripheral Clocks Enable During CSleep Mode
                UART5LPEN: u1,
                ///  I2C1 Peripheral Clocks Enable During CSleep Mode
                I2C1LPEN: u1,
                ///  I2C2 Peripheral Clocks Enable During CSleep Mode
                I2C2LPEN: u1,
                ///  I2C3 Peripheral Clocks Enable During CSleep Mode
                I2C3LPEN: u1,
                reserved27: u3,
                ///  HDMI-CEC Peripheral Clocks Enable During CSleep Mode
                HDMICECLPEN: u1,
                reserved29: u1,
                ///  DAC1/2 peripheral clock enable during CSleep mode
                DAC12LPEN: u1,
                ///  USART7 Peripheral Clocks Enable During CSleep Mode
                USART7LPEN: u1,
                ///  USART8 Peripheral Clocks Enable During CSleep Mode
                USART8LPEN: u1,
            }),
            ///  RCC APB1 High Sleep Clock Register
            C1_APB1HLPENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Clock Recovery System peripheral clock enable during CSleep mode
                CRSLPEN: u1,
                ///  SWPMI Peripheral Clocks Enable During CSleep Mode
                SWPLPEN: u1,
                reserved4: u1,
                ///  OPAMP peripheral clock enable during CSleep mode
                OPAMPLPEN: u1,
                ///  MDIOS peripheral clock enable during CSleep mode
                MDIOSLPEN: u1,
                reserved8: u2,
                ///  FDCAN Peripheral Clocks Enable During CSleep Mode
                FDCANLPEN: u1,
                padding: u23,
            }),
            ///  RCC APB2 Sleep Clock Register
            C1_APB2LPENR: mmio.Mmio(packed struct(u32) {
                ///  TIM1 peripheral clock enable during CSleep mode
                TIM1LPEN: u1,
                ///  TIM8 peripheral clock enable during CSleep mode
                TIM8LPEN: u1,
                reserved4: u2,
                ///  USART1 Peripheral Clocks Enable During CSleep Mode
                USART1LPEN: u1,
                ///  USART6 Peripheral Clocks Enable During CSleep Mode
                USART6LPEN: u1,
                reserved12: u6,
                ///  SPI1 Peripheral Clocks Enable During CSleep Mode
                SPI1LPEN: u1,
                ///  SPI4 Peripheral Clocks Enable During CSleep Mode
                SPI4LPEN: u1,
                reserved16: u2,
                ///  TIM15 peripheral clock enable during CSleep mode
                TIM15LPEN: u1,
                ///  TIM16 peripheral clock enable during CSleep mode
                TIM16LPEN: u1,
                ///  TIM17 peripheral clock enable during CSleep mode
                TIM17LPEN: u1,
                reserved20: u1,
                ///  SPI5 Peripheral Clocks Enable During CSleep Mode
                SPI5LPEN: u1,
                reserved22: u1,
                ///  SAI1 Peripheral Clocks Enable During CSleep Mode
                SAI1LPEN: u1,
                ///  SAI2 Peripheral Clocks Enable During CSleep Mode
                SAI2LPEN: u1,
                ///  SAI3 Peripheral Clocks Enable During CSleep Mode
                SAI3LPEN: u1,
                reserved28: u3,
                ///  DFSDM1 Peripheral Clocks Enable During CSleep Mode
                DFSDM1LPEN: u1,
                ///  HRTIM peripheral clock enable during CSleep mode
                HRTIMLPEN: u1,
                padding: u2,
            }),
            ///  RCC APB4 Sleep Clock Register
            C1_APB4LPENR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SYSCFG peripheral clock enable during CSleep mode
                SYSCFGLPEN: u1,
                reserved3: u1,
                ///  LPUART1 Peripheral Clocks Enable During CSleep Mode
                LPUART1LPEN: u1,
                reserved5: u1,
                ///  SPI6 Peripheral Clocks Enable During CSleep Mode
                SPI6LPEN: u1,
                reserved7: u1,
                ///  I2C4 Peripheral Clocks Enable During CSleep Mode
                I2C4LPEN: u1,
                reserved9: u1,
                ///  LPTIM2 Peripheral Clocks Enable During CSleep Mode
                LPTIM2LPEN: u1,
                ///  LPTIM3 Peripheral Clocks Enable During CSleep Mode
                LPTIM3LPEN: u1,
                ///  LPTIM4 Peripheral Clocks Enable During CSleep Mode
                LPTIM4LPEN: u1,
                ///  LPTIM5 Peripheral Clocks Enable During CSleep Mode
                LPTIM5LPEN: u1,
                reserved14: u1,
                ///  COMP1/2 peripheral clock enable during CSleep mode
                COMP12LPEN: u1,
                ///  VREF peripheral clock enable during CSleep mode
                VREFLPEN: u1,
                ///  RTC APB Clock Enable During CSleep Mode
                RTCAPBLPEN: u1,
                reserved21: u4,
                ///  SAI4 Peripheral Clocks Enable During CSleep Mode
                SAI4LPEN: u1,
                padding: u10,
            }),
        };

        ///  Low power timer
        pub const LPTIM1 = extern struct {
            ///  Interrupt and Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Compare match
                CMPM: u1,
                ///  Autoreload match
                ARRM: u1,
                ///  External trigger edge event
                EXTTRIG: u1,
                ///  Compare register update OK
                CMPOK: u1,
                ///  Autoreload register update OK
                ARROK: u1,
                ///  Counter direction change down to up
                UP: u1,
                ///  Counter direction change up to down
                DOWN: u1,
                padding: u25,
            }),
            ///  Interrupt Clear Register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  compare match Clear Flag
                CMPMCF: u1,
                ///  Autoreload match Clear Flag
                ARRMCF: u1,
                ///  External trigger valid edge Clear Flag
                EXTTRIGCF: u1,
                ///  Compare register update OK Clear Flag
                CMPOKCF: u1,
                ///  Autoreload register update OK Clear Flag
                ARROKCF: u1,
                ///  Direction change to UP Clear Flag
                UPCF: u1,
                ///  Direction change to down Clear Flag
                DOWNCF: u1,
                padding: u25,
            }),
            ///  Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Compare match Interrupt Enable
                CMPMIE: u1,
                ///  Autoreload match Interrupt Enable
                ARRMIE: u1,
                ///  External trigger valid edge Interrupt Enable
                EXTTRIGIE: u1,
                ///  Compare register update OK Interrupt Enable
                CMPOKIE: u1,
                ///  Autoreload register update OK Interrupt Enable
                ARROKIE: u1,
                ///  Direction change to UP Interrupt Enable
                UPIE: u1,
                ///  Direction change to down Interrupt Enable
                DOWNIE: u1,
                padding: u25,
            }),
            ///  Configuration Register
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  Clock selector
                CKSEL: u1,
                ///  Clock Polarity
                CKPOL: u2,
                ///  Configurable digital filter for external clock
                CKFLT: u2,
                reserved6: u1,
                ///  Configurable digital filter for trigger
                TRGFLT: u2,
                reserved9: u1,
                ///  Clock prescaler
                PRESC: u3,
                reserved13: u1,
                ///  Trigger selector
                TRIGSEL: u3,
                reserved17: u1,
                ///  Trigger enable and polarity
                TRIGEN: u2,
                ///  Timeout enable
                TIMOUT: u1,
                ///  Waveform shape
                WAVE: u1,
                ///  Waveform shape polarity
                WAVPOL: u1,
                ///  Registers update mode
                PRELOAD: u1,
                ///  counter mode enabled
                COUNTMODE: u1,
                ///  Encoder mode enable
                ENC: u1,
                padding: u7,
            }),
            ///  Control Register
            CR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM Enable
                ENABLE: u1,
                ///  LPTIM start in single mode
                SNGSTRT: u1,
                ///  Timer start in continuous mode
                CNTSTRT: u1,
                ///  Counter reset
                COUNTRST: u1,
                ///  Reset after read enable
                RSTARE: u1,
                padding: u27,
            }),
            ///  Compare Register
            CMP: mmio.Mmio(packed struct(u32) {
                ///  Compare value
                CMP: u16,
                padding: u16,
            }),
            ///  Autoreload Register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto reload value
                ARR: u16,
                padding: u16,
            }),
            ///  Counter Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            CFGR2: mmio.Mmio(packed struct(u32) {
                ///  LPTIM Input 1 selection
                IN1SEL: u2,
                reserved4: u2,
                ///  LPTIM Input 2 selection
                IN2SEL: u2,
                padding: u26,
            }),
        };

        ///  High Resolution Timer: TIMC
        pub const HRTIM_TIMC = extern struct {
            ///  Timerx Control Register
            TIMCCR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Timer x Clock prescaler
                CK_PSCx: u3,
                ///  Continuous mode
                CONT: u1,
                ///  Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                ///  Push-Pull mode enable
                PSHPLL: u1,
                reserved10: u3,
                ///  Synchronization Resets Timer x
                SYNCRSTx: u1,
                ///  Synchronization Starts Timer x
                SYNCSTRTx: u1,
                ///  Delayed CMP2 mode
                DELCMP2: u2,
                ///  Delayed CMP4 mode
                DELCMP4: u2,
                reserved17: u1,
                ///  Timer x Repetition update
                TxREPU: u1,
                ///  Timerx reset update
                TxRSTU: u1,
                reserved20: u1,
                ///  TBU
                TBU: u1,
                ///  TCU
                TCU: u1,
                ///  TDU
                TDU: u1,
                ///  TEU
                TEU: u1,
                ///  Master Timer update
                MSTU: u1,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                ///  Update Gating
                UPDGAT: u4,
            }),
            ///  Timerx Interrupt Status Register
            TIMCISR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt Flag
                CMP1: u1,
                ///  Compare 2 Interrupt Flag
                CMP2: u1,
                ///  Compare 3 Interrupt Flag
                CMP3: u1,
                ///  Compare 4 Interrupt Flag
                CMP4: u1,
                ///  Repetition Interrupt Flag
                REP: u1,
                reserved6: u1,
                ///  Update Interrupt Flag
                UPD: u1,
                ///  Capture1 Interrupt Flag
                CPT1: u1,
                ///  Capture2 Interrupt Flag
                CPT2: u1,
                ///  Output 1 Set Interrupt Flag
                SETx1: u1,
                ///  Output 1 Reset Interrupt Flag
                RSTx1: u1,
                ///  Output 2 Set Interrupt Flag
                SETx2: u1,
                ///  Output 2 Reset Interrupt Flag
                RSTx2: u1,
                ///  Reset Interrupt Flag
                RST: u1,
                ///  Delayed Protection Flag
                DLYPRT: u1,
                reserved16: u1,
                ///  Current Push Pull Status
                CPPSTAT: u1,
                ///  Idle Push Pull Status
                IPPSTAT: u1,
                ///  Output 1 State
                O1STAT: u1,
                ///  Output 2 State
                O2STAT: u1,
                padding: u12,
            }),
            ///  Timerx Interrupt Clear Register
            TIMCICR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt flag Clear
                CMP1C: u1,
                ///  Compare 2 Interrupt flag Clear
                CMP2C: u1,
                ///  Compare 3 Interrupt flag Clear
                CMP3C: u1,
                ///  Compare 4 Interrupt flag Clear
                CMP4C: u1,
                ///  Repetition Interrupt flag Clear
                REPC: u1,
                reserved6: u1,
                ///  Update Interrupt flag Clear
                UPDC: u1,
                ///  Capture1 Interrupt flag Clear
                CPT1C: u1,
                ///  Capture2 Interrupt flag Clear
                CPT2C: u1,
                ///  Output 1 Set flag Clear
                SET1xC: u1,
                ///  Output 1 Reset flag Clear
                RSTx1C: u1,
                ///  Output 2 Set flag Clear
                SET2xC: u1,
                ///  Output 2 Reset flag Clear
                RSTx2C: u1,
                ///  Reset Interrupt flag Clear
                RSTC: u1,
                ///  Delayed Protection Flag Clear
                DLYPRTC: u1,
                padding: u17,
            }),
            ///  TIMxDIER5
            TIMCDIER5: mmio.Mmio(packed struct(u32) {
                ///  CMP1IE
                CMP1IE: u1,
                ///  CMP2IE
                CMP2IE: u1,
                ///  CMP3IE
                CMP3IE: u1,
                ///  CMP4IE
                CMP4IE: u1,
                ///  REPIE
                REPIE: u1,
                reserved6: u1,
                ///  UPDIE
                UPDIE: u1,
                ///  CPT1IE
                CPT1IE: u1,
                ///  CPT2IE
                CPT2IE: u1,
                ///  SET1xIE
                SET1xIE: u1,
                ///  RSTx1IE
                RSTx1IE: u1,
                ///  SETx2IE
                SETx2IE: u1,
                ///  RSTx2IE
                RSTx2IE: u1,
                ///  RSTIE
                RSTIE: u1,
                ///  DLYPRTIE
                DLYPRTIE: u1,
                reserved16: u1,
                ///  CMP1DE
                CMP1DE: u1,
                ///  CMP2DE
                CMP2DE: u1,
                ///  CMP3DE
                CMP3DE: u1,
                ///  CMP4DE
                CMP4DE: u1,
                ///  REPDE
                REPDE: u1,
                reserved22: u1,
                ///  UPDDE
                UPDDE: u1,
                ///  CPT1DE
                CPT1DE: u1,
                ///  CPT2DE
                CPT2DE: u1,
                ///  SET1xDE
                SET1xDE: u1,
                ///  RSTx1DE
                RSTx1DE: u1,
                ///  SETx2DE
                SETx2DE: u1,
                ///  RSTx2DE
                RSTx2DE: u1,
                ///  RSTDE
                RSTDE: u1,
                ///  DLYPRTDE
                DLYPRTDE: u1,
                padding: u1,
            }),
            ///  Timerx Counter Register
            CNTCR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Counter value
                CNTx: u16,
                padding: u16,
            }),
            ///  Timerx Period Register
            PERCR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Period value
                PERx: u16,
                padding: u16,
            }),
            ///  Timerx Repetition Register
            REPCR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Repetition counter value
                REPx: u8,
                padding: u24,
            }),
            ///  Timerx Compare 1 Register
            CMP1CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 1 Compound Register
            CMP1CCR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                ///  Timerx Repetition value (aliased from HRTIM_REPx register)
                REPx: u8,
                padding: u8,
            }),
            ///  Timerx Compare 2 Register
            CMP2CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 2 value
                CMP2x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 3 Register
            CMP3CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 3 value
                CMP3x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 4 Register
            CMP4CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 4 value
                CMP4x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 1 Register
            CPT1CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 1 value
                CPT1x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 2 Register
            CPT2CR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 2 value
                CPT2x: u16,
                padding: u16,
            }),
            ///  Timerx Deadtime Register
            DTCR: mmio.Mmio(packed struct(u32) {
                ///  Deadtime Rising value
                DTRx: u9,
                ///  Sign Deadtime Rising value
                SDTRx: u1,
                ///  Deadtime Prescaler
                DTPRSC: u3,
                reserved14: u1,
                ///  Deadtime Rising Sign Lock
                DTRSLKx: u1,
                ///  Deadtime Rising Lock
                DTRLKx: u1,
                ///  Deadtime Falling value
                DTFx: u9,
                ///  Sign Deadtime Falling value
                SDTFx: u1,
                reserved30: u4,
                ///  Deadtime Falling Sign Lock
                DTFSLKx: u1,
                ///  Deadtime Falling Lock
                DTFLKx: u1,
            }),
            ///  Timerx Output1 Set Register
            SETC1R: mmio.Mmio(packed struct(u32) {
                ///  Software Set trigger
                SST: u1,
                ///  Timer A resynchronizaton
                RESYNC: u1,
                ///  Timer A Period
                PER: u1,
                ///  Timer A compare 1
                CMP1: u1,
                ///  Timer A compare 2
                CMP2: u1,
                ///  Timer A compare 3
                CMP3: u1,
                ///  Timer A compare 4
                CMP4: u1,
                ///  Master Period
                MSTPER: u1,
                ///  Master Compare 1
                MSTCMP1: u1,
                ///  Master Compare 2
                MSTCMP2: u1,
                ///  Master Compare 3
                MSTCMP3: u1,
                ///  Master Compare 4
                MSTCMP4: u1,
                ///  Timer Event 1
                TIMEVNT1: u1,
                ///  Timer Event 2
                TIMEVNT2: u1,
                ///  Timer Event 3
                TIMEVNT3: u1,
                ///  Timer Event 4
                TIMEVNT4: u1,
                ///  Timer Event 5
                TIMEVNT5: u1,
                ///  Timer Event 6
                TIMEVNT6: u1,
                ///  Timer Event 7
                TIMEVNT7: u1,
                ///  Timer Event 8
                TIMEVNT8: u1,
                ///  Timer Event 9
                TIMEVNT9: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Registers update (transfer preload to active)
                UPDATE: u1,
            }),
            ///  Timerx Output1 Reset Register
            RSTC1R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Set Register
            SETC2R: mmio.Mmio(packed struct(u32) {
                ///  SST
                SST: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Reset Register
            RSTC2R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx External Event Filtering Register 1
            EEFCR1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 latch
                EE1LTCH: u1,
                ///  External Event 1 filter
                EE1FLTR: u4,
                reserved6: u1,
                ///  External Event 2 latch
                EE2LTCH: u1,
                ///  External Event 2 filter
                EE2FLTR: u4,
                reserved12: u1,
                ///  External Event 3 latch
                EE3LTCH: u1,
                ///  External Event 3 filter
                EE3FLTR: u4,
                reserved18: u1,
                ///  External Event 4 latch
                EE4LTCH: u1,
                ///  External Event 4 filter
                EE4FLTR: u4,
                reserved24: u1,
                ///  External Event 5 latch
                EE5LTCH: u1,
                ///  External Event 5 filter
                EE5FLTR: u4,
                padding: u3,
            }),
            ///  Timerx External Event Filtering Register 2
            EEFCR2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 latch
                EE6LTCH: u1,
                ///  External Event 6 filter
                EE6FLTR: u4,
                reserved6: u1,
                ///  External Event 7 latch
                EE7LTCH: u1,
                ///  External Event 7 filter
                EE7FLTR: u4,
                reserved12: u1,
                ///  External Event 8 latch
                EE8LTCH: u1,
                ///  External Event 8 filter
                EE8FLTR: u4,
                reserved18: u1,
                ///  External Event 9 latch
                EE9LTCH: u1,
                ///  External Event 9 filter
                EE9FLTR: u4,
                reserved24: u1,
                ///  External Event 10 latch
                EE10LTCH: u1,
                ///  External Event 10 filter
                EE10FLTR: u4,
                padding: u3,
            }),
            ///  TimerA Reset Register
            RSTCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Timer A Update reset
                UPDT: u1,
                ///  Timer A compare 2 reset
                CMP2: u1,
                ///  Timer A compare 4 reset
                CMP4: u1,
                ///  Master timer Period
                MSTPER: u1,
                ///  Master compare 1
                MSTCMP1: u1,
                ///  Master compare 2
                MSTCMP2: u1,
                ///  Master compare 3
                MSTCMP3: u1,
                ///  Master compare 4
                MSTCMP4: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Timer A Compare 1
                TIMACMP1: u1,
                ///  Timer A Compare 2
                TIMACMP2: u1,
                ///  Timer A Compare 4
                TIMACMP4: u1,
                ///  Timer B Compare 1
                TIMBCMP1: u1,
                ///  Timer B Compare 2
                TIMBCMP2: u1,
                ///  Timer B Compare 4
                TIMBCMP4: u1,
                ///  Timer D Compare 1
                TIMDCMP1: u1,
                ///  Timer D Compare 2
                TIMDCMP2: u1,
                ///  Timer D Compare 4
                TIMDCMP4: u1,
                ///  Timer E Compare 1
                TIMECMP1: u1,
                ///  Timer E Compare 2
                TIMECMP2: u1,
                ///  Timer E Compare 4
                TIMECMP4: u1,
                padding: u1,
            }),
            ///  Timerx Chopper Register
            CHPCR: mmio.Mmio(packed struct(u32) {
                ///  Timerx carrier frequency value
                CHPFRQ: u4,
                ///  Timerx chopper duty cycle value
                CHPDTY: u3,
                ///  STRTPW
                STRTPW: u4,
                padding: u21,
            }),
            ///  Timerx Capture 2 Control Register
            CPT1CCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                reserved24: u4,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  CPT2xCR
            CPT2CCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                reserved24: u4,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  Timerx Output Register
            OUTCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Output 1 polarity
                POL1: u1,
                ///  Output 1 Idle mode
                IDLEM1: u1,
                ///  Output 1 Idle State
                IDLES1: u1,
                ///  Output 1 Fault state
                FAULT1: u2,
                ///  Output 1 Chopper enable
                CHP1: u1,
                ///  Output 1 Deadtime upon burst mode Idle entry
                DIDL1: u1,
                ///  Deadtime enable
                DTEN: u1,
                ///  Delayed Protection Enable
                DLYPRTEN: u1,
                ///  Delayed Protection
                DLYPRT: u3,
                reserved17: u4,
                ///  Output 2 polarity
                POL2: u1,
                ///  Output 2 Idle mode
                IDLEM2: u1,
                ///  Output 2 Idle State
                IDLES2: u1,
                ///  Output 2 Fault state
                FAULT2: u2,
                ///  Output 2 Chopper enable
                CHP2: u1,
                ///  Output 2 Deadtime upon burst mode Idle entry
                DIDL2: u1,
                padding: u8,
            }),
            ///  Timerx Fault Register
            FLTCR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 enable
                FLT1EN: u1,
                ///  Fault 2 enable
                FLT2EN: u1,
                ///  Fault 3 enable
                FLT3EN: u1,
                ///  Fault 4 enable
                FLT4EN: u1,
                ///  Fault 5 enable
                FLT5EN: u1,
                reserved31: u26,
                ///  Fault sources Lock
                FLTLCK: u1,
            }),
        };

        ///  Low power timer
        pub const LPTIM3 = extern struct {
            ///  Interrupt and Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Compare match
                CMPM: u1,
                ///  Autoreload match
                ARRM: u1,
                ///  External trigger edge event
                EXTTRIG: u1,
                ///  Compare register update OK
                CMPOK: u1,
                ///  Autoreload register update OK
                ARROK: u1,
                ///  Counter direction change down to up
                UP: u1,
                ///  Counter direction change up to down
                DOWN: u1,
                padding: u25,
            }),
            ///  Interrupt Clear Register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  compare match Clear Flag
                CMPMCF: u1,
                ///  Autoreload match Clear Flag
                ARRMCF: u1,
                ///  External trigger valid edge Clear Flag
                EXTTRIGCF: u1,
                ///  Compare register update OK Clear Flag
                CMPOKCF: u1,
                ///  Autoreload register update OK Clear Flag
                ARROKCF: u1,
                ///  Direction change to UP Clear Flag
                UPCF: u1,
                ///  Direction change to down Clear Flag
                DOWNCF: u1,
                padding: u25,
            }),
            ///  Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Compare match Interrupt Enable
                CMPMIE: u1,
                ///  Autoreload match Interrupt Enable
                ARRMIE: u1,
                ///  External trigger valid edge Interrupt Enable
                EXTTRIGIE: u1,
                ///  Compare register update OK Interrupt Enable
                CMPOKIE: u1,
                ///  Autoreload register update OK Interrupt Enable
                ARROKIE: u1,
                ///  Direction change to UP Interrupt Enable
                UPIE: u1,
                ///  Direction change to down Interrupt Enable
                DOWNIE: u1,
                padding: u25,
            }),
            ///  Configuration Register
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  Clock selector
                CKSEL: u1,
                ///  Clock Polarity
                CKPOL: u2,
                ///  Configurable digital filter for external clock
                CKFLT: u2,
                reserved6: u1,
                ///  Configurable digital filter for trigger
                TRGFLT: u2,
                reserved9: u1,
                ///  Clock prescaler
                PRESC: u3,
                reserved13: u1,
                ///  Trigger selector
                TRIGSEL: u3,
                reserved17: u1,
                ///  Trigger enable and polarity
                TRIGEN: u2,
                ///  Timeout enable
                TIMOUT: u1,
                ///  Waveform shape
                WAVE: u1,
                ///  Waveform shape polarity
                WAVPOL: u1,
                ///  Registers update mode
                PRELOAD: u1,
                ///  counter mode enabled
                COUNTMODE: u1,
                ///  Encoder mode enable
                ENC: u1,
                padding: u7,
            }),
            ///  Control Register
            CR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM Enable
                ENABLE: u1,
                ///  LPTIM start in single mode
                SNGSTRT: u1,
                ///  Timer start in continuous mode
                CNTSTRT: u1,
                ///  Counter reset
                COUNTRST: u1,
                ///  Reset after read enable
                RSTARE: u1,
                padding: u27,
            }),
            ///  Compare Register
            CMP: mmio.Mmio(packed struct(u32) {
                ///  Compare value
                CMP: u16,
                padding: u16,
            }),
            ///  Autoreload Register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto reload value
                ARR: u16,
                padding: u16,
            }),
            ///  Counter Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            CFGR2: mmio.Mmio(packed struct(u32) {
                ///  LPTIM Input 1 selection
                IN1SEL: u2,
                padding: u30,
            }),
        };

        ///  Advanced-timers
        pub const TIM1 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                ///  Direction
                DIR: u1,
                ///  Center-aligned mode selection
                CMS: u2,
                ///  Auto-reload preload enable
                ARPE: u1,
                ///  Clock division
                CKD: u2,
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare preloaded control
                CCPC: u1,
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: u1,
                ///  Capture/compare DMA selection
                CCDS: u1,
                ///  Master mode selection
                MMS: u3,
                ///  TI1 selection
                TI1S: u1,
                ///  Output Idle state 1
                OIS1: u1,
                ///  Output Idle state 1
                OIS1N: u1,
                ///  Output Idle state 2
                OIS2: u1,
                ///  Output Idle state 2
                OIS2N: u1,
                ///  Output Idle state 3
                OIS3: u1,
                ///  Output Idle state 3
                OIS3N: u1,
                ///  Output Idle state 4
                OIS4: u1,
                reserved16: u1,
                ///  Output Idle state 5
                OIS5: u1,
                reserved18: u1,
                ///  Output Idle state 6
                OIS6: u1,
                reserved20: u1,
                ///  Master mode selection 2
                MMS2: u4,
                padding: u8,
            }),
            ///  slave mode control register
            SMCR: mmio.Mmio(packed struct(u32) {
                ///  Slave mode selection
                SMS: u3,
                reserved4: u1,
                ///  Trigger selection
                TS: u3,
                ///  Master/Slave mode
                MSM: u1,
                ///  External trigger filter
                ETF: u4,
                ///  External trigger prescaler
                ETPS: u2,
                ///  External clock enable
                ECE: u1,
                ///  External trigger polarity
                ETP: u1,
                ///  Slave mode selection - bit 3
                SMS_3: u1,
                reserved20: u3,
                ///  Trigger selection - bit 4:3
                TS_4_3: u2,
                padding: u10,
            }),
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                ///  Capture/Compare 1 interrupt enable
                CC1IE: u1,
                ///  Capture/Compare 2 interrupt enable
                CC2IE: u1,
                ///  Capture/Compare 3 interrupt enable
                CC3IE: u1,
                ///  Capture/Compare 4 interrupt enable
                CC4IE: u1,
                ///  COM interrupt enable
                COMIE: u1,
                ///  Trigger interrupt enable
                TIE: u1,
                ///  Break interrupt enable
                BIE: u1,
                ///  Update DMA request enable
                UDE: u1,
                ///  Capture/Compare 1 DMA request enable
                CC1DE: u1,
                ///  Capture/Compare 2 DMA request enable
                CC2DE: u1,
                ///  Capture/Compare 3 DMA request enable
                CC3DE: u1,
                ///  Capture/Compare 4 DMA request enable
                CC4DE: u1,
                ///  COM DMA request enable
                COMDE: u1,
                ///  Trigger DMA request enable
                TDE: u1,
                padding: u17,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                ///  Capture/compare 1 interrupt flag
                CC1IF: u1,
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                ///  Capture/Compare 3 interrupt flag
                CC3IF: u1,
                ///  Capture/Compare 4 interrupt flag
                CC4IF: u1,
                ///  COM interrupt flag
                COMIF: u1,
                ///  Trigger interrupt flag
                TIF: u1,
                ///  Break interrupt flag
                BIF: u1,
                ///  Break 2 interrupt flag
                B2IF: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: u1,
                ///  Capture/compare 2 overcapture flag
                CC2OF: u1,
                ///  Capture/Compare 3 overcapture flag
                CC3OF: u1,
                ///  Capture/Compare 4 overcapture flag
                CC4OF: u1,
                ///  System Break interrupt flag
                SBIF: u1,
                reserved16: u2,
                ///  Compare 5 interrupt flag
                CC5IF: u1,
                ///  Compare 6 interrupt flag
                CC6IF: u1,
                padding: u14,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                ///  Capture/compare 2 generation
                CC2G: u1,
                ///  Capture/compare 3 generation
                CC3G: u1,
                ///  Capture/compare 4 generation
                CC4G: u1,
                ///  Capture/Compare control update generation
                COMG: u1,
                ///  Trigger generation
                TG: u1,
                ///  Break generation
                BG: u1,
                ///  Break 2 generation
                B2G: u1,
                padding: u23,
            }),
            ///  capture/compare mode register 1 (output mode)
            CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: u2,
                ///  Output Compare 1 fast enable
                OC1FE: u1,
                ///  Output Compare 1 preload enable
                OC1PE: u1,
                ///  Output Compare 1 mode
                OC1M: u3,
                ///  Output Compare 1 clear enable
                OC1CE: u1,
                ///  Capture/Compare 2 selection
                CC2S: u2,
                ///  Output Compare 2 fast enable
                OC2FE: u1,
                ///  Output Compare 2 preload enable
                OC2PE: u1,
                ///  Output Compare 2 mode
                OC2M: u3,
                ///  Output Compare 2 clear enable
                OC2CE: u1,
                ///  Output Compare 1 mode - bit 3
                OC1M_3: u1,
                reserved24: u7,
                ///  Output Compare 2 mode - bit 3
                OC2M_3: u1,
                padding: u7,
            }),
            ///  capture/compare mode register 2 (output mode)
            CCMR2_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 3 selection
                CC3S: u2,
                ///  Output compare 3 fast enable
                OC3FE: u1,
                ///  Output compare 3 preload enable
                OC3PE: u1,
                ///  Output compare 3 mode
                OC3M: u3,
                ///  Output compare 3 clear enable
                OC3CE: u1,
                ///  Capture/Compare 4 selection
                CC4S: u2,
                ///  Output compare 4 fast enable
                OC4FE: u1,
                ///  Output compare 4 preload enable
                OC4PE: u1,
                ///  Output compare 4 mode
                OC4M: u3,
                ///  Output compare 4 clear enable
                OC4CE: u1,
                ///  Output Compare 3 mode - bit 3
                OC3M_3: u1,
                reserved24: u7,
                ///  Output Compare 4 mode - bit 3
                OC4M_4: u1,
                padding: u7,
            }),
            ///  capture/compare enable register
            CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable
                CC1E: u1,
                ///  Capture/Compare 1 output Polarity
                CC1P: u1,
                ///  Capture/Compare 1 complementary output enable
                CC1NE: u1,
                ///  Capture/Compare 1 output Polarity
                CC1NP: u1,
                ///  Capture/Compare 2 output enable
                CC2E: u1,
                ///  Capture/Compare 2 output Polarity
                CC2P: u1,
                ///  Capture/Compare 2 complementary output enable
                CC2NE: u1,
                ///  Capture/Compare 2 output Polarity
                CC2NP: u1,
                ///  Capture/Compare 3 output enable
                CC3E: u1,
                ///  Capture/Compare 3 output Polarity
                CC3P: u1,
                ///  Capture/Compare 3 complementary output enable
                CC3NE: u1,
                ///  Capture/Compare 3 output Polarity
                CC3NP: u1,
                ///  Capture/Compare 4 output enable
                CC4E: u1,
                ///  Capture/Compare 3 output Polarity
                CC4P: u1,
                reserved15: u1,
                ///  Capture/Compare 4 complementary output polarity
                CC4NP: u1,
                ///  Capture/Compare 5 output enable
                CC5E: u1,
                ///  Capture/Compare 5 output polarity
                CC5P: u1,
                reserved20: u2,
                ///  Capture/Compare 6 output enable
                CC6E: u1,
                ///  Capture/Compare 6 output polarity
                CC6P: u1,
                padding: u10,
            }),
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF copy
                UIFCPY: u1,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto-reload value
                ARR: u16,
                padding: u16,
            }),
            ///  repetition counter register
            RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition counter value
                REP: u8,
                padding: u24,
            }),
            ///  capture/compare register 1
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 value
                CCR1: u16,
                padding: u16,
            }),
            ///  capture/compare register 2
            CCR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 2 value
                CCR2: u16,
                padding: u16,
            }),
            ///  capture/compare register 3
            CCR3: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare value
                CCR3: u16,
                padding: u16,
            }),
            ///  capture/compare register 4
            CCR4: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare value
                CCR4: u16,
                padding: u16,
            }),
            ///  break and dead-time register
            BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: u2,
                ///  Off-state selection for Idle mode
                OSSI: u1,
                ///  Off-state selection for Run mode
                OSSR: u1,
                ///  Break enable
                BKE: u1,
                ///  Break polarity
                BKP: u1,
                ///  Automatic output enable
                AOE: u1,
                ///  Main output enable
                MOE: u1,
                ///  Break filter
                BKF: u4,
                ///  Break 2 filter
                BK2F: u4,
                ///  Break 2 enable
                BK2E: u1,
                ///  Break 2 polarity
                BK2P: u1,
                padding: u6,
            }),
            ///  DMA control register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  DMA base address
                DBA: u5,
                reserved8: u3,
                ///  DMA burst length
                DBL: u5,
                padding: u19,
            }),
            ///  DMA address for full transfer
            DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses
                DMAB: u16,
                padding: u16,
            }),
            reserved84: [4]u8,
            ///  capture/compare mode register 3 (output mode)
            CCMR3_Output: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Output compare 5 fast enable
                OC5FE: u1,
                ///  Output compare 5 preload enable
                OC5PE: u1,
                ///  Output compare 5 mode
                OC5M: u3,
                ///  Output compare 5 clear enable
                OC5CE: u1,
                reserved10: u2,
                ///  Output compare 6 fast enable
                OC6FE: u1,
                ///  Output compare 6 preload enable
                OC6PE: u1,
                ///  Output compare 6 mode
                OC6M: u3,
                ///  Output compare 6 clear enable
                OC6CE: u1,
                ///  Output Compare 5 mode
                OC5M3: u1,
                reserved24: u7,
                ///  Output Compare 6 mode
                OC6M3: u1,
                padding: u7,
            }),
            ///  capture/compare register 5
            CCR5: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 5 value
                CCR5: u16,
                reserved29: u13,
                ///  Group Channel 5 and Channel 1
                GC5C1: u1,
                ///  Group Channel 5 and Channel 2
                GC5C2: u1,
                ///  Group Channel 5 and Channel 3
                GC5C3: u1,
            }),
            ///  capture/compare register 6
            CRR6: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 6 value
                CCR6: u16,
                padding: u16,
            }),
            ///  TIM1 alternate function option register 1
            AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: u1,
                ///  BRK COMP1 enable
                BKCMP1E: u1,
                ///  BRK COMP2 enable
                BKCMP2E: u1,
                reserved8: u5,
                ///  BRK dfsdm1_break[0] enable
                BKDF1BK0E: u1,
                ///  BRK BKIN input polarity
                BKINP: u1,
                ///  BRK COMP1 input polarity
                BKCMP1P: u1,
                ///  BRK COMP2 input polarity
                BKCMP2P: u1,
                reserved14: u2,
                ///  ETR source selection
                ETRSEL: u4,
                padding: u14,
            }),
            ///  TIM1 Alternate function odfsdm1_breakster 2
            AF2: mmio.Mmio(packed struct(u32) {
                ///  BRK2 BKIN input enable
                BK2INE: u1,
                ///  BRK2 COMP1 enable
                BK2CMP1E: u1,
                ///  BRK2 COMP2 enable
                BK2CMP2E: u1,
                reserved8: u5,
                ///  BRK2 dfsdm1_break[1] enable
                BK2DF1BK1E: u1,
                ///  BRK2 BKIN2 input polarity
                BK2INP: u1,
                ///  BRK2 COMP1 input polarit
                BK2CMP1P: u1,
                ///  BRK2 COMP2 input polarity
                BK2CMP2P: u1,
                padding: u20,
            }),
            ///  TIM1 timer input selection register
            TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: u4,
                reserved8: u4,
                ///  selects TI2[0] to TI2[15] input
                TI2SEL: u4,
                reserved16: u4,
                ///  selects TI3[0] to TI3[15] input
                TI3SEL: u4,
                reserved24: u4,
                ///  selects TI4[0] to TI4[15] input
                TI4SEL: u4,
                padding: u4,
            }),
        };

        ///  High Resolution Timer: TIMD
        pub const HRTIM_TIMD = extern struct {
            ///  Timerx Control Register
            TIMDCR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Timer x Clock prescaler
                CK_PSCx: u3,
                ///  Continuous mode
                CONT: u1,
                ///  Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                ///  Push-Pull mode enable
                PSHPLL: u1,
                reserved10: u3,
                ///  Synchronization Resets Timer x
                SYNCRSTx: u1,
                ///  Synchronization Starts Timer x
                SYNCSTRTx: u1,
                ///  Delayed CMP2 mode
                DELCMP2: u2,
                ///  Delayed CMP4 mode
                DELCMP4: u2,
                reserved17: u1,
                ///  Timer x Repetition update
                TxREPU: u1,
                ///  Timerx reset update
                TxRSTU: u1,
                reserved20: u1,
                ///  TBU
                TBU: u1,
                ///  TCU
                TCU: u1,
                ///  TDU
                TDU: u1,
                ///  TEU
                TEU: u1,
                ///  Master Timer update
                MSTU: u1,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                ///  Update Gating
                UPDGAT: u4,
            }),
            ///  Timerx Interrupt Status Register
            TIMDISR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt Flag
                CMP1: u1,
                ///  Compare 2 Interrupt Flag
                CMP2: u1,
                ///  Compare 3 Interrupt Flag
                CMP3: u1,
                ///  Compare 4 Interrupt Flag
                CMP4: u1,
                ///  Repetition Interrupt Flag
                REP: u1,
                reserved6: u1,
                ///  Update Interrupt Flag
                UPD: u1,
                ///  Capture1 Interrupt Flag
                CPT1: u1,
                ///  Capture2 Interrupt Flag
                CPT2: u1,
                ///  Output 1 Set Interrupt Flag
                SETx1: u1,
                ///  Output 1 Reset Interrupt Flag
                RSTx1: u1,
                ///  Output 2 Set Interrupt Flag
                SETx2: u1,
                ///  Output 2 Reset Interrupt Flag
                RSTx2: u1,
                ///  Reset Interrupt Flag
                RST: u1,
                ///  Delayed Protection Flag
                DLYPRT: u1,
                reserved16: u1,
                ///  Current Push Pull Status
                CPPSTAT: u1,
                ///  Idle Push Pull Status
                IPPSTAT: u1,
                ///  Output 1 State
                O1STAT: u1,
                ///  Output 2 State
                O2STAT: u1,
                padding: u12,
            }),
            ///  Timerx Interrupt Clear Register
            TIMDICR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt flag Clear
                CMP1C: u1,
                ///  Compare 2 Interrupt flag Clear
                CMP2C: u1,
                ///  Compare 3 Interrupt flag Clear
                CMP3C: u1,
                ///  Compare 4 Interrupt flag Clear
                CMP4C: u1,
                ///  Repetition Interrupt flag Clear
                REPC: u1,
                reserved6: u1,
                ///  Update Interrupt flag Clear
                UPDC: u1,
                ///  Capture1 Interrupt flag Clear
                CPT1C: u1,
                ///  Capture2 Interrupt flag Clear
                CPT2C: u1,
                ///  Output 1 Set flag Clear
                SET1xC: u1,
                ///  Output 1 Reset flag Clear
                RSTx1C: u1,
                ///  Output 2 Set flag Clear
                SET2xC: u1,
                ///  Output 2 Reset flag Clear
                RSTx2C: u1,
                ///  Reset Interrupt flag Clear
                RSTC: u1,
                ///  Delayed Protection Flag Clear
                DLYPRTC: u1,
                padding: u17,
            }),
            ///  TIMxDIER5
            TIMDDIER5: mmio.Mmio(packed struct(u32) {
                ///  CMP1IE
                CMP1IE: u1,
                ///  CMP2IE
                CMP2IE: u1,
                ///  CMP3IE
                CMP3IE: u1,
                ///  CMP4IE
                CMP4IE: u1,
                ///  REPIE
                REPIE: u1,
                reserved6: u1,
                ///  UPDIE
                UPDIE: u1,
                ///  CPT1IE
                CPT1IE: u1,
                ///  CPT2IE
                CPT2IE: u1,
                ///  SET1xIE
                SET1xIE: u1,
                ///  RSTx1IE
                RSTx1IE: u1,
                ///  SETx2IE
                SETx2IE: u1,
                ///  RSTx2IE
                RSTx2IE: u1,
                ///  RSTIE
                RSTIE: u1,
                ///  DLYPRTIE
                DLYPRTIE: u1,
                reserved16: u1,
                ///  CMP1DE
                CMP1DE: u1,
                ///  CMP2DE
                CMP2DE: u1,
                ///  CMP3DE
                CMP3DE: u1,
                ///  CMP4DE
                CMP4DE: u1,
                ///  REPDE
                REPDE: u1,
                reserved22: u1,
                ///  UPDDE
                UPDDE: u1,
                ///  CPT1DE
                CPT1DE: u1,
                ///  CPT2DE
                CPT2DE: u1,
                ///  SET1xDE
                SET1xDE: u1,
                ///  RSTx1DE
                RSTx1DE: u1,
                ///  SETx2DE
                SETx2DE: u1,
                ///  RSTx2DE
                RSTx2DE: u1,
                ///  RSTDE
                RSTDE: u1,
                ///  DLYPRTDE
                DLYPRTDE: u1,
                padding: u1,
            }),
            ///  Timerx Counter Register
            CNTDR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Counter value
                CNTx: u16,
                padding: u16,
            }),
            ///  Timerx Period Register
            PERDR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Period value
                PERx: u16,
                padding: u16,
            }),
            ///  Timerx Repetition Register
            REPDR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Repetition counter value
                REPx: u8,
                padding: u24,
            }),
            ///  Timerx Compare 1 Register
            CMP1DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 1 Compound Register
            CMP1CDR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                ///  Timerx Repetition value (aliased from HRTIM_REPx register)
                REPx: u8,
                padding: u8,
            }),
            ///  Timerx Compare 2 Register
            CMP2DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 2 value
                CMP2x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 3 Register
            CMP3DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 3 value
                CMP3x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 4 Register
            CMP4DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 4 value
                CMP4x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 1 Register
            CPT1DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 1 value
                CPT1x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 2 Register
            CPT2DR: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 2 value
                CPT2x: u16,
                padding: u16,
            }),
            ///  Timerx Deadtime Register
            DTDR: mmio.Mmio(packed struct(u32) {
                ///  Deadtime Rising value
                DTRx: u9,
                ///  Sign Deadtime Rising value
                SDTRx: u1,
                ///  Deadtime Prescaler
                DTPRSC: u3,
                reserved14: u1,
                ///  Deadtime Rising Sign Lock
                DTRSLKx: u1,
                ///  Deadtime Rising Lock
                DTRLKx: u1,
                ///  Deadtime Falling value
                DTFx: u9,
                ///  Sign Deadtime Falling value
                SDTFx: u1,
                reserved30: u4,
                ///  Deadtime Falling Sign Lock
                DTFSLKx: u1,
                ///  Deadtime Falling Lock
                DTFLKx: u1,
            }),
            ///  Timerx Output1 Set Register
            SETD1R: mmio.Mmio(packed struct(u32) {
                ///  Software Set trigger
                SST: u1,
                ///  Timer A resynchronizaton
                RESYNC: u1,
                ///  Timer A Period
                PER: u1,
                ///  Timer A compare 1
                CMP1: u1,
                ///  Timer A compare 2
                CMP2: u1,
                ///  Timer A compare 3
                CMP3: u1,
                ///  Timer A compare 4
                CMP4: u1,
                ///  Master Period
                MSTPER: u1,
                ///  Master Compare 1
                MSTCMP1: u1,
                ///  Master Compare 2
                MSTCMP2: u1,
                ///  Master Compare 3
                MSTCMP3: u1,
                ///  Master Compare 4
                MSTCMP4: u1,
                ///  Timer Event 1
                TIMEVNT1: u1,
                ///  Timer Event 2
                TIMEVNT2: u1,
                ///  Timer Event 3
                TIMEVNT3: u1,
                ///  Timer Event 4
                TIMEVNT4: u1,
                ///  Timer Event 5
                TIMEVNT5: u1,
                ///  Timer Event 6
                TIMEVNT6: u1,
                ///  Timer Event 7
                TIMEVNT7: u1,
                ///  Timer Event 8
                TIMEVNT8: u1,
                ///  Timer Event 9
                TIMEVNT9: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Registers update (transfer preload to active)
                UPDATE: u1,
            }),
            ///  Timerx Output1 Reset Register
            RSTD1R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Set Register
            SETD2R: mmio.Mmio(packed struct(u32) {
                ///  SST
                SST: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Reset Register
            RSTD2R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx External Event Filtering Register 1
            EEFDR1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 latch
                EE1LTCH: u1,
                ///  External Event 1 filter
                EE1FLTR: u4,
                reserved6: u1,
                ///  External Event 2 latch
                EE2LTCH: u1,
                ///  External Event 2 filter
                EE2FLTR: u4,
                reserved12: u1,
                ///  External Event 3 latch
                EE3LTCH: u1,
                ///  External Event 3 filter
                EE3FLTR: u4,
                reserved18: u1,
                ///  External Event 4 latch
                EE4LTCH: u1,
                ///  External Event 4 filter
                EE4FLTR: u4,
                reserved24: u1,
                ///  External Event 5 latch
                EE5LTCH: u1,
                ///  External Event 5 filter
                EE5FLTR: u4,
                padding: u3,
            }),
            ///  Timerx External Event Filtering Register 2
            EEFDR2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 latch
                EE6LTCH: u1,
                ///  External Event 6 filter
                EE6FLTR: u4,
                reserved6: u1,
                ///  External Event 7 latch
                EE7LTCH: u1,
                ///  External Event 7 filter
                EE7FLTR: u4,
                reserved12: u1,
                ///  External Event 8 latch
                EE8LTCH: u1,
                ///  External Event 8 filter
                EE8FLTR: u4,
                reserved18: u1,
                ///  External Event 9 latch
                EE9LTCH: u1,
                ///  External Event 9 filter
                EE9FLTR: u4,
                reserved24: u1,
                ///  External Event 10 latch
                EE10LTCH: u1,
                ///  External Event 10 filter
                EE10FLTR: u4,
                padding: u3,
            }),
            ///  TimerA Reset Register
            RSTDR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Timer A Update reset
                UPDT: u1,
                ///  Timer A compare 2 reset
                CMP2: u1,
                ///  Timer A compare 4 reset
                CMP4: u1,
                ///  Master timer Period
                MSTPER: u1,
                ///  Master compare 1
                MSTCMP1: u1,
                ///  Master compare 2
                MSTCMP2: u1,
                ///  Master compare 3
                MSTCMP3: u1,
                ///  Master compare 4
                MSTCMP4: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Timer A Compare 1
                TIMACMP1: u1,
                ///  Timer A Compare 2
                TIMACMP2: u1,
                ///  Timer A Compare 4
                TIMACMP4: u1,
                ///  Timer B Compare 1
                TIMBCMP1: u1,
                ///  Timer B Compare 2
                TIMBCMP2: u1,
                ///  Timer B Compare 4
                TIMBCMP4: u1,
                ///  Timer C Compare 1
                TIMCCMP1: u1,
                ///  Timer C Compare 2
                TIMCCMP2: u1,
                ///  Timer C Compare 4
                TIMCCMP4: u1,
                ///  Timer E Compare 1
                TIMECMP1: u1,
                ///  Timer E Compare 2
                TIMECMP2: u1,
                ///  Timer E Compare 4
                TIMECMP4: u1,
                padding: u1,
            }),
            ///  Timerx Chopper Register
            CHPDR: mmio.Mmio(packed struct(u32) {
                ///  Timerx carrier frequency value
                CHPFRQ: u4,
                ///  Timerx chopper duty cycle value
                CHPDTY: u3,
                ///  STRTPW
                STRTPW: u4,
                padding: u21,
            }),
            ///  Timerx Capture 2 Control Register
            CPT1DCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                reserved28: u4,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  CPT2xCR
            CPT2DCR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                reserved28: u4,
                ///  Timer E output 1 Set
                TE1SET: u1,
                ///  Timer E output 1 Reset
                TE1RST: u1,
                ///  Timer E Compare 1
                TECMP1: u1,
                ///  Timer E Compare 2
                TECMP2: u1,
            }),
            ///  Timerx Output Register
            OUTDR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Output 1 polarity
                POL1: u1,
                ///  Output 1 Idle mode
                IDLEM1: u1,
                ///  Output 1 Idle State
                IDLES1: u1,
                ///  Output 1 Fault state
                FAULT1: u2,
                ///  Output 1 Chopper enable
                CHP1: u1,
                ///  Output 1 Deadtime upon burst mode Idle entry
                DIDL1: u1,
                ///  Deadtime enable
                DTEN: u1,
                ///  Delayed Protection Enable
                DLYPRTEN: u1,
                ///  Delayed Protection
                DLYPRT: u3,
                reserved17: u4,
                ///  Output 2 polarity
                POL2: u1,
                ///  Output 2 Idle mode
                IDLEM2: u1,
                ///  Output 2 Idle State
                IDLES2: u1,
                ///  Output 2 Fault state
                FAULT2: u2,
                ///  Output 2 Chopper enable
                CHP2: u1,
                ///  Output 2 Deadtime upon burst mode Idle entry
                DIDL2: u1,
                padding: u8,
            }),
            ///  Timerx Fault Register
            FLTDR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 enable
                FLT1EN: u1,
                ///  Fault 2 enable
                FLT2EN: u1,
                ///  Fault 3 enable
                FLT3EN: u1,
                ///  Fault 4 enable
                FLT4EN: u1,
                ///  Fault 5 enable
                FLT5EN: u1,
                reserved31: u26,
                ///  Fault sources Lock
                FLTLCK: u1,
            }),
        };

        ///  LPUART1
        pub const LPUART1 = extern struct {
            ///  Control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  USART enable
                UE: u1,
                ///  USART enable in Stop mode
                UESM: u1,
                ///  Receiver enable
                RE: u1,
                ///  Transmitter enable
                TE: u1,
                ///  IDLE interrupt enable
                IDLEIE: u1,
                ///  RXNE interrupt enable
                RXNEIE: u1,
                ///  Transmission complete interrupt enable
                TCIE: u1,
                ///  interrupt enable
                TXEIE: u1,
                ///  PE interrupt enable
                PEIE: u1,
                ///  Parity selection
                PS: u1,
                ///  Parity control enable
                PCE: u1,
                ///  Receiver wakeup method
                WAKE: u1,
                ///  Word length
                M0: u1,
                ///  Mute mode enable
                MME: u1,
                ///  Character match interrupt enable
                CMIE: u1,
                reserved16: u1,
                ///  Driver Enable deassertion time
                DEDT: u5,
                ///  Driver Enable assertion time
                DEAT: u5,
                reserved28: u2,
                ///  Word length
                M1: u1,
                ///  FIFO mode enable
                FIFOEN: u1,
                ///  TXFIFO empty interrupt enable
                TXFEIE: u1,
                ///  RXFIFO Full interrupt enable
                RXFFIE: u1,
            }),
            ///  Control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  7-bit Address Detection/4-bit Address Detection
                ADDM7: u1,
                reserved12: u7,
                ///  STOP bits
                STOP: u2,
                reserved15: u1,
                ///  Swap TX/RX pins
                SWAP: u1,
                ///  RX pin active level inversion
                RXINV: u1,
                ///  TX pin active level inversion
                TXINV: u1,
                ///  Binary data inversion
                DATAINV: u1,
                ///  Most significant bit first
                MSBFIRST: u1,
                reserved24: u4,
                ///  Address of the USART node
                ADD: u8,
            }),
            ///  Control register 3
            CR3: mmio.Mmio(packed struct(u32) {
                ///  Error interrupt enable
                EIE: u1,
                reserved3: u2,
                ///  Half-duplex selection
                HDSEL: u1,
                reserved6: u2,
                ///  DMA enable receiver
                DMAR: u1,
                ///  DMA enable transmitter
                DMAT: u1,
                ///  RTS enable
                RTSE: u1,
                ///  CTS enable
                CTSE: u1,
                ///  CTS interrupt enable
                CTSIE: u1,
                reserved12: u1,
                ///  Overrun Disable
                OVRDIS: u1,
                ///  DMA Disable on Reception Error
                DDRE: u1,
                ///  Driver enable mode
                DEM: u1,
                ///  Driver enable polarity selection
                DEP: u1,
                reserved20: u4,
                ///  Wakeup from Stop mode interrupt flag selection
                WUS: u2,
                ///  Wakeup from Stop mode interrupt enable
                WUFIE: u1,
                ///  TXFIFO threshold interrupt enable
                TXFTIE: u1,
                reserved25: u1,
                ///  Receive FIFO threshold configuration
                RXFTCFG: u3,
                ///  RXFIFO threshold interrupt enable
                RXFTIE: u1,
                ///  TXFIFO threshold configuration
                TXFTCFG: u3,
            }),
            ///  Baud rate register
            BRR: mmio.Mmio(packed struct(u32) {
                ///  BRR
                BRR: u20,
                padding: u12,
            }),
            ///  Guard time and prescaler register
            GTPR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u8,
                ///  Guard time value
                GT: u8,
                padding: u16,
            }),
            ///  Receiver timeout register
            RTOR: mmio.Mmio(packed struct(u32) {
                ///  Receiver timeout value
                RTO: u24,
                ///  Block Length
                BLEN: u8,
            }),
            ///  Request register
            RQR: mmio.Mmio(packed struct(u32) {
                ///  Auto baud rate request
                ABRRQ: u1,
                ///  Send break request
                SBKRQ: u1,
                ///  Mute mode request
                MMRQ: u1,
                ///  Receive data flush request
                RXFRQ: u1,
                ///  Transmit data flush request
                TXFRQ: u1,
                padding: u27,
            }),
            ///  Interrupt & status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  PE
                PE: u1,
                ///  FE
                FE: u1,
                ///  NE
                NE: u1,
                ///  ORE
                ORE: u1,
                ///  IDLE
                IDLE: u1,
                ///  RXNE
                RXNE: u1,
                ///  TC
                TC: u1,
                ///  TXE
                TXE: u1,
                reserved9: u1,
                ///  CTSIF
                CTSIF: u1,
                ///  CTS
                CTS: u1,
                reserved16: u5,
                ///  BUSY
                BUSY: u1,
                ///  CMF
                CMF: u1,
                ///  SBKF
                SBKF: u1,
                ///  RWU
                RWU: u1,
                ///  WUF
                WUF: u1,
                ///  TEACK
                TEACK: u1,
                ///  REACK
                REACK: u1,
                ///  TXFIFO Empty
                TXFE: u1,
                ///  RXFIFO Full
                RXFF: u1,
                reserved26: u1,
                ///  RXFIFO threshold flag
                RXFT: u1,
                ///  TXFIFO threshold flag
                TXFT: u1,
                padding: u4,
            }),
            ///  Interrupt flag clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Parity error clear flag
                PECF: u1,
                ///  Framing error clear flag
                FECF: u1,
                ///  Noise detected clear flag
                NCF: u1,
                ///  Overrun error clear flag
                ORECF: u1,
                ///  Idle line detected clear flag
                IDLECF: u1,
                reserved6: u1,
                ///  Transmission complete clear flag
                TCCF: u1,
                reserved9: u2,
                ///  CTS clear flag
                CTSCF: u1,
                reserved17: u7,
                ///  Character match clear flag
                CMCF: u1,
                reserved20: u2,
                ///  Wakeup from Stop mode clear flag
                WUCF: u1,
                padding: u11,
            }),
            ///  Receive data register
            RDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data value
                RDR: u9,
                padding: u23,
            }),
            ///  Transmit data register
            TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data value
                TDR: u9,
                padding: u23,
            }),
            ///  Prescaler register
            PRESC: mmio.Mmio(packed struct(u32) {
                ///  Clock prescaler
                PRESCALER: u4,
                padding: u28,
            }),
        };

        ///  System configuration controller
        pub const SYSCFG = extern struct {
            reserved4: [4]u8,
            ///  peripheral mode configuration register
            PMCR: mmio.Mmio(packed struct(u32) {
                ///  I2C1 Fm+
                I2C1FMP: u1,
                ///  I2C2 Fm+
                I2C2FMP: u1,
                ///  I2C3 Fm+
                I2C3FMP: u1,
                ///  I2C4 Fm+
                I2C4FMP: u1,
                ///  PB(6) Fm+
                PB6FMP: u1,
                ///  PB(7) Fast Mode Plus
                PB7FMP: u1,
                ///  PB(8) Fast Mode Plus
                PB8FMP: u1,
                ///  PB(9) Fm+
                PB9FMP: u1,
                ///  Booster Enable
                BOOSTE: u1,
                ///  Analog switch supply voltage selection
                BOOSTVDDSEL: u1,
                reserved21: u11,
                ///  Ethernet PHY Interface Selection
                EPIS: u3,
                ///  PA0 Switch Open
                PA0SO: u1,
                ///  PA1 Switch Open
                PA1SO: u1,
                ///  PC2 Switch Open
                PC2SO: u1,
                ///  PC3 Switch Open
                PC3SO: u1,
                padding: u4,
            }),
            ///  external interrupt configuration register 1
            EXTICR1: mmio.Mmio(packed struct(u32) {
                ///  EXTI x configuration (x = 0 to 3)
                EXTI0: u4,
                ///  EXTI x configuration (x = 0 to 3)
                EXTI1: u4,
                ///  EXTI x configuration (x = 0 to 3)
                EXTI2: u4,
                ///  EXTI x configuration (x = 0 to 3)
                EXTI3: u4,
                padding: u16,
            }),
            ///  external interrupt configuration register 2
            EXTICR2: mmio.Mmio(packed struct(u32) {
                ///  EXTI x configuration (x = 4 to 7)
                EXTI4: u4,
                ///  EXTI x configuration (x = 4 to 7)
                EXTI5: u4,
                ///  EXTI x configuration (x = 4 to 7)
                EXTI6: u4,
                ///  EXTI x configuration (x = 4 to 7)
                EXTI7: u4,
                padding: u16,
            }),
            ///  external interrupt configuration register 3
            EXTICR3: mmio.Mmio(packed struct(u32) {
                ///  EXTI x configuration (x = 8 to 11)
                EXTI8: u4,
                ///  EXTI x configuration (x = 8 to 11)
                EXTI9: u4,
                ///  EXTI10
                EXTI10: u4,
                ///  EXTI x configuration (x = 8 to 11)
                EXTI11: u4,
                padding: u16,
            }),
            ///  external interrupt configuration register 4
            EXTICR4: mmio.Mmio(packed struct(u32) {
                ///  EXTI x configuration (x = 12 to 15)
                EXTI12: u4,
                ///  EXTI x configuration (x = 12 to 15)
                EXTI13: u4,
                ///  EXTI x configuration (x = 12 to 15)
                EXTI14: u4,
                ///  EXTI x configuration (x = 12 to 15)
                EXTI15: u4,
                padding: u16,
            }),
            reserved32: [8]u8,
            ///  compensation cell control/status register
            CCCSR: mmio.Mmio(packed struct(u32) {
                ///  enable
                EN: u1,
                ///  Code selection
                CS: u1,
                reserved8: u6,
                ///  Compensation cell ready flag
                READY: u1,
                reserved16: u7,
                ///  High-speed at low-voltage
                HSLV: u1,
                padding: u15,
            }),
            ///  SYSCFG compensation cell value register
            CCVR: mmio.Mmio(packed struct(u32) {
                ///  NMOS compensation value
                NCV: u4,
                ///  PMOS compensation value
                PCV: u4,
                padding: u24,
            }),
            ///  SYSCFG compensation cell code register
            CCCR: mmio.Mmio(packed struct(u32) {
                ///  NMOS compensation code
                NCC: u4,
                ///  PMOS compensation code
                PCC: u4,
                padding: u24,
            }),
            ///  SYSCFG power control register
            PWRCR: mmio.Mmio(packed struct(u32) {
                ///  Overdrive enable
                ODEN: u1,
                padding: u31,
            }),
            reserved292: [244]u8,
            ///  SYSCFG package register
            PKGR: mmio.Mmio(packed struct(u32) {
                ///  Package
                PKG: u4,
                padding: u28,
            }),
            reserved768: [472]u8,
            ///  SYSCFG user register 0
            UR0: mmio.Mmio(packed struct(u32) {
                ///  Bank Swap
                BKS: u1,
                reserved16: u15,
                ///  Readout protection
                RDP: u8,
                padding: u8,
            }),
            reserved776: [4]u8,
            ///  SYSCFG user register 2
            UR2: mmio.Mmio(packed struct(u32) {
                ///  BOR_LVL Brownout Reset Threshold Level
                BORH: u2,
                reserved16: u14,
                ///  Boot Address 0
                BOOT_ADD0: u16,
            }),
            ///  SYSCFG user register 3
            UR3: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Boot Address 1
                BOOT_ADD1: u16,
            }),
            ///  SYSCFG user register 4
            UR4: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Mass Erase Protected Area Disabled for bank 1
                MEPAD_1: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 5
            UR5: mmio.Mmio(packed struct(u32) {
                ///  Mass erase secured area disabled for bank 1
                MESAD_1: u1,
                reserved16: u15,
                ///  Write protection for flash bank 1
                WRPN_1: u8,
                padding: u8,
            }),
            ///  SYSCFG user register 6
            UR6: mmio.Mmio(packed struct(u32) {
                ///  Protected area start address for bank 1
                PA_BEG_1: u12,
                reserved16: u4,
                ///  Protected area end address for bank 1
                PA_END_1: u12,
                padding: u4,
            }),
            ///  SYSCFG user register 7
            UR7: mmio.Mmio(packed struct(u32) {
                ///  Secured area start address for bank 1
                SA_BEG_1: u12,
                reserved16: u4,
                ///  Secured area end address for bank 1
                SA_END_1: u12,
                padding: u4,
            }),
            ///  SYSCFG user register 8
            UR8: mmio.Mmio(packed struct(u32) {
                ///  Mass erase protected area disabled for bank 2
                MEPAD_2: u1,
                reserved16: u15,
                ///  Mass erase secured area disabled for bank 2
                MESAD_2: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 9
            UR9: mmio.Mmio(packed struct(u32) {
                ///  Write protection for flash bank 2
                WRPN_2: u8,
                reserved16: u8,
                ///  Protected area start address for bank 2
                PA_BEG_2: u12,
                padding: u4,
            }),
            ///  SYSCFG user register 10
            UR10: mmio.Mmio(packed struct(u32) {
                ///  Protected area end address for bank 2
                PA_END_2: u12,
                reserved16: u4,
                ///  Secured area start address for bank 2
                SA_BEG_2: u12,
                padding: u4,
            }),
            ///  SYSCFG user register 11
            UR11: mmio.Mmio(packed struct(u32) {
                ///  Secured area end address for bank 2
                SA_END_2: u12,
                reserved16: u4,
                ///  Independent Watchdog 1 mode
                IWDG1M: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 12
            UR12: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Secure mode
                SECURE: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 13
            UR13: mmio.Mmio(packed struct(u32) {
                ///  Secured DTCM RAM Size
                SDRS: u2,
                reserved16: u14,
                ///  D1 Standby reset
                D1SBRST: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 14
            UR14: mmio.Mmio(packed struct(u32) {
                ///  D1 Stop Reset
                D1STPRST: u1,
                padding: u31,
            }),
            ///  SYSCFG user register 15
            UR15: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Freeze independent watchdog in Standby mode
                FZIWDGSTB: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 16
            UR16: mmio.Mmio(packed struct(u32) {
                ///  Freeze independent watchdog in Stop mode
                FZIWDGSTP: u1,
                reserved16: u15,
                ///  Private key programmed
                PKP: u1,
                padding: u15,
            }),
            ///  SYSCFG user register 17
            UR17: mmio.Mmio(packed struct(u32) {
                ///  I/O high speed / low voltage
                IO_HSLV: u1,
                padding: u31,
            }),
        };

        ///  External interrupt/event controller
        pub const EXTI = extern struct {
            ///  EXTI rising trigger selection register
            RTSR1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of Configurable Event input
                TR0: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR1: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR2: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR3: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR4: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR5: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR6: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR7: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR8: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR9: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR10: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR11: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR12: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR13: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR14: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR15: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR16: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR17: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR18: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR21: u1,
                padding: u10,
            }),
            ///  EXTI falling trigger selection register
            FTSR1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of Configurable Event input
                TR0: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR1: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR2: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR3: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR4: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR5: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR6: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR7: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR8: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR9: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR10: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR11: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR12: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR13: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR14: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR15: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR16: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR17: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR18: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                TR21: u1,
                padding: u10,
            }),
            ///  EXTI software interrupt event register
            SWIER1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER0: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER1: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER2: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER3: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER4: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER5: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER6: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER7: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER8: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER9: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER10: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER11: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER12: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER13: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER14: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER15: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER16: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER17: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER18: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                SWIER21: u1,
                padding: u10,
            }),
            ///  EXTI D3 pending mask register
            D3PMR1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of Configurable Event input
                MR0: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR1: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR2: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR3: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR4: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR5: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR6: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR7: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR8: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR9: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR10: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR11: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR12: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR13: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR14: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR15: u1,
                reserved19: u3,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR21: u1,
                reserved25: u3,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR25: u1,
                padding: u6,
            }),
            ///  EXTI D3 pending clear selection register low
            D3PCR1L: mmio.Mmio(packed struct(u32) {
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS0: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS1: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS2: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS3: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS4: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS5: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS6: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS7: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS8: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS9: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS10: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS11: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS12: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS13: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS14: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate (n/2)
                PCS15: u2,
            }),
            ///  EXTI D3 pending clear selection register high
            D3PCR1H: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
                PCS19: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
                PCS20: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
                PCS21: u2,
                reserved18: u6,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
                PCS25: u2,
                padding: u12,
            }),
            reserved32: [8]u8,
            ///  EXTI rising trigger selection register
            RTSR2: mmio.Mmio(packed struct(u32) {
                reserved17: u17,
                ///  Rising trigger event configuration bit of Configurable Event input x+32
                TR49: u1,
                reserved19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input x+32
                TR51: u1,
                padding: u12,
            }),
            ///  EXTI falling trigger selection register
            FTSR2: mmio.Mmio(packed struct(u32) {
                reserved17: u17,
                ///  Falling trigger event configuration bit of Configurable Event input x+32
                TR49: u1,
                reserved19: u1,
                ///  Falling trigger event configuration bit of Configurable Event input x+32
                TR51: u1,
                padding: u12,
            }),
            ///  EXTI software interrupt event register
            SWIER2: mmio.Mmio(packed struct(u32) {
                reserved17: u17,
                ///  Software interrupt on line x+32
                SWIER49: u1,
                reserved19: u1,
                ///  Software interrupt on line x+32
                SWIER51: u1,
                padding: u12,
            }),
            ///  EXTI D3 pending mask register
            D3PMR2: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  D3 Pending Mask on Event input x+32
                MR34: u1,
                ///  D3 Pending Mask on Event input x+32
                MR35: u1,
                reserved9: u5,
                ///  D3 Pending Mask on Event input x+32
                MR41: u1,
                reserved16: u6,
                ///  D3 Pending Mask on Event input x+32
                MR48: u1,
                ///  D3 Pending Mask on Event input x+32
                MR49: u1,
                ///  D3 Pending Mask on Event input x+32
                MR50: u1,
                ///  D3 Pending Mask on Event input x+32
                MR51: u1,
                ///  D3 Pending Mask on Event input x+32
                MR52: u1,
                ///  D3 Pending Mask on Event input x+32
                MR53: u1,
                padding: u10,
            }),
            ///  EXTI D3 pending clear selection register low
            D3PCR2L: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
                PCS34: u2,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
                PCS35: u2,
                reserved18: u10,
                ///  D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
                PCS41: u2,
                padding: u12,
            }),
            ///  EXTI D3 pending clear selection register high
            D3PCR2H: mmio.Mmio(packed struct(u32) {
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS48: u2,
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS49: u2,
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS50: u2,
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS51: u2,
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS52: u2,
                ///  Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
                PCS53: u2,
                padding: u20,
            }),
            reserved64: [8]u8,
            ///  EXTI rising trigger selection register
            RTSR3: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  Rising trigger event configuration bit of Configurable Event input x+64
                TR82: u1,
                reserved20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input x+64
                TR84: u1,
                ///  Rising trigger event configuration bit of Configurable Event input x+64
                TR85: u1,
                ///  Rising trigger event configuration bit of Configurable Event input x+64
                TR86: u1,
                padding: u9,
            }),
            ///  EXTI falling trigger selection register
            FTSR3: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  Falling trigger event configuration bit of Configurable Event input x+64
                TR82: u1,
                reserved20: u1,
                ///  Falling trigger event configuration bit of Configurable Event input x+64
                TR84: u1,
                ///  Falling trigger event configuration bit of Configurable Event input x+64
                TR85: u1,
                ///  Falling trigger event configuration bit of Configurable Event input x+64
                TR86: u1,
                padding: u9,
            }),
            ///  EXTI software interrupt event register
            SWIER3: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  Software interrupt on line x+64
                SWIER82: u1,
                reserved20: u1,
                ///  Software interrupt on line x+64
                SWIER84: u1,
                ///  Software interrupt on line x+64
                SWIER85: u1,
                ///  Software interrupt on line x+64
                SWIER86: u1,
                padding: u9,
            }),
            ///  EXTI D3 pending mask register
            D3PMR3: mmio.Mmio(packed struct(u32) {
                reserved24: u24,
                ///  D3 Pending Mask on Event input x+64
                MR88: u1,
                padding: u7,
            }),
            reserved84: [4]u8,
            ///  EXTI D3 pending clear selection register high
            D3PCR3H: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  D3 Pending request clear input signal selection on Event input x= truncate N+160/2
                PCS88: u2,
                padding: u12,
            }),
            reserved128: [40]u8,
            ///  EXTI interrupt mask register
            CPUIMR1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of Configurable Event input
                MR0: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR1: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR2: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR3: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR4: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR5: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR6: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR7: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR8: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR9: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR10: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR11: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR12: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR13: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR14: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR15: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR16: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR17: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR18: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR19: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR20: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR21: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR22: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR23: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR24: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR25: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR26: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR27: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR28: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR29: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR30: u1,
                ///  Rising trigger event configuration bit of Configurable Event input
                MR31: u1,
            }),
            ///  EXTI event mask register
            CPUEMR1: mmio.Mmio(packed struct(u32) {
                ///  CPU Event mask on Event input x
                MR0: u1,
                ///  CPU Event mask on Event input x
                MR1: u1,
                ///  CPU Event mask on Event input x
                MR2: u1,
                ///  CPU Event mask on Event input x
                MR3: u1,
                ///  CPU Event mask on Event input x
                MR4: u1,
                ///  CPU Event mask on Event input x
                MR5: u1,
                ///  CPU Event mask on Event input x
                MR6: u1,
                ///  CPU Event mask on Event input x
                MR7: u1,
                ///  CPU Event mask on Event input x
                MR8: u1,
                ///  CPU Event mask on Event input x
                MR9: u1,
                ///  CPU Event mask on Event input x
                MR10: u1,
                ///  CPU Event mask on Event input x
                MR11: u1,
                ///  CPU Event mask on Event input x
                MR12: u1,
                ///  CPU Event mask on Event input x
                MR13: u1,
                ///  CPU Event mask on Event input x
                MR14: u1,
                ///  CPU Event mask on Event input x
                MR15: u1,
                ///  CPU Event mask on Event input x
                MR16: u1,
                ///  CPU Event mask on Event input x
                MR17: u1,
                ///  CPU Event mask on Event input x
                MR18: u1,
                ///  CPU Event mask on Event input x
                MR19: u1,
                ///  CPU Event mask on Event input x
                MR20: u1,
                ///  CPU Event mask on Event input x
                MR21: u1,
                ///  CPU Event mask on Event input x
                MR22: u1,
                ///  CPU Event mask on Event input x
                MR23: u1,
                ///  CPU Event mask on Event input x
                MR24: u1,
                ///  CPU Event mask on Event input x
                MR25: u1,
                ///  CPU Event mask on Event input x
                MR26: u1,
                ///  CPU Event mask on Event input x
                MR27: u1,
                ///  CPU Event mask on Event input x
                MR28: u1,
                ///  CPU Event mask on Event input x
                MR29: u1,
                ///  CPU Event mask on Event input x
                MR30: u1,
                ///  CPU Event mask on Event input x
                MR31: u1,
            }),
            ///  EXTI pending register
            CPUPR1: mmio.Mmio(packed struct(u32) {
                ///  CPU Event mask on Event input x
                PR0: u1,
                ///  CPU Event mask on Event input x
                PR1: u1,
                ///  CPU Event mask on Event input x
                PR2: u1,
                ///  CPU Event mask on Event input x
                PR3: u1,
                ///  CPU Event mask on Event input x
                PR4: u1,
                ///  CPU Event mask on Event input x
                PR5: u1,
                ///  CPU Event mask on Event input x
                PR6: u1,
                ///  CPU Event mask on Event input x
                PR7: u1,
                ///  CPU Event mask on Event input x
                PR8: u1,
                ///  CPU Event mask on Event input x
                PR9: u1,
                ///  CPU Event mask on Event input x
                PR10: u1,
                ///  CPU Event mask on Event input x
                PR11: u1,
                ///  CPU Event mask on Event input x
                PR12: u1,
                ///  CPU Event mask on Event input x
                PR13: u1,
                ///  CPU Event mask on Event input x
                PR14: u1,
                ///  CPU Event mask on Event input x
                PR15: u1,
                ///  CPU Event mask on Event input x
                PR16: u1,
                ///  CPU Event mask on Event input x
                PR17: u1,
                ///  CPU Event mask on Event input x
                PR18: u1,
                ///  CPU Event mask on Event input x
                PR19: u1,
                ///  CPU Event mask on Event input x
                PR20: u1,
                ///  CPU Event mask on Event input x
                PR21: u1,
                padding: u10,
            }),
            reserved144: [4]u8,
            ///  EXTI interrupt mask register
            CPUIMR2: mmio.Mmio(packed struct(u32) {
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR0: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR1: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR2: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR3: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR4: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR5: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR6: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR7: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR8: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR9: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR10: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR11: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR12: u1,
                reserved14: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR14: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR15: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR16: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR17: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR18: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR19: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR20: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR21: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR22: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR23: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR24: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR25: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR26: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR27: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR28: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR29: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR30: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR31: u1,
            }),
            ///  EXTI event mask register
            CPUEMR2: mmio.Mmio(packed struct(u32) {
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR32: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR33: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR34: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR35: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR36: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR37: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR38: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR39: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR40: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR41: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR42: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR43: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR44: u1,
                reserved14: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR46: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR47: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR48: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR49: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR50: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR51: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR52: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR53: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR54: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR55: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR56: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR57: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR58: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR59: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR60: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR61: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR62: u1,
                ///  CPU Interrupt Mask on Direct Event input x+32
                MR63: u1,
            }),
            ///  EXTI pending register
            CPUPR2: mmio.Mmio(packed struct(u32) {
                reserved17: u17,
                ///  Configurable event inputs x+32 Pending bit
                PR49: u1,
                reserved19: u1,
                ///  Configurable event inputs x+32 Pending bit
                PR51: u1,
                padding: u12,
            }),
            reserved160: [4]u8,
            ///  EXTI interrupt mask register
            CPUIMR3: mmio.Mmio(packed struct(u32) {
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR64: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR65: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR66: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR67: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR68: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR69: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR70: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR71: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR72: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR73: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR74: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR75: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR76: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR77: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR78: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR79: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR80: u1,
                reserved18: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR82: u1,
                reserved20: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR84: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR85: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR86: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR87: u1,
                ///  CPU Interrupt Mask on Direct Event input x+64
                MR88: u1,
                padding: u7,
            }),
            ///  EXTI event mask register
            CPUEMR3: mmio.Mmio(packed struct(u32) {
                ///  CPU Event mask on Event input x+64
                MR64: u1,
                ///  CPU Event mask on Event input x+64
                MR65: u1,
                ///  CPU Event mask on Event input x+64
                MR66: u1,
                ///  CPU Event mask on Event input x+64
                MR67: u1,
                ///  CPU Event mask on Event input x+64
                MR68: u1,
                ///  CPU Event mask on Event input x+64
                MR69: u1,
                ///  CPU Event mask on Event input x+64
                MR70: u1,
                ///  CPU Event mask on Event input x+64
                MR71: u1,
                ///  CPU Event mask on Event input x+64
                MR72: u1,
                ///  CPU Event mask on Event input x+64
                MR73: u1,
                ///  CPU Event mask on Event input x+64
                MR74: u1,
                ///  CPU Event mask on Event input x+64
                MR75: u1,
                ///  CPU Event mask on Event input x+64
                MR76: u1,
                ///  CPU Event mask on Event input x+64
                MR77: u1,
                ///  CPU Event mask on Event input x+64
                MR78: u1,
                ///  CPU Event mask on Event input x+64
                MR79: u1,
                ///  CPU Event mask on Event input x+64
                MR80: u1,
                reserved18: u1,
                ///  CPU Event mask on Event input x+64
                MR82: u1,
                reserved20: u1,
                ///  CPU Event mask on Event input x+64
                MR84: u1,
                ///  CPU Event mask on Event input x+64
                MR85: u1,
                ///  CPU Event mask on Event input x+64
                MR86: u1,
                ///  CPU Event mask on Event input x+64
                MR87: u1,
                ///  CPU Event mask on Event input x+64
                MR88: u1,
                padding: u7,
            }),
            ///  EXTI pending register
            CPUPR3: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  Configurable event inputs x+64 Pending bit
                PR82: u1,
                reserved20: u1,
                ///  Configurable event inputs x+64 Pending bit
                PR84: u1,
                ///  Configurable event inputs x+64 Pending bit
                PR85: u1,
                ///  Configurable event inputs x+64 Pending bit
                PR86: u1,
                padding: u9,
            }),
        };

        ///  DELAY_Block_SDMMC1
        pub const DELAY_Block_SDMMC1 = extern struct {
            ///  DLYB control register
            CR: mmio.Mmio(packed struct(u32) {
                ///  Delay block enable bit
                DEN: u1,
                ///  Sampler length enable bit
                SEN: u1,
                padding: u30,
            }),
            ///  DLYB configuration register
            CFGR: mmio.Mmio(packed struct(u32) {
                ///  Select the phase for the Output clock
                SEL: u4,
                reserved8: u4,
                ///  Delay Defines the delay of a Unit delay cell
                UNIT: u7,
                reserved16: u1,
                ///  Delay line length value
                LNG: u12,
                reserved31: u3,
                ///  Length valid flag
                LNGF: u1,
            }),
        };

        ///  High Resolution Timer: TIME
        pub const HRTIM_TIME = extern struct {
            ///  Timerx Control Register
            TIMECR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM Timer x Clock prescaler
                CK_PSCx: u3,
                ///  Continuous mode
                CONT: u1,
                ///  Re-triggerable mode
                RETRIG: u1,
                ///  Half mode enable
                HALF: u1,
                ///  Push-Pull mode enable
                PSHPLL: u1,
                reserved10: u3,
                ///  Synchronization Resets Timer x
                SYNCRSTx: u1,
                ///  Synchronization Starts Timer x
                SYNCSTRTx: u1,
                ///  Delayed CMP2 mode
                DELCMP2: u2,
                ///  Delayed CMP4 mode
                DELCMP4: u2,
                reserved17: u1,
                ///  Timer x Repetition update
                TxREPU: u1,
                ///  Timerx reset update
                TxRSTU: u1,
                reserved20: u1,
                ///  TBU
                TBU: u1,
                ///  TCU
                TCU: u1,
                ///  TDU
                TDU: u1,
                ///  TEU
                TEU: u1,
                ///  Master Timer update
                MSTU: u1,
                ///  AC Synchronization
                DACSYNC: u2,
                ///  Preload enable
                PREEN: u1,
                ///  Update Gating
                UPDGAT: u4,
            }),
            ///  Timerx Interrupt Status Register
            TIMEISR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt Flag
                CMP1: u1,
                ///  Compare 2 Interrupt Flag
                CMP2: u1,
                ///  Compare 3 Interrupt Flag
                CMP3: u1,
                ///  Compare 4 Interrupt Flag
                CMP4: u1,
                ///  Repetition Interrupt Flag
                REP: u1,
                reserved6: u1,
                ///  Update Interrupt Flag
                UPD: u1,
                ///  Capture1 Interrupt Flag
                CPT1: u1,
                ///  Capture2 Interrupt Flag
                CPT2: u1,
                ///  Output 1 Set Interrupt Flag
                SETx1: u1,
                ///  Output 1 Reset Interrupt Flag
                RSTx1: u1,
                ///  Output 2 Set Interrupt Flag
                SETx2: u1,
                ///  Output 2 Reset Interrupt Flag
                RSTx2: u1,
                ///  Reset Interrupt Flag
                RST: u1,
                ///  Delayed Protection Flag
                DLYPRT: u1,
                reserved16: u1,
                ///  Current Push Pull Status
                CPPSTAT: u1,
                ///  Idle Push Pull Status
                IPPSTAT: u1,
                ///  Output 1 State
                O1STAT: u1,
                ///  Output 2 State
                O2STAT: u1,
                padding: u12,
            }),
            ///  Timerx Interrupt Clear Register
            TIMEICR: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 Interrupt flag Clear
                CMP1C: u1,
                ///  Compare 2 Interrupt flag Clear
                CMP2C: u1,
                ///  Compare 3 Interrupt flag Clear
                CMP3C: u1,
                ///  Compare 4 Interrupt flag Clear
                CMP4C: u1,
                ///  Repetition Interrupt flag Clear
                REPC: u1,
                reserved6: u1,
                ///  Update Interrupt flag Clear
                UPDC: u1,
                ///  Capture1 Interrupt flag Clear
                CPT1C: u1,
                ///  Capture2 Interrupt flag Clear
                CPT2C: u1,
                ///  Output 1 Set flag Clear
                SET1xC: u1,
                ///  Output 1 Reset flag Clear
                RSTx1C: u1,
                ///  Output 2 Set flag Clear
                SET2xC: u1,
                ///  Output 2 Reset flag Clear
                RSTx2C: u1,
                ///  Reset Interrupt flag Clear
                RSTC: u1,
                ///  Delayed Protection Flag Clear
                DLYPRTC: u1,
                padding: u17,
            }),
            ///  TIMxDIER5
            TIMEDIER5: mmio.Mmio(packed struct(u32) {
                ///  CMP1IE
                CMP1IE: u1,
                ///  CMP2IE
                CMP2IE: u1,
                ///  CMP3IE
                CMP3IE: u1,
                ///  CMP4IE
                CMP4IE: u1,
                ///  REPIE
                REPIE: u1,
                reserved6: u1,
                ///  UPDIE
                UPDIE: u1,
                ///  CPT1IE
                CPT1IE: u1,
                ///  CPT2IE
                CPT2IE: u1,
                ///  SET1xIE
                SET1xIE: u1,
                ///  RSTx1IE
                RSTx1IE: u1,
                ///  SETx2IE
                SETx2IE: u1,
                ///  RSTx2IE
                RSTx2IE: u1,
                ///  RSTIE
                RSTIE: u1,
                ///  DLYPRTIE
                DLYPRTIE: u1,
                reserved16: u1,
                ///  CMP1DE
                CMP1DE: u1,
                ///  CMP2DE
                CMP2DE: u1,
                ///  CMP3DE
                CMP3DE: u1,
                ///  CMP4DE
                CMP4DE: u1,
                ///  REPDE
                REPDE: u1,
                reserved22: u1,
                ///  UPDDE
                UPDDE: u1,
                ///  CPT1DE
                CPT1DE: u1,
                ///  CPT2DE
                CPT2DE: u1,
                ///  SET1xDE
                SET1xDE: u1,
                ///  RSTx1DE
                RSTx1DE: u1,
                ///  SETx2DE
                SETx2DE: u1,
                ///  RSTx2DE
                RSTx2DE: u1,
                ///  RSTDE
                RSTDE: u1,
                ///  DLYPRTDE
                DLYPRTDE: u1,
                padding: u1,
            }),
            ///  Timerx Counter Register
            CNTER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Counter value
                CNTx: u16,
                padding: u16,
            }),
            ///  Timerx Period Register
            PERER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Period value
                PERx: u16,
                padding: u16,
            }),
            ///  Timerx Repetition Register
            REPER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Repetition counter value
                REPx: u8,
                padding: u24,
            }),
            ///  Timerx Compare 1 Register
            CMP1ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 1 Compound Register
            CMP1CER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 1 value
                CMP1x: u16,
                ///  Timerx Repetition value (aliased from HRTIM_REPx register)
                REPx: u8,
                padding: u8,
            }),
            ///  Timerx Compare 2 Register
            CMP2ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 2 value
                CMP2x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 3 Register
            CMP3ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 3 value
                CMP3x: u16,
                padding: u16,
            }),
            ///  Timerx Compare 4 Register
            CMP4ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Compare 4 value
                CMP4x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 1 Register
            CPT1ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 1 value
                CPT1x: u16,
                padding: u16,
            }),
            ///  Timerx Capture 2 Register
            CPT2ER: mmio.Mmio(packed struct(u32) {
                ///  Timerx Capture 2 value
                CPT2x: u16,
                padding: u16,
            }),
            ///  Timerx Deadtime Register
            DTER: mmio.Mmio(packed struct(u32) {
                ///  Deadtime Rising value
                DTRx: u9,
                ///  Sign Deadtime Rising value
                SDTRx: u1,
                ///  Deadtime Prescaler
                DTPRSC: u3,
                reserved14: u1,
                ///  Deadtime Rising Sign Lock
                DTRSLKx: u1,
                ///  Deadtime Rising Lock
                DTRLKx: u1,
                ///  Deadtime Falling value
                DTFx: u9,
                ///  Sign Deadtime Falling value
                SDTFx: u1,
                reserved30: u4,
                ///  Deadtime Falling Sign Lock
                DTFSLKx: u1,
                ///  Deadtime Falling Lock
                DTFLKx: u1,
            }),
            ///  Timerx Output1 Set Register
            SETE1R: mmio.Mmio(packed struct(u32) {
                ///  Software Set trigger
                SST: u1,
                ///  Timer A resynchronizaton
                RESYNC: u1,
                ///  Timer A Period
                PER: u1,
                ///  Timer A compare 1
                CMP1: u1,
                ///  Timer A compare 2
                CMP2: u1,
                ///  Timer A compare 3
                CMP3: u1,
                ///  Timer A compare 4
                CMP4: u1,
                ///  Master Period
                MSTPER: u1,
                ///  Master Compare 1
                MSTCMP1: u1,
                ///  Master Compare 2
                MSTCMP2: u1,
                ///  Master Compare 3
                MSTCMP3: u1,
                ///  Master Compare 4
                MSTCMP4: u1,
                ///  Timer Event 1
                TIMEVNT1: u1,
                ///  Timer Event 2
                TIMEVNT2: u1,
                ///  Timer Event 3
                TIMEVNT3: u1,
                ///  Timer Event 4
                TIMEVNT4: u1,
                ///  Timer Event 5
                TIMEVNT5: u1,
                ///  Timer Event 6
                TIMEVNT6: u1,
                ///  Timer Event 7
                TIMEVNT7: u1,
                ///  Timer Event 8
                TIMEVNT8: u1,
                ///  Timer Event 9
                TIMEVNT9: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Registers update (transfer preload to active)
                UPDATE: u1,
            }),
            ///  Timerx Output1 Reset Register
            RSTE1R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Set Register
            SETE2R: mmio.Mmio(packed struct(u32) {
                ///  SST
                SST: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx Output2 Reset Register
            RSTE2R: mmio.Mmio(packed struct(u32) {
                ///  SRT
                SRT: u1,
                ///  RESYNC
                RESYNC: u1,
                ///  PER
                PER: u1,
                ///  CMP1
                CMP1: u1,
                ///  CMP2
                CMP2: u1,
                ///  CMP3
                CMP3: u1,
                ///  CMP4
                CMP4: u1,
                ///  MSTPER
                MSTPER: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TIMEVNT1
                TIMEVNT1: u1,
                ///  TIMEVNT2
                TIMEVNT2: u1,
                ///  TIMEVNT3
                TIMEVNT3: u1,
                ///  TIMEVNT4
                TIMEVNT4: u1,
                ///  TIMEVNT5
                TIMEVNT5: u1,
                ///  TIMEVNT6
                TIMEVNT6: u1,
                ///  TIMEVNT7
                TIMEVNT7: u1,
                ///  TIMEVNT8
                TIMEVNT8: u1,
                ///  TIMEVNT9
                TIMEVNT9: u1,
                ///  EXTEVNT1
                EXTEVNT1: u1,
                ///  EXTEVNT2
                EXTEVNT2: u1,
                ///  EXTEVNT3
                EXTEVNT3: u1,
                ///  EXTEVNT4
                EXTEVNT4: u1,
                ///  EXTEVNT5
                EXTEVNT5: u1,
                ///  EXTEVNT6
                EXTEVNT6: u1,
                ///  EXTEVNT7
                EXTEVNT7: u1,
                ///  EXTEVNT8
                EXTEVNT8: u1,
                ///  EXTEVNT9
                EXTEVNT9: u1,
                ///  EXTEVNT10
                EXTEVNT10: u1,
                ///  UPDATE
                UPDATE: u1,
            }),
            ///  Timerx External Event Filtering Register 1
            EEFER1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 latch
                EE1LTCH: u1,
                ///  External Event 1 filter
                EE1FLTR: u4,
                reserved6: u1,
                ///  External Event 2 latch
                EE2LTCH: u1,
                ///  External Event 2 filter
                EE2FLTR: u4,
                reserved12: u1,
                ///  External Event 3 latch
                EE3LTCH: u1,
                ///  External Event 3 filter
                EE3FLTR: u4,
                reserved18: u1,
                ///  External Event 4 latch
                EE4LTCH: u1,
                ///  External Event 4 filter
                EE4FLTR: u4,
                reserved24: u1,
                ///  External Event 5 latch
                EE5LTCH: u1,
                ///  External Event 5 filter
                EE5FLTR: u4,
                padding: u3,
            }),
            ///  Timerx External Event Filtering Register 2
            EEFER2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 latch
                EE6LTCH: u1,
                ///  External Event 6 filter
                EE6FLTR: u4,
                reserved6: u1,
                ///  External Event 7 latch
                EE7LTCH: u1,
                ///  External Event 7 filter
                EE7FLTR: u4,
                reserved12: u1,
                ///  External Event 8 latch
                EE8LTCH: u1,
                ///  External Event 8 filter
                EE8FLTR: u4,
                reserved18: u1,
                ///  External Event 9 latch
                EE9LTCH: u1,
                ///  External Event 9 filter
                EE9FLTR: u4,
                reserved24: u1,
                ///  External Event 10 latch
                EE10LTCH: u1,
                ///  External Event 10 filter
                EE10FLTR: u4,
                padding: u3,
            }),
            ///  TimerA Reset Register
            RSTER: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Timer A Update reset
                UPDT: u1,
                ///  Timer A compare 2 reset
                CMP2: u1,
                ///  Timer A compare 4 reset
                CMP4: u1,
                ///  Master timer Period
                MSTPER: u1,
                ///  Master compare 1
                MSTCMP1: u1,
                ///  Master compare 2
                MSTCMP2: u1,
                ///  Master compare 3
                MSTCMP3: u1,
                ///  Master compare 4
                MSTCMP4: u1,
                ///  External Event 1
                EXTEVNT1: u1,
                ///  External Event 2
                EXTEVNT2: u1,
                ///  External Event 3
                EXTEVNT3: u1,
                ///  External Event 4
                EXTEVNT4: u1,
                ///  External Event 5
                EXTEVNT5: u1,
                ///  External Event 6
                EXTEVNT6: u1,
                ///  External Event 7
                EXTEVNT7: u1,
                ///  External Event 8
                EXTEVNT8: u1,
                ///  External Event 9
                EXTEVNT9: u1,
                ///  External Event 10
                EXTEVNT10: u1,
                ///  Timer A Compare 1
                TIMACMP1: u1,
                ///  Timer A Compare 2
                TIMACMP2: u1,
                ///  Timer A Compare 4
                TIMACMP4: u1,
                ///  Timer B Compare 1
                TIMBCMP1: u1,
                ///  Timer B Compare 2
                TIMBCMP2: u1,
                ///  Timer B Compare 4
                TIMBCMP4: u1,
                ///  Timer C Compare 1
                TIMCCMP1: u1,
                ///  Timer C Compare 2
                TIMCCMP2: u1,
                ///  Timer C Compare 4
                TIMCCMP4: u1,
                ///  Timer D Compare 1
                TIMDCMP1: u1,
                ///  Timer D Compare 2
                TIMDCMP2: u1,
                ///  Timer D Compare 4
                TIMDCMP4: u1,
                padding: u1,
            }),
            ///  Timerx Chopper Register
            CHPER: mmio.Mmio(packed struct(u32) {
                ///  Timerx carrier frequency value
                CHPFRQ: u4,
                ///  Timerx chopper duty cycle value
                CHPDTY: u3,
                ///  STRTPW
                STRTPW: u4,
                padding: u21,
            }),
            ///  Timerx Capture 2 Control Register
            CPT1ECR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                padding: u4,
            }),
            ///  CPT2xCR
            CPT2ECR: mmio.Mmio(packed struct(u32) {
                ///  Software Capture
                SWCPT: u1,
                ///  Update Capture
                UDPCPT: u1,
                ///  External Event 1 Capture
                EXEV1CPT: u1,
                ///  External Event 2 Capture
                EXEV2CPT: u1,
                ///  External Event 3 Capture
                EXEV3CPT: u1,
                ///  External Event 4 Capture
                EXEV4CPT: u1,
                ///  External Event 5 Capture
                EXEV5CPT: u1,
                ///  External Event 6 Capture
                EXEV6CPT: u1,
                ///  External Event 7 Capture
                EXEV7CPT: u1,
                ///  External Event 8 Capture
                EXEV8CPT: u1,
                ///  External Event 9 Capture
                EXEV9CPT: u1,
                ///  External Event 10 Capture
                EXEV10CPT: u1,
                ///  Timer A output 1 Set
                TA1SET: u1,
                ///  Timer A output 1 Reset
                TA1RST: u1,
                ///  Timer A Compare 1
                TACMP1: u1,
                ///  Timer A Compare 2
                TACMP2: u1,
                ///  Timer B output 1 Set
                TB1SET: u1,
                ///  Timer B output 1 Reset
                TB1RST: u1,
                ///  Timer B Compare 1
                TBCMP1: u1,
                ///  Timer B Compare 2
                TBCMP2: u1,
                ///  Timer C output 1 Set
                TC1SET: u1,
                ///  Timer C output 1 Reset
                TC1RST: u1,
                ///  Timer C Compare 1
                TCCMP1: u1,
                ///  Timer C Compare 2
                TCCMP2: u1,
                ///  Timer D output 1 Set
                TD1SET: u1,
                ///  Timer D output 1 Reset
                TD1RST: u1,
                ///  Timer D Compare 1
                TDCMP1: u1,
                ///  Timer D Compare 2
                TDCMP2: u1,
                padding: u4,
            }),
            ///  Timerx Output Register
            OUTER: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Output 1 polarity
                POL1: u1,
                ///  Output 1 Idle mode
                IDLEM1: u1,
                ///  Output 1 Idle State
                IDLES1: u1,
                ///  Output 1 Fault state
                FAULT1: u2,
                ///  Output 1 Chopper enable
                CHP1: u1,
                ///  Output 1 Deadtime upon burst mode Idle entry
                DIDL1: u1,
                ///  Deadtime enable
                DTEN: u1,
                ///  Delayed Protection Enable
                DLYPRTEN: u1,
                ///  Delayed Protection
                DLYPRT: u3,
                reserved17: u4,
                ///  Output 2 polarity
                POL2: u1,
                ///  Output 2 Idle mode
                IDLEM2: u1,
                ///  Output 2 Idle State
                IDLES2: u1,
                ///  Output 2 Fault state
                FAULT2: u2,
                ///  Output 2 Chopper enable
                CHP2: u1,
                ///  Output 2 Deadtime upon burst mode Idle entry
                DIDL2: u1,
                padding: u8,
            }),
            ///  Timerx Fault Register
            FLTER: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 enable
                FLT1EN: u1,
                ///  Fault 2 enable
                FLT2EN: u1,
                ///  Fault 3 enable
                FLT3EN: u1,
                ///  Fault 4 enable
                FLT4EN: u1,
                ///  Fault 5 enable
                FLT5EN: u1,
                reserved31: u26,
                ///  Fault sources Lock
                FLTLCK: u1,
            }),
        };

        ///  High Resolution Timer: Common functions
        pub const HRTIM_Common = extern struct {
            ///  Control Register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Master Update Disable
                MUDIS: u1,
                ///  Timer A Update Disable
                TAUDIS: u1,
                ///  Timer B Update Disable
                TBUDIS: u1,
                ///  Timer C Update Disable
                TCUDIS: u1,
                ///  Timer D Update Disable
                TDUDIS: u1,
                ///  Timer E Update Disable
                TEUDIS: u1,
                reserved16: u10,
                ///  ADC Trigger 1 Update Source
                AD1USRC: u3,
                ///  ADC Trigger 2 Update Source
                AD2USRC: u3,
                ///  ADC Trigger 3 Update Source
                AD3USRC: u3,
                ///  ADC Trigger 4 Update Source
                AD4USRC: u3,
                padding: u4,
            }),
            ///  Control Register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Master Timer Software update
                MSWU: u1,
                ///  Timer A Software update
                TASWU: u1,
                ///  Timer B Software Update
                TBSWU: u1,
                ///  Timer C Software Update
                TCSWU: u1,
                ///  Timer D Software Update
                TDSWU: u1,
                ///  Timer E Software Update
                TESWU: u1,
                reserved8: u2,
                ///  Master Counter software reset
                MRST: u1,
                ///  Timer A counter software reset
                TARST: u1,
                ///  Timer B counter software reset
                TBRST: u1,
                ///  Timer C counter software reset
                TCRST: u1,
                ///  Timer D counter software reset
                TDRST: u1,
                ///  Timer E counter software reset
                TERST: u1,
                padding: u18,
            }),
            ///  Interrupt Status Register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 Interrupt Flag
                FLT1: u1,
                ///  Fault 2 Interrupt Flag
                FLT2: u1,
                ///  Fault 3 Interrupt Flag
                FLT3: u1,
                ///  Fault 4 Interrupt Flag
                FLT4: u1,
                ///  Fault 5 Interrupt Flag
                FLT5: u1,
                ///  System Fault Interrupt Flag
                SYSFLT: u1,
                reserved16: u10,
                ///  DLL Ready Interrupt Flag
                DLLRDY: u1,
                ///  Burst mode Period Interrupt Flag
                BMPER: u1,
                padding: u14,
            }),
            ///  Interrupt Clear Register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 Interrupt Flag Clear
                FLT1C: u1,
                ///  Fault 2 Interrupt Flag Clear
                FLT2C: u1,
                ///  Fault 3 Interrupt Flag Clear
                FLT3C: u1,
                ///  Fault 4 Interrupt Flag Clear
                FLT4C: u1,
                ///  Fault 5 Interrupt Flag Clear
                FLT5C: u1,
                ///  System Fault Interrupt Flag Clear
                SYSFLTC: u1,
                reserved16: u10,
                ///  DLL Ready Interrupt flag Clear
                DLLRDYC: u1,
                ///  Burst mode period flag Clear
                BMPERC: u1,
                padding: u14,
            }),
            ///  Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Fault 1 Interrupt Enable
                FLT1IE: u1,
                ///  Fault 2 Interrupt Enable
                FLT2IE: u1,
                ///  Fault 3 Interrupt Enable
                FLT3IE: u1,
                ///  Fault 4 Interrupt Enable
                FLT4IE: u1,
                ///  Fault 5 Interrupt Enable
                FLT5IE: u1,
                ///  System Fault Interrupt Enable
                SYSFLTE: u1,
                reserved16: u10,
                ///  DLL Ready Interrupt Enable
                DLLRDYIE: u1,
                ///  Burst mode period Interrupt Enable
                BMPERIE: u1,
                padding: u14,
            }),
            ///  Output Enable Register
            OENR: mmio.Mmio(packed struct(u32) {
                ///  Timer A Output 1 Enable
                TA1OEN: u1,
                ///  Timer A Output 2 Enable
                TA2OEN: u1,
                ///  Timer B Output 1 Enable
                TB1OEN: u1,
                ///  Timer B Output 2 Enable
                TB2OEN: u1,
                ///  Timer C Output 1 Enable
                TC1OEN: u1,
                ///  Timer C Output 2 Enable
                TC2OEN: u1,
                ///  Timer D Output 1 Enable
                TD1OEN: u1,
                ///  Timer D Output 2 Enable
                TD2OEN: u1,
                ///  Timer E Output 1 Enable
                TE1OEN: u1,
                ///  Timer E Output 2 Enable
                TE2OEN: u1,
                padding: u22,
            }),
            ///  DISR
            DISR: mmio.Mmio(packed struct(u32) {
                ///  TA1ODIS
                TA1ODIS: u1,
                ///  TA2ODIS
                TA2ODIS: u1,
                ///  TB1ODIS
                TB1ODIS: u1,
                ///  TB2ODIS
                TB2ODIS: u1,
                ///  TC1ODIS
                TC1ODIS: u1,
                ///  TC2ODIS
                TC2ODIS: u1,
                ///  TD1ODIS
                TD1ODIS: u1,
                ///  TD2ODIS
                TD2ODIS: u1,
                ///  TE1ODIS
                TE1ODIS: u1,
                ///  TE2ODIS
                TE2ODIS: u1,
                padding: u22,
            }),
            ///  Output Disable Status Register
            ODSR: mmio.Mmio(packed struct(u32) {
                ///  Timer A Output 1 disable status
                TA1ODS: u1,
                ///  Timer A Output 2 disable status
                TA2ODS: u1,
                ///  Timer B Output 1 disable status
                TB1ODS: u1,
                ///  Timer B Output 2 disable status
                TB2ODS: u1,
                ///  Timer C Output 1 disable status
                TC1ODS: u1,
                ///  Timer C Output 2 disable status
                TC2ODS: u1,
                ///  Timer D Output 1 disable status
                TD1ODS: u1,
                ///  Timer D Output 2 disable status
                TD2ODS: u1,
                ///  Timer E Output 1 disable status
                TE1ODS: u1,
                ///  Timer E Output 2 disable status
                TE2ODS: u1,
                padding: u22,
            }),
            ///  Burst Mode Control Register
            BMCR: mmio.Mmio(packed struct(u32) {
                ///  Burst Mode enable
                BME: u1,
                ///  Burst Mode operating mode
                BMOM: u1,
                ///  Burst Mode Clock source
                BMCLK: u4,
                ///  Burst Mode Prescaler
                BMPRSC: u4,
                ///  Burst Mode Preload Enable
                BMPREN: u1,
                reserved16: u5,
                ///  Master Timer Burst Mode
                MTBM: u1,
                ///  Timer A Burst Mode
                TABM: u1,
                ///  Timer B Burst Mode
                TBBM: u1,
                ///  Timer C Burst Mode
                TCBM: u1,
                ///  Timer D Burst Mode
                TDBM: u1,
                ///  Timer E Burst Mode
                TEBM: u1,
                reserved31: u9,
                ///  Burst Mode Status
                BMSTAT: u1,
            }),
            ///  BMTRG
            BMTRG: mmio.Mmio(packed struct(u32) {
                ///  SW
                SW: u1,
                ///  MSTRST
                MSTRST: u1,
                ///  MSTREP
                MSTREP: u1,
                ///  MSTCMP1
                MSTCMP1: u1,
                ///  MSTCMP2
                MSTCMP2: u1,
                ///  MSTCMP3
                MSTCMP3: u1,
                ///  MSTCMP4
                MSTCMP4: u1,
                ///  TARST
                TARST: u1,
                ///  TAREP
                TAREP: u1,
                ///  TACMP1
                TACMP1: u1,
                ///  TACMP2
                TACMP2: u1,
                ///  TBRST
                TBRST: u1,
                ///  TBREP
                TBREP: u1,
                ///  TBCMP1
                TBCMP1: u1,
                ///  TBCMP2
                TBCMP2: u1,
                ///  TCRST
                TCRST: u1,
                ///  TCREP
                TCREP: u1,
                ///  TCCMP1
                TCCMP1: u1,
                ///  TCCMP2
                TCCMP2: u1,
                ///  TDRST
                TDRST: u1,
                ///  TDREP
                TDREP: u1,
                ///  TDCMP1
                TDCMP1: u1,
                ///  TDCMP2
                TDCMP2: u1,
                ///  TERST
                TERST: u1,
                ///  TEREP
                TEREP: u1,
                ///  TECMP1
                TECMP1: u1,
                ///  TECMP2
                TECMP2: u1,
                reserved31: u4,
                ///  OCHPEV
                OCHPEV: u1,
            }),
            ///  BMCMPR6
            BMCMPR6: mmio.Mmio(packed struct(u32) {
                ///  BMCMP
                BMCMP: u16,
                padding: u16,
            }),
            ///  Burst Mode Period Register
            BMPER: mmio.Mmio(packed struct(u32) {
                ///  Burst mode Period
                BMPER: u16,
                padding: u16,
            }),
            ///  Timer External Event Control Register 1
            EECR1: mmio.Mmio(packed struct(u32) {
                ///  External Event 1 Source
                EE1SRC: u2,
                ///  External Event 1 Polarity
                EE1POL: u1,
                ///  External Event 1 Sensitivity
                EE1SNS: u2,
                ///  External Event 1 Fast mode
                EE1FAST: u1,
                ///  External Event 2 Source
                EE2SRC: u2,
                ///  External Event 2 Polarity
                EE2POL: u1,
                ///  External Event 2 Sensitivity
                EE2SNS: u2,
                ///  External Event 2 Fast mode
                EE2FAST: u1,
                ///  External Event 3 Source
                EE3SRC: u2,
                ///  External Event 3 Polarity
                EE3POL: u1,
                ///  External Event 3 Sensitivity
                EE3SNS: u2,
                ///  External Event 3 Fast mode
                EE3FAST: u1,
                ///  External Event 4 Source
                EE4SRC: u2,
                ///  External Event 4 Polarity
                EE4POL: u1,
                ///  External Event 4 Sensitivity
                EE4SNS: u2,
                ///  External Event 4 Fast mode
                EE4FAST: u1,
                ///  External Event 5 Source
                EE5SRC: u2,
                ///  External Event 5 Polarity
                EE5POL: u1,
                ///  External Event 5 Sensitivity
                EE5SNS: u2,
                ///  External Event 5 Fast mode
                EE5FAST: u1,
                padding: u2,
            }),
            ///  Timer External Event Control Register 2
            EECR2: mmio.Mmio(packed struct(u32) {
                ///  External Event 6 Source
                EE6SRC: u2,
                ///  External Event 6 Polarity
                EE6POL: u1,
                ///  External Event 6 Sensitivity
                EE6SNS: u2,
                reserved6: u1,
                ///  External Event 7 Source
                EE7SRC: u2,
                ///  External Event 7 Polarity
                EE7POL: u1,
                ///  External Event 7 Sensitivity
                EE7SNS: u2,
                reserved12: u1,
                ///  External Event 8 Source
                EE8SRC: u2,
                ///  External Event 8 Polarity
                EE8POL: u1,
                ///  External Event 8 Sensitivity
                EE8SNS: u2,
                reserved18: u1,
                ///  External Event 9 Source
                EE9SRC: u2,
                ///  External Event 9 Polarity
                EE9POL: u1,
                ///  External Event 9 Sensitivity
                EE9SNS: u2,
                reserved24: u1,
                ///  External Event 10 Source
                EE10SRC: u2,
                ///  External Event 10 Polarity
                EE10POL: u1,
                ///  External Event 10 Sensitivity
                EE10SNS: u2,
                padding: u3,
            }),
            ///  Timer External Event Control Register 3
            EECR3: mmio.Mmio(packed struct(u32) {
                ///  EE6SRC
                EE6SRC: u2,
                ///  EE6POL
                EE6POL: u1,
                ///  EE6SNS
                EE6SNS: u2,
                reserved6: u1,
                ///  EE7SRC
                EE7SRC: u2,
                ///  EE7POL
                EE7POL: u1,
                ///  EE7SNS
                EE7SNS: u2,
                reserved12: u1,
                ///  EE8SRC
                EE8SRC: u2,
                ///  EE8POL
                EE8POL: u1,
                ///  EE8SNS
                EE8SNS: u2,
                reserved18: u1,
                ///  EE9SRC
                EE9SRC: u2,
                ///  EE9POL
                EE9POL: u1,
                ///  EE9SNS
                EE9SNS: u2,
                reserved24: u1,
                ///  EE10SRC
                EE10SRC: u2,
                ///  EE10POL
                EE10POL: u1,
                ///  EE10SNS
                EE10SNS: u2,
                padding: u3,
            }),
            ///  ADC Trigger 1 Register
            ADC1R: mmio.Mmio(packed struct(u32) {
                ///  ADC trigger 1 on Master Compare 1
                AD1MC1: u1,
                ///  ADC trigger 1 on Master Compare 2
                AD1MC2: u1,
                ///  ADC trigger 1 on Master Compare 3
                AD1MC3: u1,
                ///  ADC trigger 1 on Master Compare 4
                AD1MC4: u1,
                ///  ADC trigger 1 on Master Period
                AD1MPER: u1,
                ///  ADC trigger 1 on External Event 1
                AD1EEV1: u1,
                ///  ADC trigger 1 on External Event 2
                AD1EEV2: u1,
                ///  ADC trigger 1 on External Event 3
                AD1EEV3: u1,
                ///  ADC trigger 1 on External Event 4
                AD1EEV4: u1,
                ///  ADC trigger 1 on External Event 5
                AD1EEV5: u1,
                ///  ADC trigger 1 on Timer A compare 2
                AD1TAC2: u1,
                ///  ADC trigger 1 on Timer A compare 3
                AD1TAC3: u1,
                ///  ADC trigger 1 on Timer A compare 4
                AD1TAC4: u1,
                ///  ADC trigger 1 on Timer A Period
                AD1TAPER: u1,
                ///  ADC trigger 1 on Timer A Reset
                AD1TARST: u1,
                ///  ADC trigger 1 on Timer B compare 2
                AD1TBC2: u1,
                ///  ADC trigger 1 on Timer B compare 3
                AD1TBC3: u1,
                ///  ADC trigger 1 on Timer B compare 4
                AD1TBC4: u1,
                ///  ADC trigger 1 on Timer B Period
                AD1TBPER: u1,
                ///  ADC trigger 1 on Timer B Reset
                AD1TBRST: u1,
                ///  ADC trigger 1 on Timer C compare 2
                AD1TCC2: u1,
                ///  ADC trigger 1 on Timer C compare 3
                AD1TCC3: u1,
                ///  ADC trigger 1 on Timer C compare 4
                AD1TCC4: u1,
                ///  ADC trigger 1 on Timer C Period
                AD1TCPER: u1,
                ///  ADC trigger 1 on Timer D compare 2
                AD1TDC2: u1,
                ///  ADC trigger 1 on Timer D compare 3
                AD1TDC3: u1,
                ///  ADC trigger 1 on Timer D compare 4
                AD1TDC4: u1,
                ///  ADC trigger 1 on Timer D Period
                AD1TDPER: u1,
                ///  ADC trigger 1 on Timer E compare 2
                AD1TEC2: u1,
                ///  ADC trigger 1 on Timer E compare 3
                AD1TEC3: u1,
                ///  ADC trigger 1 on Timer E compare 4
                AD1TEC4: u1,
                ///  ADC trigger 1 on Timer E Period
                AD1TEPER: u1,
            }),
            ///  ADC Trigger 2 Register
            ADC2R: mmio.Mmio(packed struct(u32) {
                ///  ADC trigger 2 on Master Compare 1
                AD2MC1: u1,
                ///  ADC trigger 2 on Master Compare 2
                AD2MC2: u1,
                ///  ADC trigger 2 on Master Compare 3
                AD2MC3: u1,
                ///  ADC trigger 2 on Master Compare 4
                AD2MC4: u1,
                ///  ADC trigger 2 on Master Period
                AD2MPER: u1,
                ///  ADC trigger 2 on External Event 6
                AD2EEV6: u1,
                ///  ADC trigger 2 on External Event 7
                AD2EEV7: u1,
                ///  ADC trigger 2 on External Event 8
                AD2EEV8: u1,
                ///  ADC trigger 2 on External Event 9
                AD2EEV9: u1,
                ///  ADC trigger 2 on External Event 10
                AD2EEV10: u1,
                ///  ADC trigger 2 on Timer A compare 2
                AD2TAC2: u1,
                ///  ADC trigger 2 on Timer A compare 3
                AD2TAC3: u1,
                ///  ADC trigger 2 on Timer A compare 4
                AD2TAC4: u1,
                ///  ADC trigger 2 on Timer A Period
                AD2TAPER: u1,
                ///  ADC trigger 2 on Timer B compare 2
                AD2TBC2: u1,
                ///  ADC trigger 2 on Timer B compare 3
                AD2TBC3: u1,
                ///  ADC trigger 2 on Timer B compare 4
                AD2TBC4: u1,
                ///  ADC trigger 2 on Timer B Period
                AD2TBPER: u1,
                ///  ADC trigger 2 on Timer C compare 2
                AD2TCC2: u1,
                ///  ADC trigger 2 on Timer C compare 3
                AD2TCC3: u1,
                ///  ADC trigger 2 on Timer C compare 4
                AD2TCC4: u1,
                ///  ADC trigger 2 on Timer C Period
                AD2TCPER: u1,
                ///  ADC trigger 2 on Timer C Reset
                AD2TCRST: u1,
                ///  ADC trigger 2 on Timer D compare 2
                AD2TDC2: u1,
                ///  ADC trigger 2 on Timer D compare 3
                AD2TDC3: u1,
                ///  ADC trigger 2 on Timer D compare 4
                AD2TDC4: u1,
                ///  ADC trigger 2 on Timer D Period
                AD2TDPER: u1,
                ///  ADC trigger 2 on Timer D Reset
                AD2TDRST: u1,
                ///  ADC trigger 2 on Timer E compare 2
                AD2TEC2: u1,
                ///  ADC trigger 2 on Timer E compare 3
                AD2TEC3: u1,
                ///  ADC trigger 2 on Timer E compare 4
                AD2TEC4: u1,
                ///  ADC trigger 2 on Timer E Reset
                AD2TERST: u1,
            }),
            ///  ADC Trigger 3 Register
            ADC3R: mmio.Mmio(packed struct(u32) {
                ///  AD1MC1
                AD1MC1: u1,
                ///  AD1MC2
                AD1MC2: u1,
                ///  AD1MC3
                AD1MC3: u1,
                ///  AD1MC4
                AD1MC4: u1,
                ///  AD1MPER
                AD1MPER: u1,
                ///  AD1EEV1
                AD1EEV1: u1,
                ///  AD1EEV2
                AD1EEV2: u1,
                ///  AD1EEV3
                AD1EEV3: u1,
                ///  AD1EEV4
                AD1EEV4: u1,
                ///  AD1EEV5
                AD1EEV5: u1,
                ///  AD1TAC2
                AD1TAC2: u1,
                ///  AD1TAC3
                AD1TAC3: u1,
                ///  AD1TAC4
                AD1TAC4: u1,
                ///  AD1TAPER
                AD1TAPER: u1,
                ///  AD1TARST
                AD1TARST: u1,
                ///  AD1TBC2
                AD1TBC2: u1,
                ///  AD1TBC3
                AD1TBC3: u1,
                ///  AD1TBC4
                AD1TBC4: u1,
                ///  AD1TBPER
                AD1TBPER: u1,
                ///  AD1TBRST
                AD1TBRST: u1,
                ///  AD1TCC2
                AD1TCC2: u1,
                ///  AD1TCC3
                AD1TCC3: u1,
                ///  AD1TCC4
                AD1TCC4: u1,
                ///  AD1TCPER
                AD1TCPER: u1,
                ///  AD1TDC2
                AD1TDC2: u1,
                ///  AD1TDC3
                AD1TDC3: u1,
                ///  AD1TDC4
                AD1TDC4: u1,
                ///  AD1TDPER
                AD1TDPER: u1,
                ///  AD1TEC2
                AD1TEC2: u1,
                ///  AD1TEC3
                AD1TEC3: u1,
                ///  AD1TEC4
                AD1TEC4: u1,
                ///  AD1TEPER
                AD1TEPER: u1,
            }),
            ///  ADC Trigger 4 Register
            ADC4R: mmio.Mmio(packed struct(u32) {
                ///  AD2MC1
                AD2MC1: u1,
                ///  AD2MC2
                AD2MC2: u1,
                ///  AD2MC3
                AD2MC3: u1,
                ///  AD2MC4
                AD2MC4: u1,
                ///  AD2MPER
                AD2MPER: u1,
                ///  AD2EEV6
                AD2EEV6: u1,
                ///  AD2EEV7
                AD2EEV7: u1,
                ///  AD2EEV8
                AD2EEV8: u1,
                ///  AD2EEV9
                AD2EEV9: u1,
                ///  AD2EEV10
                AD2EEV10: u1,
                ///  AD2TAC2
                AD2TAC2: u1,
                ///  AD2TAC3
                AD2TAC3: u1,
                ///  AD2TAC4
                AD2TAC4: u1,
                ///  AD2TAPER
                AD2TAPER: u1,
                ///  AD2TBC2
                AD2TBC2: u1,
                ///  AD2TBC3
                AD2TBC3: u1,
                ///  AD2TBC4
                AD2TBC4: u1,
                ///  AD2TBPER
                AD2TBPER: u1,
                ///  AD2TCC2
                AD2TCC2: u1,
                ///  AD2TCC3
                AD2TCC3: u1,
                ///  AD2TCC4
                AD2TCC4: u1,
                ///  AD2TCPER
                AD2TCPER: u1,
                ///  AD2TCRST
                AD2TCRST: u1,
                ///  AD2TDC2
                AD2TDC2: u1,
                ///  AD2TDC3
                AD2TDC3: u1,
                ///  AD2TDC4
                AD2TDC4: u1,
                ///  AD2TDPER
                AD2TDPER: u1,
                ///  AD2TDRST
                AD2TDRST: u1,
                ///  AD2TEC2
                AD2TEC2: u1,
                ///  AD2TEC3
                AD2TEC3: u1,
                ///  AD2TEC4
                AD2TEC4: u1,
                ///  AD2TERST
                AD2TERST: u1,
            }),
            ///  DLL Control Register
            DLLCR: mmio.Mmio(packed struct(u32) {
                ///  DLL Calibration Start
                CAL: u1,
                ///  DLL Calibration Enable
                CALEN: u1,
                ///  DLL Calibration rate
                CALRTE: u2,
                padding: u28,
            }),
            ///  HRTIM Fault Input Register 1
            FLTINR1: mmio.Mmio(packed struct(u32) {
                ///  FLT1E
                FLT1E: u1,
                ///  FLT1P
                FLT1P: u1,
                ///  FLT1SRC
                FLT1SRC: u1,
                ///  FLT1F
                FLT1F: u4,
                ///  FLT1LCK
                FLT1LCK: u1,
                ///  FLT2E
                FLT2E: u1,
                ///  FLT2P
                FLT2P: u1,
                ///  FLT2SRC
                FLT2SRC: u1,
                ///  FLT2F
                FLT2F: u4,
                ///  FLT2LCK
                FLT2LCK: u1,
                ///  FLT3E
                FLT3E: u1,
                ///  FLT3P
                FLT3P: u1,
                ///  FLT3SRC
                FLT3SRC: u1,
                ///  FLT3F
                FLT3F: u4,
                ///  FLT3LCK
                FLT3LCK: u1,
                ///  FLT4E
                FLT4E: u1,
                ///  FLT4P
                FLT4P: u1,
                ///  FLT4SRC
                FLT4SRC: u1,
                ///  FLT4F
                FLT4F: u4,
                ///  FLT4LCK
                FLT4LCK: u1,
            }),
            ///  HRTIM Fault Input Register 2
            FLTINR2: mmio.Mmio(packed struct(u32) {
                ///  FLT5E
                FLT5E: u1,
                ///  FLT5P
                FLT5P: u1,
                ///  FLT5SRC
                FLT5SRC: u1,
                ///  FLT5F
                FLT5F: u4,
                ///  FLT5LCK
                FLT5LCK: u1,
                reserved24: u16,
                ///  FLTSD
                FLTSD: u2,
                padding: u6,
            }),
            ///  BDMUPDR
            BDMUPDR: mmio.Mmio(packed struct(u32) {
                ///  MCR
                MCR: u1,
                ///  MICR
                MICR: u1,
                ///  MDIER
                MDIER: u1,
                ///  MCNT
                MCNT: u1,
                ///  MPER
                MPER: u1,
                ///  MREP
                MREP: u1,
                ///  MCMP1
                MCMP1: u1,
                ///  MCMP2
                MCMP2: u1,
                ///  MCMP3
                MCMP3: u1,
                ///  MCMP4
                MCMP4: u1,
                padding: u22,
            }),
            ///  Burst DMA Timerx update Register
            BDTxUPR: mmio.Mmio(packed struct(u32) {
                ///  HRTIM_TIMxCR register update enable
                TIMxCR: u1,
                ///  HRTIM_TIMxICR register update enable
                TIMxICR: u1,
                ///  HRTIM_TIMxDIER register update enable
                TIMxDIER: u1,
                ///  HRTIM_CNTxR register update enable
                TIMxCNT: u1,
                ///  HRTIM_PERxR register update enable
                TIMxPER: u1,
                ///  HRTIM_REPxR register update enable
                TIMxREP: u1,
                ///  HRTIM_CMP1xR register update enable
                TIMxCMP1: u1,
                ///  HRTIM_CMP2xR register update enable
                TIMxCMP2: u1,
                ///  HRTIM_CMP3xR register update enable
                TIMxCMP3: u1,
                ///  HRTIM_CMP4xR register update enable
                TIMxCMP4: u1,
                ///  HRTIM_DTxR register update enable
                TIMx_DTxR: u1,
                ///  HRTIM_SET1xR register update enable
                TIMxSET1R: u1,
                ///  HRTIM_RST1xR register update enable
                TIMxRST1R: u1,
                ///  HRTIM_SET2xR register update enable
                TIMxSET2R: u1,
                ///  HRTIM_RST2xR register update enable
                TIMxRST2R: u1,
                ///  HRTIM_EEFxR1 register update enable
                TIMxEEFR1: u1,
                ///  HRTIM_EEFxR2 register update enable
                TIMxEEFR2: u1,
                ///  HRTIM_RSTxR register update enable
                TIMxRSTR: u1,
                ///  HRTIM_CHPxR register update enable
                TIMxCHPR: u1,
                ///  HRTIM_OUTxR register update enable
                TIMxOUTR: u1,
                ///  HRTIM_FLTxR register update enable
                TIMxFLTR: u1,
                padding: u11,
            }),
            ///  Burst DMA Data Register
            BDMADR: mmio.Mmio(packed struct(u32) {
                ///  Burst DMA Data register
                BDMADR: u32,
            }),
        };

        ///  Flash
        pub const Flash = extern struct {
            ///  Access control register
            ACR: mmio.Mmio(packed struct(u32) {
                ///  Read latency
                LATENCY: u3,
                reserved4: u1,
                ///  Flash signal delay
                WRHIGHFREQ: u2,
                padding: u26,
            }),
            ///  FLASH key register for bank 1
            KEYR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 access configuration unlock key
                KEYR1: u32,
            }),
            ///  FLASH option key register
            OPTKEYR: mmio.Mmio(packed struct(u32) {
                ///  Unlock key option bytes
                OPTKEYR: u32,
            }),
            ///  FLASH control register for bank 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 configuration lock bit
                LOCK1: u1,
                ///  Bank 1 program enable bit
                PG1: u1,
                ///  Bank 1 sector erase request
                SER1: u1,
                ///  Bank 1 erase request
                BER1: u1,
                ///  Bank 1 program size
                PSIZE1: u2,
                ///  Bank 1 write forcing control bit
                FW1: u1,
                ///  Bank 1 bank or sector erase start control bit
                START1: u1,
                ///  Bank 1 sector erase selection number
                SNB1: u3,
                reserved15: u4,
                ///  Bank 1 CRC control bit
                CRC_EN: u1,
                ///  Bank 1 end-of-program interrupt control bit
                EOPIE1: u1,
                ///  Bank 1 write protection error interrupt enable bit
                WRPERRIE1: u1,
                ///  Bank 1 programming sequence error interrupt enable bit
                PGSERRIE1: u1,
                ///  Bank 1 strobe error interrupt enable bit
                STRBERRIE1: u1,
                reserved21: u1,
                ///  Bank 1 inconsistency error interrupt enable bit
                INCERRIE1: u1,
                ///  Bank 1 write/erase error interrupt enable bit
                OPERRIE1: u1,
                ///  Bank 1 read protection error interrupt enable bit
                RDPERRIE1: u1,
                ///  Bank 1 secure error interrupt enable bit
                RDSERRIE1: u1,
                ///  Bank 1 ECC single correction error interrupt enable bit
                SNECCERRIE1: u1,
                ///  Bank 1 ECC double detection error interrupt enable bit
                DBECCERRIE1: u1,
                ///  Bank 1 end of CRC calculation interrupt enable bit
                CRCENDIE1: u1,
                padding: u4,
            }),
            ///  FLASH status register for bank 1
            SR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 ongoing program flag
                BSY1: u1,
                ///  Bank 1 write buffer not empty flag
                WBNE1: u1,
                ///  Bank 1 wait queue flag
                QW1: u1,
                ///  Bank 1 CRC busy flag
                CRC_BUSY1: u1,
                reserved16: u12,
                ///  Bank 1 end-of-program flag
                EOP1: u1,
                ///  Bank 1 write protection error flag
                WRPERR1: u1,
                ///  Bank 1 programming sequence error flag
                PGSERR1: u1,
                ///  Bank 1 strobe error flag
                STRBERR1: u1,
                reserved21: u1,
                ///  Bank 1 inconsistency error flag
                INCERR1: u1,
                ///  Bank 1 write/erase error flag
                OPERR1: u1,
                ///  Bank 1 read protection error flag
                RDPERR1: u1,
                ///  Bank 1 secure error flag
                RDSERR1: u1,
                ///  Bank 1 single correction error flag
                SNECCERR11: u1,
                ///  Bank 1 ECC double detection error flag
                DBECCERR1: u1,
                ///  Bank 1 CRC-complete flag
                CRCEND1: u1,
                padding: u4,
            }),
            ///  FLASH clear control register for bank 1
            CCR1: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Bank 1 EOP1 flag clear bit
                CLR_EOP1: u1,
                ///  Bank 1 WRPERR1 flag clear bit
                CLR_WRPERR1: u1,
                ///  Bank 1 PGSERR1 flag clear bi
                CLR_PGSERR1: u1,
                ///  Bank 1 STRBERR1 flag clear bit
                CLR_STRBERR1: u1,
                reserved21: u1,
                ///  Bank 1 INCERR1 flag clear bit
                CLR_INCERR1: u1,
                ///  Bank 1 OPERR1 flag clear bit
                CLR_OPERR1: u1,
                ///  Bank 1 RDPERR1 flag clear bit
                CLR_RDPERR1: u1,
                ///  Bank 1 RDSERR1 flag clear bit
                CLR_RDSERR1: u1,
                ///  Bank 1 SNECCERR1 flag clear bit
                CLR_SNECCERR1: u1,
                ///  Bank 1 DBECCERR1 flag clear bit
                CLR_DBECCERR1: u1,
                ///  Bank 1 CRCEND1 flag clear bit
                CLR_CRCEND1: u1,
                padding: u4,
            }),
            ///  FLASH option control register
            OPTCR: mmio.Mmio(packed struct(u32) {
                ///  FLASH_OPTCR lock option configuration bit
                OPTLOCK: u1,
                ///  Option byte start change option configuration bit
                OPTSTART: u1,
                reserved4: u2,
                ///  Flash mass erase enable bit
                MER: u1,
                reserved30: u25,
                ///  Option byte change error interrupt enable bit
                OPTCHANGEERRIE: u1,
                ///  Bank swapping configuration bit
                SWAP_BANK: u1,
            }),
            ///  FLASH option status register
            OPTSR_CUR: mmio.Mmio(packed struct(u32) {
                ///  Option byte change ongoing flag
                OPT_BUSY: u1,
                reserved2: u1,
                ///  Brownout level option status bit
                BOR_LEV: u2,
                ///  IWDG1 control option status bit
                IWDG1_HW: u1,
                reserved6: u1,
                ///  D1 DStop entry reset option status bit
                nRST_STOP_D1: u1,
                ///  D1 DStandby entry reset option status bit
                nRST_STBY_D1: u1,
                ///  Readout protection level option status byte
                RDP: u8,
                reserved17: u1,
                ///  IWDG Stop mode freeze option status bit
                FZ_IWDG_STOP: u1,
                ///  IWDG Standby mode freeze option status bit
                FZ_IWDG_SDBY: u1,
                ///  DTCM RAM size option status
                ST_RAM_SIZE: u2,
                ///  Security enable option status bit
                SECURITY: u1,
                reserved26: u4,
                ///  User option bit 1
                RSS1: u1,
                reserved28: u1,
                ///  Device personalization status bit
                PERSO_OK: u1,
                ///  I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
                IO_HSLV: u1,
                ///  Option byte change error flag
                OPTCHANGEERR: u1,
                ///  Bank swapping option status bit
                SWAP_BANK_OPT: u1,
            }),
            ///  FLASH option status register
            OPTSR_PRG: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  BOR reset level option configuration bits
                BOR_LEV: u2,
                ///  IWDG1 option configuration bit
                IWDG1_HW: u1,
                reserved6: u1,
                ///  Option byte erase after D1 DStop option configuration bit
                nRST_STOP_D1: u1,
                ///  Option byte erase after D1 DStandby option configuration bit
                nRST_STBY_D1: u1,
                ///  Readout protection level option configuration byte
                RDP: u8,
                reserved17: u1,
                ///  IWDG Stop mode freeze option configuration bit
                FZ_IWDG_STOP: u1,
                ///  IWDG Standby mode freeze option configuration bit
                FZ_IWDG_SDBY: u1,
                ///  DTCM size select option configuration bits
                ST_RAM_SIZE: u2,
                ///  Security option configuration bit
                SECURITY: u1,
                reserved26: u4,
                ///  User option configuration bit 1
                RSS1: u1,
                ///  User option configuration bit 2
                RSS2: u1,
                reserved29: u1,
                ///  I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
                IO_HSLV: u1,
                reserved31: u1,
                ///  Bank swapping option configuration bit
                SWAP_BANK_OPT: u1,
            }),
            ///  FLASH option clear control register
            OPTCCR: mmio.Mmio(packed struct(u32) {
                reserved30: u30,
                ///  OPTCHANGEERR reset bit
                CLR_OPTCHANGEERR: u1,
                padding: u1,
            }),
            ///  FLASH protection address for bank 1
            PRAR_CUR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 lowest PCROP protected address
                PROT_AREA_START1: u12,
                reserved16: u4,
                ///  Bank 1 highest PCROP protected address
                PROT_AREA_END1: u12,
                reserved31: u3,
                ///  Bank 1 PCROP protected erase enable option status bit
                DMEP1: u1,
            }),
            ///  FLASH protection address for bank 1
            PRAR_PRG1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 lowest PCROP protected address configuration
                PROT_AREA_START1: u12,
                reserved16: u4,
                ///  Bank 1 highest PCROP protected address configuration
                PROT_AREA_END1: u12,
                reserved31: u3,
                ///  Bank 1 PCROP protected erase enable option configuration bit
                DMEP1: u1,
            }),
            ///  FLASH secure address for bank 1
            SCAR_CUR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 lowest secure protected address
                SEC_AREA_START1: u12,
                reserved16: u4,
                ///  Bank 1 highest secure protected address
                SEC_AREA_END1: u12,
                reserved31: u3,
                ///  Bank 1 secure protected erase enable option status bit
                DMES1: u1,
            }),
            ///  FLASH secure address for bank 1
            SCAR_PRG1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 lowest secure protected address configuration
                SEC_AREA_START1: u12,
                reserved16: u4,
                ///  Bank 1 highest secure protected address configuration
                SEC_AREA_END1: u12,
                reserved31: u3,
                ///  Bank 1 secure protected erase enable option configuration bit
                DMES1: u1,
            }),
            ///  FLASH write sector protection for bank 1
            WPSN_CUR1R: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 sector write protection option status byte
                WRPSn1: u8,
                padding: u24,
            }),
            ///  FLASH write sector protection for bank 1
            WPSN_PRG1R: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 sector write protection configuration byte
                WRPSn1: u8,
                padding: u24,
            }),
            ///  FLASH register with boot address
            BOOT_CURR: mmio.Mmio(packed struct(u32) {
                ///  Boot address 0
                BOOT_ADD0: u16,
                ///  Boot address 1
                BOOT_ADD1: u16,
            }),
            ///  FLASH register with boot address
            BOOT_PRGR: mmio.Mmio(packed struct(u32) {
                ///  Boot address 0
                BOOT_ADD0: u16,
                ///  Boot address 1
                BOOT_ADD1: u16,
            }),
            reserved80: [8]u8,
            ///  FLASH CRC control register for bank 1
            CRCCR1: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 CRC sector number
                CRC_SECT: u3,
                reserved7: u4,
                ///  Bank 1 CRC select bit
                ALL_BANK: u1,
                ///  Bank 1 CRC sector mode select bit
                CRC_BY_SECT: u1,
                ///  Bank 1 CRC sector select bit
                ADD_SECT: u1,
                ///  Bank 1 CRC sector list clear bit
                CLEAN_SECT: u1,
                reserved16: u5,
                ///  Bank 1 CRC start bit
                START_CRC: u1,
                ///  Bank 1 CRC clear bit
                CLEAN_CRC: u1,
                reserved20: u2,
                ///  Bank 1 CRC burst size
                CRC_BURST: u2,
                padding: u10,
            }),
            ///  FLASH CRC start address register for bank 1
            CRCSADD1R: mmio.Mmio(packed struct(u32) {
                ///  CRC start address on bank 1
                CRC_START_ADDR: u32,
            }),
            ///  FLASH CRC end address register for bank 1
            CRCEADD1R: mmio.Mmio(packed struct(u32) {
                ///  CRC end address on bank 1
                CRC_END_ADDR: u32,
            }),
            ///  FLASH CRC data register
            CRCDATAR: mmio.Mmio(packed struct(u32) {
                ///  CRC result
                CRC_DATA: u32,
            }),
            ///  FLASH ECC fail address for bank 1
            ECC_FA1R: mmio.Mmio(packed struct(u32) {
                ///  Bank 1 ECC error address
                FAIL_ECC_ADDR1: u15,
                padding: u17,
            }),
            reserved256: [156]u8,
            ///  Access control register
            ACR_: mmio.Mmio(packed struct(u32) {
                ///  Read latency
                LATENCY: u3,
                reserved4: u1,
                ///  Flash signal delay
                WRHIGHFREQ: u2,
                padding: u26,
            }),
            ///  FLASH key register for bank 2
            KEYR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 access configuration unlock key
                KEYR2: u32,
            }),
            ///  FLASH option key register
            OPTKEYR_: mmio.Mmio(packed struct(u32) {
                ///  Unlock key option bytes
                OPTKEYR: u32,
            }),
            ///  FLASH control register for bank 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 configuration lock bit
                LOCK2: u1,
                ///  Bank 2 program enable bit
                PG2: u1,
                ///  Bank 2 sector erase request
                SER2: u1,
                ///  Bank 2 erase request
                BER2: u1,
                ///  Bank 2 program size
                PSIZE2: u2,
                ///  Bank 2 write forcing control bit
                FW2: u1,
                ///  Bank 2 bank or sector erase start control bit
                START2: u1,
                ///  Bank 2 sector erase selection number
                SNB2: u3,
                reserved15: u4,
                ///  Bank 2 CRC control bit
                CRC_EN: u1,
                ///  Bank 2 end-of-program interrupt control bit
                EOPIE2: u1,
                ///  Bank 2 write protection error interrupt enable bit
                WRPERRIE2: u1,
                ///  Bank 2 programming sequence error interrupt enable bit
                PGSERRIE2: u1,
                ///  Bank 2 strobe error interrupt enable bit
                STRBERRIE2: u1,
                reserved21: u1,
                ///  Bank 2 inconsistency error interrupt enable bit
                INCERRIE2: u1,
                ///  Bank 2 write/erase error interrupt enable bit
                OPERRIE2: u1,
                ///  Bank 2 read protection error interrupt enable bit
                RDPERRIE2: u1,
                ///  Bank 2 secure error interrupt enable bit
                RDSERRIE2: u1,
                ///  Bank 2 ECC single correction error interrupt enable bit
                SNECCERRIE2: u1,
                ///  Bank 2 ECC double detection error interrupt enable bit
                DBECCERRIE2: u1,
                ///  Bank 2 end of CRC calculation interrupt enable bit
                CRCENDIE2: u1,
                padding: u4,
            }),
            ///  FLASH status register for bank 2
            SR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 ongoing program flag
                BSY2: u1,
                ///  Bank 2 write buffer not empty flag
                WBNE2: u1,
                ///  Bank 2 wait queue flag
                QW2: u1,
                ///  Bank 2 CRC busy flag
                CRC_BUSY2: u1,
                reserved16: u12,
                ///  Bank 2 end-of-program flag
                EOP2: u1,
                ///  Bank 2 write protection error flag
                WRPERR2: u1,
                ///  Bank 2 programming sequence error flag
                PGSERR2: u1,
                ///  Bank 2 strobe error flag
                STRBERR2: u1,
                reserved21: u1,
                ///  Bank 2 inconsistency error flag
                INCERR2: u1,
                ///  Bank 2 write/erase error flag
                OPERR2: u1,
                ///  Bank 2 read protection error flag
                RDPERR2: u1,
                ///  Bank 2 secure error flag
                RDSERR2: u1,
                ///  Bank 2 single correction error flag
                SNECCERR2: u1,
                ///  Bank 2 ECC double detection error flag
                DBECCERR2: u1,
                ///  Bank 2 CRC-complete flag
                CRCEND2: u1,
                padding: u4,
            }),
            ///  FLASH clear control register for bank 2
            CCR2: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  Bank 1 EOP1 flag clear bit
                CLR_EOP2: u1,
                ///  Bank 2 WRPERR1 flag clear bit
                CLR_WRPERR2: u1,
                ///  Bank 2 PGSERR1 flag clear bi
                CLR_PGSERR2: u1,
                ///  Bank 2 STRBERR1 flag clear bit
                CLR_STRBERR2: u1,
                reserved21: u1,
                ///  Bank 2 INCERR1 flag clear bit
                CLR_INCERR2: u1,
                ///  Bank 2 OPERR1 flag clear bit
                CLR_OPERR2: u1,
                ///  Bank 2 RDPERR1 flag clear bit
                CLR_RDPERR2: u1,
                ///  Bank 1 RDSERR1 flag clear bit
                CLR_RDSERR1: u1,
                ///  Bank 2 SNECCERR1 flag clear bit
                CLR_SNECCERR2: u1,
                ///  Bank 1 DBECCERR1 flag clear bit
                CLR_DBECCERR1: u1,
                ///  Bank 2 CRCEND1 flag clear bit
                CLR_CRCEND2: u1,
                padding: u4,
            }),
            ///  FLASH option control register
            OPTCR_: mmio.Mmio(packed struct(u32) {
                ///  FLASH_OPTCR lock option configuration bit
                OPTLOCK: u1,
                ///  Option byte start change option configuration bit
                OPTSTART: u1,
                reserved4: u2,
                ///  Flash mass erase enable bit
                MER: u1,
                reserved30: u25,
                ///  Option byte change error interrupt enable bit
                OPTCHANGEERRIE: u1,
                ///  Bank swapping configuration bit
                SWAP_BANK: u1,
            }),
            ///  FLASH option status register
            OPTSR_CUR_: mmio.Mmio(packed struct(u32) {
                ///  Option byte change ongoing flag
                OPT_BUSY: u1,
                reserved2: u1,
                ///  Brownout level option status bit
                BOR_LEV: u2,
                ///  IWDG1 control option status bit
                IWDG1_HW: u1,
                reserved6: u1,
                ///  D1 DStop entry reset option status bit
                nRST_STOP_D1: u1,
                ///  D1 DStandby entry reset option status bit
                nRST_STBY_D1: u1,
                ///  Readout protection level option status byte
                RDP: u8,
                reserved17: u1,
                ///  IWDG Stop mode freeze option status bit
                FZ_IWDG_STOP: u1,
                ///  IWDG Standby mode freeze option status bit
                FZ_IWDG_SDBY: u1,
                ///  DTCM RAM size option status
                ST_RAM_SIZE: u2,
                ///  Security enable option status bit
                SECURITY: u1,
                reserved26: u4,
                ///  User option bit 1
                RSS1: u1,
                reserved28: u1,
                ///  Device personalization status bit
                PERSO_OK: u1,
                ///  I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
                IO_HSLV: u1,
                ///  Option byte change error flag
                OPTCHANGEERR: u1,
                ///  Bank swapping option status bit
                SWAP_BANK_OPT: u1,
            }),
            ///  FLASH option status register
            OPTSR_PRG_: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  BOR reset level option configuration bits
                BOR_LEV: u2,
                ///  IWDG1 option configuration bit
                IWDG1_HW: u1,
                reserved6: u1,
                ///  Option byte erase after D1 DStop option configuration bit
                nRST_STOP_D1: u1,
                ///  Option byte erase after D1 DStandby option configuration bit
                nRST_STBY_D1: u1,
                ///  Readout protection level option configuration byte
                RDP: u8,
                reserved17: u1,
                ///  IWDG Stop mode freeze option configuration bit
                FZ_IWDG_STOP: u1,
                ///  IWDG Standby mode freeze option configuration bit
                FZ_IWDG_SDBY: u1,
                ///  DTCM size select option configuration bits
                ST_RAM_SIZE: u2,
                ///  Security option configuration bit
                SECURITY: u1,
                reserved26: u4,
                ///  User option configuration bit 1
                RSS1: u1,
                ///  User option configuration bit 2
                RSS2: u1,
                reserved29: u1,
                ///  I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
                IO_HSLV: u1,
                reserved31: u1,
                ///  Bank swapping option configuration bit
                SWAP_BANK_OPT: u1,
            }),
            ///  FLASH option clear control register
            OPTCCR_: mmio.Mmio(packed struct(u32) {
                reserved30: u30,
                ///  OPTCHANGEERR reset bit
                CLR_OPTCHANGEERR: u1,
                padding: u1,
            }),
            ///  FLASH protection address for bank 1
            PRAR_CUR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 lowest PCROP protected address
                PROT_AREA_START2: u12,
                reserved16: u4,
                ///  Bank 2 highest PCROP protected address
                PROT_AREA_END2: u12,
                reserved31: u3,
                ///  Bank 2 PCROP protected erase enable option status bit
                DMEP2: u1,
            }),
            reserved304: [4]u8,
            ///  FLASH secure address for bank 2
            SCAR_CUR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 lowest secure protected address
                SEC_AREA_START2: u12,
                reserved16: u4,
                ///  Bank 2 highest secure protected address
                SEC_AREA_END2: u12,
                reserved31: u3,
                ///  Bank 2 secure protected erase enable option status bit
                DMES2: u1,
            }),
            ///  FLASH secure address for bank 2
            SCAR_PRG2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 lowest secure protected address configuration
                SEC_AREA_START2: u12,
                reserved16: u4,
                ///  Bank 2 highest secure protected address configuration
                SEC_AREA_END2: u12,
                reserved31: u3,
                ///  Bank 2 secure protected erase enable option configuration bit
                DMES2: u1,
            }),
            ///  FLASH write sector protection for bank 2
            WPSN_CUR2R: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 sector write protection option status byte
                WRPSn2: u8,
                padding: u24,
            }),
            ///  FLASH write sector protection for bank 2
            WPSN_PRG2R: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 sector write protection configuration byte
                WRPSn2: u8,
                padding: u24,
            }),
            reserved336: [16]u8,
            ///  FLASH CRC control register for bank 1
            CRCCR2: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 CRC sector number
                CRC_SECT: u3,
                reserved7: u4,
                ///  Bank 2 CRC select bit
                ALL_BANK: u1,
                ///  Bank 2 CRC sector mode select bit
                CRC_BY_SECT: u1,
                ///  Bank 2 CRC sector select bit
                ADD_SECT: u1,
                ///  Bank 2 CRC sector list clear bit
                CLEAN_SECT: u1,
                reserved16: u5,
                ///  Bank 2 CRC start bit
                START_CRC: u1,
                ///  Bank 2 CRC clear bit
                CLEAN_CRC: u1,
                reserved20: u2,
                ///  Bank 2 CRC burst size
                CRC_BURST: u2,
                padding: u10,
            }),
            ///  FLASH CRC start address register for bank 2
            CRCSADD2R: mmio.Mmio(packed struct(u32) {
                ///  CRC start address on bank 2
                CRC_START_ADDR: u32,
            }),
            ///  FLASH CRC end address register for bank 2
            CRCEADD2R: mmio.Mmio(packed struct(u32) {
                ///  CRC end address on bank 2
                CRC_END_ADDR: u32,
            }),
            reserved352: [4]u8,
            ///  FLASH ECC fail address for bank 2
            ECC_FA2R: mmio.Mmio(packed struct(u32) {
                ///  Bank 2 ECC error address
                FAIL_ECC_ADDR2: u15,
                padding: u17,
            }),
        };

        ///  AXI interconnect registers
        pub const AXI = extern struct {
            reserved8144: [8144]u8,
            ///  AXI interconnect - peripheral ID4 register
            AXI_PERIPH_ID_4: mmio.Mmio(packed struct(u32) {
                ///  JEP106 continuation code
                JEP106CON: u4,
                ///  Register file size
                KCOUNT4: u4,
                padding: u24,
            }),
            reserved8160: [12]u8,
            ///  AXI interconnect - peripheral ID0 register
            AXI_PERIPH_ID_0: mmio.Mmio(packed struct(u32) {
                ///  Peripheral part number bits 0 to 7
                PARTNUM: u8,
                padding: u24,
            }),
            ///  AXI interconnect - peripheral ID1 register
            AXI_PERIPH_ID_1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral part number bits 8 to 11
                PARTNUM: u4,
                ///  JEP106 identity bits 0 to 3
                JEP106I: u4,
                padding: u24,
            }),
            ///  AXI interconnect - peripheral ID2 register
            AXI_PERIPH_ID_2: mmio.Mmio(packed struct(u32) {
                ///  JEP106 Identity bits 4 to 6
                JEP106ID: u3,
                ///  JEP106 code flag
                JEDEC: u1,
                ///  Peripheral revision number
                REVISION: u4,
                padding: u24,
            }),
            ///  AXI interconnect - peripheral ID3 register
            AXI_PERIPH_ID_3: mmio.Mmio(packed struct(u32) {
                ///  Customer modification
                CUST_MOD_NUM: u4,
                ///  Customer version
                REV_AND: u4,
                padding: u24,
            }),
            ///  AXI interconnect - component ID0 register
            AXI_COMP_ID_0: mmio.Mmio(packed struct(u32) {
                ///  Preamble bits 0 to 7
                PREAMBLE: u8,
                padding: u24,
            }),
            ///  AXI interconnect - component ID1 register
            AXI_COMP_ID_1: mmio.Mmio(packed struct(u32) {
                ///  Preamble bits 8 to 11
                PREAMBLE: u4,
                ///  Component class
                CLASS: u4,
                padding: u24,
            }),
            ///  AXI interconnect - component ID2 register
            AXI_COMP_ID_2: mmio.Mmio(packed struct(u32) {
                ///  Preamble bits 12 to 19
                PREAMBLE: u8,
                padding: u24,
            }),
            ///  AXI interconnect - component ID3 register
            AXI_COMP_ID_3: mmio.Mmio(packed struct(u32) {
                ///  Preamble bits 20 to 27
                PREAMBLE: u8,
                padding: u24,
            }),
            reserved8200: [8]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG1_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved8228: [24]u8,
            ///  AXI interconnect - TARG x bus matrix functionality 2 register
            AXI_TARG1_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  Disable packing of beats to match the output data width
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved8236: [4]u8,
            ///  AXI interconnect - TARG x long burst functionality modification
            AXI_TARG1_FN_MOD_LB: mmio.Mmio(packed struct(u32) {
                ///  Controls burst breaking of long bursts
                FN_MOD_LB: u1,
                padding: u31,
            }),
            reserved8456: [216]u8,
            ///  AXI interconnect - TARG x long burst functionality modification
            AXI_TARG1_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override AMIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override AMIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved12296: [3836]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG2_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved12324: [24]u8,
            ///  AXI interconnect - TARG x bus matrix functionality 2 register
            AXI_TARG2_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  Disable packing of beats to match the output data width
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved12332: [4]u8,
            ///  AXI interconnect - TARG x long burst functionality modification
            AXI_TARG2_FN_MOD_LB: mmio.Mmio(packed struct(u32) {
                ///  Controls burst breaking of long bursts
                FN_MOD_LB: u1,
                padding: u31,
            }),
            reserved12552: [216]u8,
            ///  AXI interconnect - TARG x long burst functionality modification
            AXI_TARG2_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override AMIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override AMIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved16392: [3836]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG3_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved20488: [4092]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG4_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved24584: [4092]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG5_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved28680: [4092]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG6_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved32780: [4096]u8,
            ///  AXI interconnect - TARG x bus matrix issuing functionality register
            AXI_TARG7_FN_MOD_ISS_BM: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  Switch matrix write issuing override for target
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved32804: [20]u8,
            ///  AXI interconnect - TARG x bus matrix functionality 2 register
            AXI_TARG7_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  Disable packing of beats to match the output data width
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved33032: [224]u8,
            ///  AXI interconnect - TARG x long burst functionality modification
            AXI_TARG7_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override AMIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override AMIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved270372: [237336]u8,
            ///  AXI interconnect - INI x functionality modification 2 register
            AXI_INI1_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  Disables alteration of transactions by the up-sizer unless required by the protocol
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            ///  AXI interconnect - INI x AHB functionality modification register
            AXI_INI1_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  Converts all AHB-Lite write transactions to a series of single beat AXI
                RD_INC_OVERRIDE: u1,
                ///  Converts all AHB-Lite read transactions to a series of single beat AXI
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved270592: [212]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI1_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI1_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI1_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved274688: [4084]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI2_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI2_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI2_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved278564: [3864]u8,
            ///  AXI interconnect - INI x functionality modification 2 register
            AXI_INI3_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  Disables alteration of transactions by the up-sizer unless required by the protocol
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            ///  AXI interconnect - INI x AHB functionality modification register
            AXI_INI3_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  Converts all AHB-Lite write transactions to a series of single beat AXI
                RD_INC_OVERRIDE: u1,
                ///  Converts all AHB-Lite read transactions to a series of single beat AXI
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved278784: [212]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI3_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI3_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI3_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved282880: [4084]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI4_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI4_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI4_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved286976: [4084]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI5_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI5_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI5_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved291072: [4084]u8,
            ///  AXI interconnect - INI x read QoS register
            AXI_INI6_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  Read channel QoS setting
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x write QoS register
            AXI_INI6_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  Write channel QoS setting
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXI interconnect - INI x issuing functionality modification register
            AXI_INI6_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  Override ASIB read issuing capability
                READ_ISS_OVERRIDE: u1,
                ///  Override ASIB write issuing capability
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
        };

        ///  Hash processor
        pub const HASH = extern struct {
            ///  control register
            CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Initialize message digest calculation
                INIT: u1,
                ///  DMA enable
                DMAE: u1,
                ///  Data type selection
                DATATYPE: u2,
                ///  Mode selection
                MODE: u1,
                ///  Algorithm selection
                ALGO0: u1,
                ///  Number of words already pushed
                NBW: u4,
                ///  DIN not empty
                DINNE: u1,
                ///  Multiple DMA Transfers
                MDMAT: u1,
                reserved16: u2,
                ///  Long key selection
                LKEY: u1,
                reserved18: u1,
                ///  ALGO
                ALGO1: u1,
                padding: u13,
            }),
            ///  data input register
            DIN: mmio.Mmio(packed struct(u32) {
                ///  Data input
                DATAIN: u32,
            }),
            ///  start register
            STR: mmio.Mmio(packed struct(u32) {
                ///  Number of valid bits in the last word of the message
                NBLW: u5,
                reserved8: u3,
                ///  Digest calculation
                DCAL: u1,
                padding: u23,
            }),
            ///  digest registers
            HR0: mmio.Mmio(packed struct(u32) {
                ///  H0
                H0: u32,
            }),
            ///  digest registers
            HR1: mmio.Mmio(packed struct(u32) {
                ///  H1
                H1: u32,
            }),
            ///  digest registers
            HR2: mmio.Mmio(packed struct(u32) {
                ///  H2
                H2: u32,
            }),
            ///  digest registers
            HR3: mmio.Mmio(packed struct(u32) {
                ///  H3
                H3: u32,
            }),
            ///  digest registers
            HR4: mmio.Mmio(packed struct(u32) {
                ///  H4
                H4: u32,
            }),
            ///  interrupt enable register
            IMR: mmio.Mmio(packed struct(u32) {
                ///  Data input interrupt enable
                DINIE: u1,
                ///  Digest calculation completion interrupt enable
                DCIE: u1,
                padding: u30,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Data input interrupt status
                DINIS: u1,
                ///  Digest calculation completion interrupt status
                DCIS: u1,
                ///  DMA Status
                DMAS: u1,
                ///  Busy bit
                BUSY: u1,
                padding: u28,
            }),
            reserved248: [208]u8,
            ///  context swap registers
            CSR0: mmio.Mmio(packed struct(u32) {
                ///  CSR0
                CSR0: u32,
            }),
            ///  context swap registers
            CSR1: mmio.Mmio(packed struct(u32) {
                ///  CSR1
                CSR1: u32,
            }),
            ///  context swap registers
            CSR2: mmio.Mmio(packed struct(u32) {
                ///  CSR2
                CSR2: u32,
            }),
            ///  context swap registers
            CSR3: mmio.Mmio(packed struct(u32) {
                ///  CSR3
                CSR3: u32,
            }),
            ///  context swap registers
            CSR4: mmio.Mmio(packed struct(u32) {
                ///  CSR4
                CSR4: u32,
            }),
            ///  context swap registers
            CSR5: mmio.Mmio(packed struct(u32) {
                ///  CSR5
                CSR5: u32,
            }),
            ///  context swap registers
            CSR6: mmio.Mmio(packed struct(u32) {
                ///  CSR6
                CSR6: u32,
            }),
            ///  context swap registers
            CSR7: mmio.Mmio(packed struct(u32) {
                ///  CSR7
                CSR7: u32,
            }),
            ///  context swap registers
            CSR8: mmio.Mmio(packed struct(u32) {
                ///  CSR8
                CSR8: u32,
            }),
            ///  context swap registers
            CSR9: mmio.Mmio(packed struct(u32) {
                ///  CSR9
                CSR9: u32,
            }),
            ///  context swap registers
            CSR10: mmio.Mmio(packed struct(u32) {
                ///  CSR10
                CSR10: u32,
            }),
            ///  context swap registers
            CSR11: mmio.Mmio(packed struct(u32) {
                ///  CSR11
                CSR11: u32,
            }),
            ///  context swap registers
            CSR12: mmio.Mmio(packed struct(u32) {
                ///  CSR12
                CSR12: u32,
            }),
            ///  context swap registers
            CSR13: mmio.Mmio(packed struct(u32) {
                ///  CSR13
                CSR13: u32,
            }),
            ///  context swap registers
            CSR14: mmio.Mmio(packed struct(u32) {
                ///  CSR14
                CSR14: u32,
            }),
            ///  context swap registers
            CSR15: mmio.Mmio(packed struct(u32) {
                ///  CSR15
                CSR15: u32,
            }),
            ///  context swap registers
            CSR16: mmio.Mmio(packed struct(u32) {
                ///  CSR16
                CSR16: u32,
            }),
            ///  context swap registers
            CSR17: mmio.Mmio(packed struct(u32) {
                ///  CSR17
                CSR17: u32,
            }),
            ///  context swap registers
            CSR18: mmio.Mmio(packed struct(u32) {
                ///  CSR18
                CSR18: u32,
            }),
            ///  context swap registers
            CSR19: mmio.Mmio(packed struct(u32) {
                ///  CSR19
                CSR19: u32,
            }),
            ///  context swap registers
            CSR20: mmio.Mmio(packed struct(u32) {
                ///  CSR20
                CSR20: u32,
            }),
            ///  context swap registers
            CSR21: mmio.Mmio(packed struct(u32) {
                ///  CSR21
                CSR21: u32,
            }),
            ///  context swap registers
            CSR22: mmio.Mmio(packed struct(u32) {
                ///  CSR22
                CSR22: u32,
            }),
            ///  context swap registers
            CSR23: mmio.Mmio(packed struct(u32) {
                ///  CSR23
                CSR23: u32,
            }),
            ///  context swap registers
            CSR24: mmio.Mmio(packed struct(u32) {
                ///  CSR24
                CSR24: u32,
            }),
            ///  context swap registers
            CSR25: mmio.Mmio(packed struct(u32) {
                ///  CSR25
                CSR25: u32,
            }),
            ///  context swap registers
            CSR26: mmio.Mmio(packed struct(u32) {
                ///  CSR26
                CSR26: u32,
            }),
            ///  context swap registers
            CSR27: mmio.Mmio(packed struct(u32) {
                ///  CSR27
                CSR27: u32,
            }),
            ///  context swap registers
            CSR28: mmio.Mmio(packed struct(u32) {
                ///  CSR28
                CSR28: u32,
            }),
            ///  context swap registers
            CSR29: mmio.Mmio(packed struct(u32) {
                ///  CSR29
                CSR29: u32,
            }),
            ///  context swap registers
            CSR30: mmio.Mmio(packed struct(u32) {
                ///  CSR30
                CSR30: u32,
            }),
            ///  context swap registers
            CSR31: mmio.Mmio(packed struct(u32) {
                ///  CSR31
                CSR31: u32,
            }),
            ///  context swap registers
            CSR32: mmio.Mmio(packed struct(u32) {
                ///  CSR32
                CSR32: u32,
            }),
            ///  context swap registers
            CSR33: mmio.Mmio(packed struct(u32) {
                ///  CSR33
                CSR33: u32,
            }),
            ///  context swap registers
            CSR34: mmio.Mmio(packed struct(u32) {
                ///  CSR34
                CSR34: u32,
            }),
            ///  context swap registers
            CSR35: mmio.Mmio(packed struct(u32) {
                ///  CSR35
                CSR35: u32,
            }),
            ///  context swap registers
            CSR36: mmio.Mmio(packed struct(u32) {
                ///  CSR36
                CSR36: u32,
            }),
            ///  context swap registers
            CSR37: mmio.Mmio(packed struct(u32) {
                ///  CSR37
                CSR37: u32,
            }),
            ///  context swap registers
            CSR38: mmio.Mmio(packed struct(u32) {
                ///  CSR38
                CSR38: u32,
            }),
            ///  context swap registers
            CSR39: mmio.Mmio(packed struct(u32) {
                ///  CSR39
                CSR39: u32,
            }),
            ///  context swap registers
            CSR40: mmio.Mmio(packed struct(u32) {
                ///  CSR40
                CSR40: u32,
            }),
            ///  context swap registers
            CSR41: mmio.Mmio(packed struct(u32) {
                ///  CSR41
                CSR41: u32,
            }),
            ///  context swap registers
            CSR42: mmio.Mmio(packed struct(u32) {
                ///  CSR42
                CSR42: u32,
            }),
            ///  context swap registers
            CSR43: mmio.Mmio(packed struct(u32) {
                ///  CSR43
                CSR43: u32,
            }),
            ///  context swap registers
            CSR44: mmio.Mmio(packed struct(u32) {
                ///  CSR44
                CSR44: u32,
            }),
            ///  context swap registers
            CSR45: mmio.Mmio(packed struct(u32) {
                ///  CSR45
                CSR45: u32,
            }),
            ///  context swap registers
            CSR46: mmio.Mmio(packed struct(u32) {
                ///  CSR46
                CSR46: u32,
            }),
            ///  context swap registers
            CSR47: mmio.Mmio(packed struct(u32) {
                ///  CSR47
                CSR47: u32,
            }),
            ///  context swap registers
            CSR48: mmio.Mmio(packed struct(u32) {
                ///  CSR48
                CSR48: u32,
            }),
            ///  context swap registers
            CSR49: mmio.Mmio(packed struct(u32) {
                ///  CSR49
                CSR49: u32,
            }),
            ///  context swap registers
            CSR50: mmio.Mmio(packed struct(u32) {
                ///  CSR50
                CSR50: u32,
            }),
            ///  context swap registers
            CSR51: mmio.Mmio(packed struct(u32) {
                ///  CSR51
                CSR51: u32,
            }),
            ///  context swap registers
            CSR52: mmio.Mmio(packed struct(u32) {
                ///  CSR52
                CSR52: u32,
            }),
            ///  context swap registers
            CSR53: mmio.Mmio(packed struct(u32) {
                ///  CSR53
                CSR53: u32,
            }),
            reserved784: [320]u8,
            ///  HASH digest register
            HASH_HR0: mmio.Mmio(packed struct(u32) {
                ///  H0
                H0: u32,
            }),
            ///  read-only
            HASH_HR1: mmio.Mmio(packed struct(u32) {
                ///  H1
                H1: u32,
            }),
            ///  read-only
            HASH_HR2: mmio.Mmio(packed struct(u32) {
                ///  H2
                H2: u32,
            }),
            ///  read-only
            HASH_HR3: mmio.Mmio(packed struct(u32) {
                ///  H3
                H3: u32,
            }),
            ///  read-only
            HASH_HR4: mmio.Mmio(packed struct(u32) {
                ///  H4
                H4: u32,
            }),
            ///  read-only
            HASH_HR5: mmio.Mmio(packed struct(u32) {
                ///  H5
                H5: u32,
            }),
            ///  read-only
            HASH_HR6: mmio.Mmio(packed struct(u32) {
                ///  H6
                H6: u32,
            }),
            ///  read-only
            HASH_HR7: mmio.Mmio(packed struct(u32) {
                ///  H7
                H7: u32,
            }),
        };

        ///  Cryptographic processor
        pub const CRYP = extern struct {
            ///  control register
            CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Algorithm direction
                ALGODIR: u1,
                ///  Algorithm mode
                ALGOMODE0: u3,
                ///  Data type selection
                DATATYPE: u2,
                ///  Key size selection (AES mode only)
                KEYSIZE: u2,
                reserved14: u4,
                ///  FIFO flush
                FFLUSH: u1,
                ///  Cryptographic processor enable
                CRYPEN: u1,
                ///  GCM_CCMPH
                GCM_CCMPH: u2,
                reserved19: u1,
                ///  ALGOMODE
                ALGOMODE3: u1,
                padding: u12,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Input FIFO empty
                IFEM: u1,
                ///  Input FIFO not full
                IFNF: u1,
                ///  Output FIFO not empty
                OFNE: u1,
                ///  Output FIFO full
                OFFU: u1,
                ///  Busy bit
                BUSY: u1,
                padding: u27,
            }),
            ///  data input register
            DIN: mmio.Mmio(packed struct(u32) {
                ///  Data input
                DATAIN: u32,
            }),
            ///  data output register
            DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data output
                DATAOUT: u32,
            }),
            ///  DMA control register
            DMACR: mmio.Mmio(packed struct(u32) {
                ///  DMA input enable
                DIEN: u1,
                ///  DMA output enable
                DOEN: u1,
                padding: u30,
            }),
            ///  interrupt mask set/clear register
            IMSCR: mmio.Mmio(packed struct(u32) {
                ///  Input FIFO service interrupt mask
                INIM: u1,
                ///  Output FIFO service interrupt mask
                OUTIM: u1,
                padding: u30,
            }),
            ///  raw interrupt status register
            RISR: mmio.Mmio(packed struct(u32) {
                ///  Input FIFO service raw interrupt status
                INRIS: u1,
                ///  Output FIFO service raw interrupt status
                OUTRIS: u1,
                padding: u30,
            }),
            ///  masked interrupt status register
            MISR: mmio.Mmio(packed struct(u32) {
                ///  Input FIFO service masked interrupt status
                INMIS: u1,
                ///  Output FIFO service masked interrupt status
                OUTMIS: u1,
                padding: u30,
            }),
            ///  key registers
            K0LR: mmio.Mmio(packed struct(u32) {
                ///  K224
                K224: u1,
                ///  K225
                K225: u1,
                ///  K226
                K226: u1,
                ///  K227
                K227: u1,
                ///  K228
                K228: u1,
                ///  K229
                K229: u1,
                ///  K230
                K230: u1,
                ///  K231
                K231: u1,
                ///  K232
                K232: u1,
                ///  K233
                K233: u1,
                ///  K234
                K234: u1,
                ///  K235
                K235: u1,
                ///  K236
                K236: u1,
                ///  K237
                K237: u1,
                ///  K238
                K238: u1,
                ///  K239
                K239: u1,
                ///  K240
                K240: u1,
                ///  K241
                K241: u1,
                ///  K242
                K242: u1,
                ///  K243
                K243: u1,
                ///  K244
                K244: u1,
                ///  K245
                K245: u1,
                ///  K246
                K246: u1,
                ///  K247
                K247: u1,
                ///  K248
                K248: u1,
                ///  K249
                K249: u1,
                ///  K250
                K250: u1,
                ///  K251
                K251: u1,
                ///  K252
                K252: u1,
                ///  K253
                K253: u1,
                ///  K254
                K254: u1,
                ///  K255
                K255: u1,
            }),
            ///  key registers
            K0RR: mmio.Mmio(packed struct(u32) {
                ///  K192
                K192: u1,
                ///  K193
                K193: u1,
                ///  K194
                K194: u1,
                ///  K195
                K195: u1,
                ///  K196
                K196: u1,
                ///  K197
                K197: u1,
                ///  K198
                K198: u1,
                ///  K199
                K199: u1,
                ///  K200
                K200: u1,
                ///  K201
                K201: u1,
                ///  K202
                K202: u1,
                ///  K203
                K203: u1,
                ///  K204
                K204: u1,
                ///  K205
                K205: u1,
                ///  K206
                K206: u1,
                ///  K207
                K207: u1,
                ///  K208
                K208: u1,
                ///  K209
                K209: u1,
                ///  K210
                K210: u1,
                ///  K211
                K211: u1,
                ///  K212
                K212: u1,
                ///  K213
                K213: u1,
                ///  K214
                K214: u1,
                ///  K215
                K215: u1,
                ///  K216
                K216: u1,
                ///  K217
                K217: u1,
                ///  K218
                K218: u1,
                ///  K219
                K219: u1,
                ///  K220
                K220: u1,
                ///  K221
                K221: u1,
                ///  K222
                K222: u1,
                ///  K223
                K223: u1,
            }),
            ///  key registers
            K1LR: mmio.Mmio(packed struct(u32) {
                ///  K160
                K160: u1,
                ///  K161
                K161: u1,
                ///  K162
                K162: u1,
                ///  K163
                K163: u1,
                ///  K164
                K164: u1,
                ///  K165
                K165: u1,
                ///  K166
                K166: u1,
                ///  K167
                K167: u1,
                ///  K168
                K168: u1,
                ///  K169
                K169: u1,
                ///  K170
                K170: u1,
                ///  K171
                K171: u1,
                ///  K172
                K172: u1,
                ///  K173
                K173: u1,
                ///  K174
                K174: u1,
                ///  K175
                K175: u1,
                ///  K176
                K176: u1,
                ///  K177
                K177: u1,
                ///  K178
                K178: u1,
                ///  K179
                K179: u1,
                ///  K180
                K180: u1,
                ///  K181
                K181: u1,
                ///  K182
                K182: u1,
                ///  K183
                K183: u1,
                ///  K184
                K184: u1,
                ///  K185
                K185: u1,
                ///  K186
                K186: u1,
                ///  K187
                K187: u1,
                ///  K188
                K188: u1,
                ///  K189
                K189: u1,
                ///  K190
                K190: u1,
                ///  K191
                K191: u1,
            }),
            ///  key registers
            K1RR: mmio.Mmio(packed struct(u32) {
                ///  K128
                K128: u1,
                ///  K129
                K129: u1,
                ///  K130
                K130: u1,
                ///  K131
                K131: u1,
                ///  K132
                K132: u1,
                ///  K133
                K133: u1,
                ///  K134
                K134: u1,
                ///  K135
                K135: u1,
                ///  K136
                K136: u1,
                ///  K137
                K137: u1,
                ///  K138
                K138: u1,
                ///  K139
                K139: u1,
                ///  K140
                K140: u1,
                ///  K141
                K141: u1,
                ///  K142
                K142: u1,
                ///  K143
                K143: u1,
                ///  K144
                K144: u1,
                ///  K145
                K145: u1,
                ///  K146
                K146: u1,
                ///  K147
                K147: u1,
                ///  K148
                K148: u1,
                ///  K149
                K149: u1,
                ///  K150
                K150: u1,
                ///  K151
                K151: u1,
                ///  K152
                K152: u1,
                ///  K153
                K153: u1,
                ///  K154
                K154: u1,
                ///  K155
                K155: u1,
                ///  K156
                K156: u1,
                ///  K157
                K157: u1,
                ///  K158
                K158: u1,
                ///  K159
                K159: u1,
            }),
            ///  key registers
            K2LR: mmio.Mmio(packed struct(u32) {
                ///  K96
                K96: u1,
                ///  K97
                K97: u1,
                ///  K98
                K98: u1,
                ///  K99
                K99: u1,
                ///  K100
                K100: u1,
                ///  K101
                K101: u1,
                ///  K102
                K102: u1,
                ///  K103
                K103: u1,
                ///  K104
                K104: u1,
                ///  K105
                K105: u1,
                ///  K106
                K106: u1,
                ///  K107
                K107: u1,
                ///  K108
                K108: u1,
                ///  K109
                K109: u1,
                ///  K110
                K110: u1,
                ///  K111
                K111: u1,
                ///  K112
                K112: u1,
                ///  K113
                K113: u1,
                ///  K114
                K114: u1,
                ///  K115
                K115: u1,
                ///  K116
                K116: u1,
                ///  K117
                K117: u1,
                ///  K118
                K118: u1,
                ///  K119
                K119: u1,
                ///  K120
                K120: u1,
                ///  K121
                K121: u1,
                ///  K122
                K122: u1,
                ///  K123
                K123: u1,
                ///  K124
                K124: u1,
                ///  K125
                K125: u1,
                ///  K126
                K126: u1,
                ///  K127
                K127: u1,
            }),
            ///  key registers
            K2RR: mmio.Mmio(packed struct(u32) {
                ///  K64
                K64: u1,
                ///  K65
                K65: u1,
                ///  K66
                K66: u1,
                ///  K67
                K67: u1,
                ///  K68
                K68: u1,
                ///  K69
                K69: u1,
                ///  K70
                K70: u1,
                ///  K71
                K71: u1,
                ///  K72
                K72: u1,
                ///  K73
                K73: u1,
                ///  K74
                K74: u1,
                ///  K75
                K75: u1,
                ///  K76
                K76: u1,
                ///  K77
                K77: u1,
                ///  K78
                K78: u1,
                ///  K79
                K79: u1,
                ///  K80
                K80: u1,
                ///  K81
                K81: u1,
                ///  K82
                K82: u1,
                ///  K83
                K83: u1,
                ///  K84
                K84: u1,
                ///  K85
                K85: u1,
                ///  K86
                K86: u1,
                ///  K87
                K87: u1,
                ///  K88
                K88: u1,
                ///  K89
                K89: u1,
                ///  K90
                K90: u1,
                ///  K91
                K91: u1,
                ///  K92
                K92: u1,
                ///  K93
                K93: u1,
                ///  K94
                K94: u1,
                ///  K95
                K95: u1,
            }),
            ///  key registers
            K3LR: mmio.Mmio(packed struct(u32) {
                ///  K32
                K32: u1,
                ///  K33
                K33: u1,
                ///  K34
                K34: u1,
                ///  K35
                K35: u1,
                ///  K36
                K36: u1,
                ///  K37
                K37: u1,
                ///  K38
                K38: u1,
                ///  K39
                K39: u1,
                ///  K40
                K40: u1,
                ///  K41
                K41: u1,
                ///  K42
                K42: u1,
                ///  K43
                K43: u1,
                ///  K44
                K44: u1,
                ///  K45
                K45: u1,
                ///  K46
                K46: u1,
                ///  K47
                K47: u1,
                ///  K48
                K48: u1,
                ///  K49
                K49: u1,
                ///  K50
                K50: u1,
                ///  K51
                K51: u1,
                ///  K52
                K52: u1,
                ///  K53
                K53: u1,
                ///  K54
                K54: u1,
                ///  K55
                K55: u1,
                ///  K56
                K56: u1,
                ///  K57
                K57: u1,
                ///  K58
                K58: u1,
                ///  K59
                K59: u1,
                ///  K60
                K60: u1,
                ///  K61
                K61: u1,
                ///  K62
                K62: u1,
                ///  K63
                K63: u1,
            }),
            ///  key registers
            K3RR: mmio.Mmio(packed struct(u32) {
                ///  K0
                K0: u1,
                ///  K1
                K1: u1,
                ///  K2
                K2: u1,
                ///  K3
                K3: u1,
                ///  K4
                K4: u1,
                ///  K5
                K5: u1,
                ///  K6
                K6: u1,
                ///  K7
                K7: u1,
                ///  K8
                K8: u1,
                ///  K9
                K9: u1,
                ///  K10
                K10: u1,
                ///  K11
                K11: u1,
                ///  K12
                K12: u1,
                ///  K13
                K13: u1,
                ///  K14
                K14: u1,
                ///  K15
                K15: u1,
                ///  K16
                K16: u1,
                ///  K17
                K17: u1,
                ///  K18
                K18: u1,
                ///  K19
                K19: u1,
                ///  K20
                K20: u1,
                ///  K21
                K21: u1,
                ///  K22
                K22: u1,
                ///  K23
                K23: u1,
                ///  K24
                K24: u1,
                ///  K25
                K25: u1,
                ///  K26
                K26: u1,
                ///  K27
                K27: u1,
                ///  K28
                K28: u1,
                ///  K29
                K29: u1,
                ///  K30
                K30: u1,
                ///  K31
                K31: u1,
            }),
            ///  initialization vector registers
            IV0LR: mmio.Mmio(packed struct(u32) {
                ///  IV31
                IV31: u1,
                ///  IV30
                IV30: u1,
                ///  IV29
                IV29: u1,
                ///  IV28
                IV28: u1,
                ///  IV27
                IV27: u1,
                ///  IV26
                IV26: u1,
                ///  IV25
                IV25: u1,
                ///  IV24
                IV24: u1,
                ///  IV23
                IV23: u1,
                ///  IV22
                IV22: u1,
                ///  IV21
                IV21: u1,
                ///  IV20
                IV20: u1,
                ///  IV19
                IV19: u1,
                ///  IV18
                IV18: u1,
                ///  IV17
                IV17: u1,
                ///  IV16
                IV16: u1,
                ///  IV15
                IV15: u1,
                ///  IV14
                IV14: u1,
                ///  IV13
                IV13: u1,
                ///  IV12
                IV12: u1,
                ///  IV11
                IV11: u1,
                ///  IV10
                IV10: u1,
                ///  IV9
                IV9: u1,
                ///  IV8
                IV8: u1,
                ///  IV7
                IV7: u1,
                ///  IV6
                IV6: u1,
                ///  IV5
                IV5: u1,
                ///  IV4
                IV4: u1,
                ///  IV3
                IV3: u1,
                ///  IV2
                IV2: u1,
                ///  IV1
                IV1: u1,
                ///  IV0
                IV0: u1,
            }),
            ///  initialization vector registers
            IV0RR: mmio.Mmio(packed struct(u32) {
                ///  IV63
                IV63: u1,
                ///  IV62
                IV62: u1,
                ///  IV61
                IV61: u1,
                ///  IV60
                IV60: u1,
                ///  IV59
                IV59: u1,
                ///  IV58
                IV58: u1,
                ///  IV57
                IV57: u1,
                ///  IV56
                IV56: u1,
                ///  IV55
                IV55: u1,
                ///  IV54
                IV54: u1,
                ///  IV53
                IV53: u1,
                ///  IV52
                IV52: u1,
                ///  IV51
                IV51: u1,
                ///  IV50
                IV50: u1,
                ///  IV49
                IV49: u1,
                ///  IV48
                IV48: u1,
                ///  IV47
                IV47: u1,
                ///  IV46
                IV46: u1,
                ///  IV45
                IV45: u1,
                ///  IV44
                IV44: u1,
                ///  IV43
                IV43: u1,
                ///  IV42
                IV42: u1,
                ///  IV41
                IV41: u1,
                ///  IV40
                IV40: u1,
                ///  IV39
                IV39: u1,
                ///  IV38
                IV38: u1,
                ///  IV37
                IV37: u1,
                ///  IV36
                IV36: u1,
                ///  IV35
                IV35: u1,
                ///  IV34
                IV34: u1,
                ///  IV33
                IV33: u1,
                ///  IV32
                IV32: u1,
            }),
            ///  initialization vector registers
            IV1LR: mmio.Mmio(packed struct(u32) {
                ///  IV95
                IV95: u1,
                ///  IV94
                IV94: u1,
                ///  IV93
                IV93: u1,
                ///  IV92
                IV92: u1,
                ///  IV91
                IV91: u1,
                ///  IV90
                IV90: u1,
                ///  IV89
                IV89: u1,
                ///  IV88
                IV88: u1,
                ///  IV87
                IV87: u1,
                ///  IV86
                IV86: u1,
                ///  IV85
                IV85: u1,
                ///  IV84
                IV84: u1,
                ///  IV83
                IV83: u1,
                ///  IV82
                IV82: u1,
                ///  IV81
                IV81: u1,
                ///  IV80
                IV80: u1,
                ///  IV79
                IV79: u1,
                ///  IV78
                IV78: u1,
                ///  IV77
                IV77: u1,
                ///  IV76
                IV76: u1,
                ///  IV75
                IV75: u1,
                ///  IV74
                IV74: u1,
                ///  IV73
                IV73: u1,
                ///  IV72
                IV72: u1,
                ///  IV71
                IV71: u1,
                ///  IV70
                IV70: u1,
                ///  IV69
                IV69: u1,
                ///  IV68
                IV68: u1,
                ///  IV67
                IV67: u1,
                ///  IV66
                IV66: u1,
                ///  IV65
                IV65: u1,
                ///  IV64
                IV64: u1,
            }),
            ///  initialization vector registers
            IV1RR: mmio.Mmio(packed struct(u32) {
                ///  IV127
                IV127: u1,
                ///  IV126
                IV126: u1,
                ///  IV125
                IV125: u1,
                ///  IV124
                IV124: u1,
                ///  IV123
                IV123: u1,
                ///  IV122
                IV122: u1,
                ///  IV121
                IV121: u1,
                ///  IV120
                IV120: u1,
                ///  IV119
                IV119: u1,
                ///  IV118
                IV118: u1,
                ///  IV117
                IV117: u1,
                ///  IV116
                IV116: u1,
                ///  IV115
                IV115: u1,
                ///  IV114
                IV114: u1,
                ///  IV113
                IV113: u1,
                ///  IV112
                IV112: u1,
                ///  IV111
                IV111: u1,
                ///  IV110
                IV110: u1,
                ///  IV109
                IV109: u1,
                ///  IV108
                IV108: u1,
                ///  IV107
                IV107: u1,
                ///  IV106
                IV106: u1,
                ///  IV105
                IV105: u1,
                ///  IV104
                IV104: u1,
                ///  IV103
                IV103: u1,
                ///  IV102
                IV102: u1,
                ///  IV101
                IV101: u1,
                ///  IV100
                IV100: u1,
                ///  IV99
                IV99: u1,
                ///  IV98
                IV98: u1,
                ///  IV97
                IV97: u1,
                ///  IV96
                IV96: u1,
            }),
            ///  context swap register
            CSGCMCCM0R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM0
                CSGCMCCM0: u32,
            }),
            ///  context swap register
            CSGCMCCM1R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM1
                CSGCMCCM1: u32,
            }),
            ///  context swap register
            CSGCMCCM2R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM2
                CSGCMCCM2: u32,
            }),
            ///  context swap register
            CSGCMCCM3R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM3
                CSGCMCCM3: u32,
            }),
            ///  context swap register
            CSGCMCCM4R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM4
                CSGCMCCM4: u32,
            }),
            ///  context swap register
            CSGCMCCM5R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM5
                CSGCMCCM5: u32,
            }),
            ///  context swap register
            CSGCMCCM6R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM6
                CSGCMCCM6: u32,
            }),
            ///  context swap register
            CSGCMCCM7R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM7
                CSGCMCCM7: u32,
            }),
            ///  context swap register
            CSGCM0R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM0
                CSGCM0: u32,
            }),
            ///  context swap register
            CSGCM1R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM1
                CSGCM1: u32,
            }),
            ///  context swap register
            CSGCM2R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM2
                CSGCM2: u32,
            }),
            ///  context swap register
            CSGCM3R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM3
                CSGCM3: u32,
            }),
            ///  context swap register
            CSGCM4R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM4
                CSGCM4: u32,
            }),
            ///  context swap register
            CSGCM5R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM5
                CSGCM5: u32,
            }),
            ///  context swap register
            CSGCM6R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM6
                CSGCM6: u32,
            }),
            ///  context swap register
            CSGCM7R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM7
                CSGCM7: u32,
            }),
        };

        ///  Digital camera interface
        pub const DCMI = extern struct {
            ///  control register 1
            CR: mmio.Mmio(packed struct(u32) {
                ///  Capture enable
                CAPTURE: u1,
                ///  Capture mode
                CM: u1,
                ///  Crop feature
                CROP: u1,
                ///  JPEG format
                JPEG: u1,
                ///  Embedded synchronization select
                ESS: u1,
                ///  Pixel clock polarity
                PCKPOL: u1,
                ///  Horizontal synchronization polarity
                HSPOL: u1,
                ///  Vertical synchronization polarity
                VSPOL: u1,
                ///  Frame capture rate control
                FCRC: u2,
                ///  Extended data mode
                EDM: u2,
                reserved14: u2,
                ///  DCMI enable
                ENABLE: u1,
                reserved16: u1,
                ///  Byte Select mode
                BSM: u2,
                ///  Odd/Even Byte Select (Byte Select Start)
                OEBS: u1,
                ///  Line Select mode
                LSM: u1,
                ///  Odd/Even Line Select (Line Select Start)
                OELS: u1,
                padding: u11,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  HSYNC
                HSYNC: u1,
                ///  VSYNC
                VSYNC: u1,
                ///  FIFO not empty
                FNE: u1,
                padding: u29,
            }),
            ///  raw interrupt status register
            RIS: mmio.Mmio(packed struct(u32) {
                ///  Capture complete raw interrupt status
                FRAME_RIS: u1,
                ///  Overrun raw interrupt status
                OVR_RIS: u1,
                ///  Synchronization error raw interrupt status
                ERR_RIS: u1,
                ///  VSYNC raw interrupt status
                VSYNC_RIS: u1,
                ///  Line raw interrupt status
                LINE_RIS: u1,
                padding: u27,
            }),
            ///  interrupt enable register
            IER: mmio.Mmio(packed struct(u32) {
                ///  Capture complete interrupt enable
                FRAME_IE: u1,
                ///  Overrun interrupt enable
                OVR_IE: u1,
                ///  Synchronization error interrupt enable
                ERR_IE: u1,
                ///  VSYNC interrupt enable
                VSYNC_IE: u1,
                ///  Line interrupt enable
                LINE_IE: u1,
                padding: u27,
            }),
            ///  masked interrupt status register
            MIS: mmio.Mmio(packed struct(u32) {
                ///  Capture complete masked interrupt status
                FRAME_MIS: u1,
                ///  Overrun masked interrupt status
                OVR_MIS: u1,
                ///  Synchronization error masked interrupt status
                ERR_MIS: u1,
                ///  VSYNC masked interrupt status
                VSYNC_MIS: u1,
                ///  Line masked interrupt status
                LINE_MIS: u1,
                padding: u27,
            }),
            ///  interrupt clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Capture complete interrupt status clear
                FRAME_ISC: u1,
                ///  Overrun interrupt status clear
                OVR_ISC: u1,
                ///  Synchronization error interrupt status clear
                ERR_ISC: u1,
                ///  Vertical synch interrupt status clear
                VSYNC_ISC: u1,
                ///  line interrupt status clear
                LINE_ISC: u1,
                padding: u27,
            }),
            ///  embedded synchronization code register
            ESCR: mmio.Mmio(packed struct(u32) {
                ///  Frame start delimiter code
                FSC: u8,
                ///  Line start delimiter code
                LSC: u8,
                ///  Line end delimiter code
                LEC: u8,
                ///  Frame end delimiter code
                FEC: u8,
            }),
            ///  embedded synchronization unmask register
            ESUR: mmio.Mmio(packed struct(u32) {
                ///  Frame start delimiter unmask
                FSU: u8,
                ///  Line start delimiter unmask
                LSU: u8,
                ///  Line end delimiter unmask
                LEU: u8,
                ///  Frame end delimiter unmask
                FEU: u8,
            }),
            ///  crop window start
            CWSTRT: mmio.Mmio(packed struct(u32) {
                ///  Horizontal offset count
                HOFFCNT: u14,
                reserved16: u2,
                ///  Vertical start line count
                VST: u13,
                padding: u3,
            }),
            ///  crop window size
            CWSIZE: mmio.Mmio(packed struct(u32) {
                ///  Capture count
                CAPCNT: u14,
                reserved16: u2,
                ///  Vertical line count
                VLINE: u14,
                padding: u2,
            }),
            ///  data register
            DR: mmio.Mmio(packed struct(u32) {
                ///  Data byte 0
                Byte0: u8,
                ///  Data byte 1
                Byte1: u8,
                ///  Data byte 2
                Byte2: u8,
                ///  Data byte 3
                Byte3: u8,
            }),
        };

        ///  USB 1 on the go high speed
        pub const OTG1_HS_GLOBAL = extern struct {
            ///  OTG_HS control and status register
            OTG_HS_GOTGCTL: mmio.Mmio(packed struct(u32) {
                ///  Session request success
                SRQSCS: u1,
                ///  Session request
                SRQ: u1,
                reserved8: u6,
                ///  Host negotiation success
                HNGSCS: u1,
                ///  HNP request
                HNPRQ: u1,
                ///  Host set HNP enable
                HSHNPEN: u1,
                ///  Device HNP enabled
                DHNPEN: u1,
                ///  Embedded host enable
                EHEN: u1,
                reserved16: u3,
                ///  Connector ID status
                CIDSTS: u1,
                ///  Long/short debounce time
                DBCT: u1,
                ///  A-session valid
                ASVLD: u1,
                ///  B-session valid
                BSVLD: u1,
                padding: u12,
            }),
            ///  OTG_HS interrupt register
            OTG_HS_GOTGINT: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Session end detected
                SEDET: u1,
                reserved8: u5,
                ///  Session request success status change
                SRSSCHG: u1,
                ///  Host negotiation success status change
                HNSSCHG: u1,
                reserved17: u7,
                ///  Host negotiation detected
                HNGDET: u1,
                ///  A-device timeout change
                ADTOCHG: u1,
                ///  Debounce done
                DBCDNE: u1,
                ///  ID input pin changed
                IDCHNG: u1,
                padding: u11,
            }),
            ///  OTG_HS AHB configuration register
            OTG_HS_GAHBCFG: mmio.Mmio(packed struct(u32) {
                ///  Global interrupt mask
                GINT: u1,
                ///  Burst length/type
                HBSTLEN: u4,
                ///  DMA enable
                DMAEN: u1,
                reserved7: u1,
                ///  TxFIFO empty level
                TXFELVL: u1,
                ///  Periodic TxFIFO empty level
                PTXFELVL: u1,
                padding: u23,
            }),
            ///  OTG_HS USB configuration register
            OTG_HS_GUSBCFG: mmio.Mmio(packed struct(u32) {
                ///  FS timeout calibration
                TOCAL: u3,
                reserved6: u3,
                ///  USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
                PHYSEL: u1,
                reserved8: u1,
                ///  SRP-capable
                SRPCAP: u1,
                ///  HNP-capable
                HNPCAP: u1,
                ///  USB turnaround time
                TRDT: u4,
                reserved15: u1,
                ///  PHY Low-power clock select
                PHYLPCS: u1,
                reserved17: u1,
                ///  ULPI FS/LS select
                ULPIFSLS: u1,
                ///  ULPI Auto-resume
                ULPIAR: u1,
                ///  ULPI Clock SuspendM
                ULPICSM: u1,
                ///  ULPI External VBUS Drive
                ULPIEVBUSD: u1,
                ///  ULPI external VBUS indicator
                ULPIEVBUSI: u1,
                ///  TermSel DLine pulsing selection
                TSDPS: u1,
                ///  Indicator complement
                PCCI: u1,
                ///  Indicator pass through
                PTCI: u1,
                ///  ULPI interface protect disable
                ULPIIPD: u1,
                reserved29: u3,
                ///  Forced host mode
                FHMOD: u1,
                ///  Forced peripheral mode
                FDMOD: u1,
                padding: u1,
            }),
            ///  OTG_HS reset register
            OTG_HS_GRSTCTL: mmio.Mmio(packed struct(u32) {
                ///  Core soft reset
                CSRST: u1,
                ///  HCLK soft reset
                HSRST: u1,
                ///  Host frame counter reset
                FCRST: u1,
                reserved4: u1,
                ///  RxFIFO flush
                RXFFLSH: u1,
                ///  TxFIFO flush
                TXFFLSH: u1,
                ///  TxFIFO number
                TXFNUM: u5,
                reserved30: u19,
                ///  DMA request signal enabled for USB OTG HS
                DMAREQ: u1,
                ///  AHB master idle
                AHBIDL: u1,
            }),
            ///  OTG_HS core interrupt register
            OTG_HS_GINTSTS: mmio.Mmio(packed struct(u32) {
                ///  Current mode of operation
                CMOD: u1,
                ///  Mode mismatch interrupt
                MMIS: u1,
                ///  OTG interrupt
                OTGINT: u1,
                ///  Start of frame
                SOF: u1,
                ///  RxFIFO nonempty
                RXFLVL: u1,
                ///  Nonperiodic TxFIFO empty
                NPTXFE: u1,
                ///  Global IN nonperiodic NAK effective
                GINAKEFF: u1,
                ///  Global OUT NAK effective
                BOUTNAKEFF: u1,
                reserved10: u2,
                ///  Early suspend
                ESUSP: u1,
                ///  USB suspend
                USBSUSP: u1,
                ///  USB reset
                USBRST: u1,
                ///  Enumeration done
                ENUMDNE: u1,
                ///  Isochronous OUT packet dropped interrupt
                ISOODRP: u1,
                ///  End of periodic frame interrupt
                EOPF: u1,
                reserved18: u2,
                ///  IN endpoint interrupt
                IEPINT: u1,
                ///  OUT endpoint interrupt
                OEPINT: u1,
                ///  Incomplete isochronous IN transfer
                IISOIXFR: u1,
                ///  Incomplete periodic transfer
                PXFR_INCOMPISOOUT: u1,
                ///  Data fetch suspended
                DATAFSUSP: u1,
                reserved24: u1,
                ///  Host port interrupt
                HPRTINT: u1,
                ///  Host channels interrupt
                HCINT: u1,
                ///  Periodic TxFIFO empty
                PTXFE: u1,
                reserved28: u1,
                ///  Connector ID status change
                CIDSCHG: u1,
                ///  Disconnect detected interrupt
                DISCINT: u1,
                ///  Session request/new session detected interrupt
                SRQINT: u1,
                ///  Resume/remote wakeup detected interrupt
                WKUINT: u1,
            }),
            ///  OTG_HS interrupt mask register
            OTG_HS_GINTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Mode mismatch interrupt mask
                MMISM: u1,
                ///  OTG interrupt mask
                OTGINT: u1,
                ///  Start of frame mask
                SOFM: u1,
                ///  Receive FIFO nonempty mask
                RXFLVLM: u1,
                ///  Nonperiodic TxFIFO empty mask
                NPTXFEM: u1,
                ///  Global nonperiodic IN NAK effective mask
                GINAKEFFM: u1,
                ///  Global OUT NAK effective mask
                GONAKEFFM: u1,
                reserved10: u2,
                ///  Early suspend mask
                ESUSPM: u1,
                ///  USB suspend mask
                USBSUSPM: u1,
                ///  USB reset mask
                USBRST: u1,
                ///  Enumeration done mask
                ENUMDNEM: u1,
                ///  Isochronous OUT packet dropped interrupt mask
                ISOODRPM: u1,
                ///  End of periodic frame interrupt mask
                EOPFM: u1,
                reserved18: u2,
                ///  IN endpoints interrupt mask
                IEPINT: u1,
                ///  OUT endpoints interrupt mask
                OEPINT: u1,
                ///  Incomplete isochronous IN transfer mask
                IISOIXFRM: u1,
                ///  Incomplete periodic transfer mask
                PXFRM_IISOOXFRM: u1,
                ///  Data fetch suspended mask
                FSUSPM: u1,
                ///  Reset detected interrupt mask
                RSTDE: u1,
                ///  Host port interrupt mask
                PRTIM: u1,
                ///  Host channels interrupt mask
                HCIM: u1,
                ///  Periodic TxFIFO empty mask
                PTXFEM: u1,
                ///  LPM interrupt mask
                LPMINTM: u1,
                ///  Connector ID status change mask
                CIDSCHGM: u1,
                ///  Disconnect detected interrupt mask
                DISCINT: u1,
                ///  Session request/new session detected interrupt mask
                SRQIM: u1,
                ///  Resume/remote wakeup detected interrupt mask
                WUIM: u1,
            }),
            ///  OTG_HS Receive status debug read register (host mode)
            OTG_HS_GRXSTSR_Host: mmio.Mmio(packed struct(u32) {
                ///  Channel number
                CHNUM: u4,
                ///  Byte count
                BCNT: u11,
                ///  Data PID
                DPID: u2,
                ///  Packet status
                PKTSTS: u4,
                padding: u11,
            }),
            ///  OTG_HS status read and pop register (host mode)
            OTG_HS_GRXSTSP_Host: mmio.Mmio(packed struct(u32) {
                ///  Channel number
                CHNUM: u4,
                ///  Byte count
                BCNT: u11,
                ///  Data PID
                DPID: u2,
                ///  Packet status
                PKTSTS: u4,
                padding: u11,
            }),
            ///  OTG_HS Receive FIFO size register
            OTG_HS_GRXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  RxFIFO depth
                RXFD: u16,
                padding: u16,
            }),
            ///  OTG_HS nonperiodic transmit FIFO size register (host mode)
            OTG_HS_HNPTXFSIZ_Host: mmio.Mmio(packed struct(u32) {
                ///  Nonperiodic transmit RAM start address
                NPTXFSA: u16,
                ///  Nonperiodic TxFIFO depth
                NPTXFD: u16,
            }),
            ///  OTG_HS nonperiodic transmit FIFO/queue status register
            OTG_HS_GNPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  Nonperiodic TxFIFO space available
                NPTXFSAV: u16,
                ///  Nonperiodic transmit request queue space available
                NPTQXSAV: u8,
                ///  Top of the nonperiodic transmit request queue
                NPTXQTOP: u7,
                padding: u1,
            }),
            reserved56: [8]u8,
            ///  OTG_HS general core configuration register
            OTG_HS_GCCFG: mmio.Mmio(packed struct(u32) {
                ///  Data contact detection (DCD) status
                DCDET: u1,
                ///  Primary detection (PD) status
                PDET: u1,
                ///  Secondary detection (SD) status
                SDET: u1,
                ///  DM pull-up detection status
                PS2DET: u1,
                reserved16: u12,
                ///  Power down
                PWRDWN: u1,
                ///  Battery charging detector (BCD) enable
                BCDEN: u1,
                ///  Data contact detection (DCD) mode enable
                DCDEN: u1,
                ///  Primary detection (PD) mode enable
                PDEN: u1,
                ///  Secondary detection (SD) mode enable
                SDEN: u1,
                ///  USB VBUS detection enable
                VBDEN: u1,
                padding: u10,
            }),
            ///  OTG_HS core ID register
            OTG_HS_CID: mmio.Mmio(packed struct(u32) {
                ///  Product ID field
                PRODUCT_ID: u32,
            }),
            reserved84: [20]u8,
            ///  OTG core LPM configuration register
            OTG_HS_GLPMCFG: mmio.Mmio(packed struct(u32) {
                ///  LPM support enable
                LPMEN: u1,
                ///  LPM token acknowledge enable
                LPMACK: u1,
                ///  Best effort service latency
                BESL: u4,
                ///  bRemoteWake value
                REMWAKE: u1,
                ///  L1 Shallow Sleep enable
                L1SSEN: u1,
                ///  BESL threshold
                BESLTHRS: u4,
                ///  L1 deep sleep enable
                L1DSEN: u1,
                ///  LPM response
                LPMRST: u2,
                ///  Port sleep status
                SLPSTS: u1,
                ///  Sleep State Resume OK
                L1RSMOK: u1,
                ///  LPM Channel Index
                LPMCHIDX: u4,
                ///  LPM retry count
                LPMRCNT: u3,
                ///  Send LPM transaction
                SNDLPM: u1,
                ///  LPM retry count status
                LPMRCNTSTS: u3,
                ///  Enable best effort service latency
                ENBESL: u1,
                padding: u3,
            }),
            reserved256: [168]u8,
            ///  OTG_HS Host periodic transmit FIFO size register
            OTG_HS_HPTXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  Host periodic TxFIFO start address
                PTXSA: u16,
                ///  Host periodic TxFIFO depth
                PTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF1: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF2: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF3: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            reserved288: [16]u8,
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF4: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF5: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF6: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO size register
            OTG_HS_DIEPTXF7: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint FIFOx transmit RAM start address
                INEPTXSA: u16,
                ///  IN endpoint TxFIFO depth
                INEPTXFD: u16,
            }),
        };

        ///  Digital filter for sigma delta modulators
        pub const DFSDM = extern struct {
            ///  DFSDM channel configuration 0 register 1
            DFSDM_CHCFG0R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 0
                SITP: u2,
                ///  SPI clock select for channel 0
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 0
                SCDEN: u1,
                ///  Clock absence detector enable on channel 0
                CKABEN: u1,
                ///  Channel 0 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 0
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 1 register 1
            DFSDM_CHCFG1R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 1
                SITP: u2,
                ///  SPI clock select for channel 1
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 1
                SCDEN: u1,
                ///  Clock absence detector enable on channel 1
                CKABEN: u1,
                ///  Channel 1 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 1
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 2 register 1
            DFSDM_CHCFG2R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 2
                SITP: u2,
                ///  SPI clock select for channel 2
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 2
                SCDEN: u1,
                ///  Clock absence detector enable on channel 2
                CKABEN: u1,
                ///  Channel 2 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 2
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 3 register 1
            DFSDM_CHCFG3R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 3
                SITP: u2,
                ///  SPI clock select for channel 3
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 3
                SCDEN: u1,
                ///  Clock absence detector enable on channel 3
                CKABEN: u1,
                ///  Channel 3 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 3
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 4 register 1
            DFSDM_CHCFG4R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 4
                SITP: u2,
                ///  SPI clock select for channel 4
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 4
                SCDEN: u1,
                ///  Clock absence detector enable on channel 4
                CKABEN: u1,
                ///  Channel 4 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 4
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 5 register 1
            DFSDM_CHCFG5R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 5
                SITP: u2,
                ///  SPI clock select for channel 5
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 5
                SCDEN: u1,
                ///  Clock absence detector enable on channel 5
                CKABEN: u1,
                ///  Channel 5 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 5
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 6 register 1
            DFSDM_CHCFG6R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 6
                SITP: u2,
                ///  SPI clock select for channel 6
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 6
                SCDEN: u1,
                ///  Clock absence detector enable on channel 6
                CKABEN: u1,
                ///  Channel 6 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 6
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 7 register 1
            DFSDM_CHCFG7R1: mmio.Mmio(packed struct(u32) {
                ///  Serial interface type for channel 7
                SITP: u2,
                ///  SPI clock select for channel 7
                SPICKSEL: u2,
                reserved5: u1,
                ///  Short-circuit detector enable on channel 7
                SCDEN: u1,
                ///  Clock absence detector enable on channel 7
                CKABEN: u1,
                ///  Channel 7 enable
                CHEN: u1,
                ///  Channel inputs selection
                CHINSEL: u1,
                reserved12: u3,
                ///  Input data multiplexer for channel 7
                DATMPX: u2,
                ///  Data packing mode in DFSDM_CHDATINyR register
                DATPACK: u2,
                ///  Output serial clock divider
                CKOUTDIV: u8,
                reserved30: u6,
                ///  Output serial clock source selection
                CKOUTSRC: u1,
                ///  Global enable for DFSDM interface
                DFSDMEN: u1,
            }),
            ///  DFSDM channel configuration 0 register 2
            DFSDM_CHCFG0R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 0
                DTRBS: u5,
                ///  24-bit calibration offset for channel 0
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 1 register 2
            DFSDM_CHCFG1R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 1
                DTRBS: u5,
                ///  24-bit calibration offset for channel 1
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 2 register 2
            DFSDM_CHCFG2R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 2
                DTRBS: u5,
                ///  24-bit calibration offset for channel 2
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 3 register 2
            DFSDM_CHCFG3R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 3
                DTRBS: u5,
                ///  24-bit calibration offset for channel 3
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 4 register 2
            DFSDM_CHCFG4R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 4
                DTRBS: u5,
                ///  24-bit calibration offset for channel 4
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 5 register 2
            DFSDM_CHCFG5R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 5
                DTRBS: u5,
                ///  24-bit calibration offset for channel 5
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 6 register 2
            DFSDM_CHCFG6R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 6
                DTRBS: u5,
                ///  24-bit calibration offset for channel 6
                OFFSET: u24,
            }),
            ///  DFSDM channel configuration 7 register 2
            DFSDM_CHCFG7R2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Data right bit-shift for channel 7
                DTRBS: u5,
                ///  24-bit calibration offset for channel 7
                OFFSET: u24,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD0R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 0
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 0
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 0
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 0
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD1R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 1
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 1
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 1
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 1
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD2R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 2
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 2
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 2
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 2
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD3R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 3
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 3
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 3
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 3
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD4R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 4
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 4
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 4
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 4
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD5R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 5
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 5
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 5
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 5
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD6R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 6
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 6
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 6
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 6
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM analog watchdog and short-circuit detector register
            DFSDM_AWSCD7R: mmio.Mmio(packed struct(u32) {
                ///  short-circuit detector threshold for channel 7
                SCDT: u8,
                reserved12: u4,
                ///  Break signal assignment for short-circuit detector on channel 7
                BKSCD: u4,
                ///  Analog watchdog filter oversampling ratio (decimation rate) on channel 7
                AWFOSR: u5,
                reserved22: u1,
                ///  Analog watchdog Sinc filter order on channel 7
                AWFORD: u2,
                padding: u8,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT0R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT1R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT2R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT3R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT4R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT5R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT6R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel watchdog filter data register
            DFSDM_CHWDAT7R: mmio.Mmio(packed struct(u32) {
                ///  Input channel y watchdog data
                WDATA: u16,
                padding: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN0R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 0
                INDAT0: u16,
                ///  Input data for channel 1
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN1R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 1
                INDAT0: u16,
                ///  Input data for channel 2
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN2R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 2
                INDAT0: u16,
                ///  Input data for channel 3
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN3R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 3
                INDAT0: u16,
                ///  Input data for channel 4
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN4R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 4
                INDAT0: u16,
                ///  Input data for channel 5
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN5R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 5
                INDAT0: u16,
                ///  Input data for channel 6
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN6R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 6
                INDAT0: u16,
                ///  Input data for channel 7
                INDAT1: u16,
            }),
            ///  DFSDM channel data input register
            DFSDM_CHDATIN7R: mmio.Mmio(packed struct(u32) {
                ///  Input data for channel 7
                INDAT0: u16,
                ///  Input data for channel 8
                INDAT1: u16,
            }),
            ///  DFSDM control register 1
            DFSDM0_CR1: mmio.Mmio(packed struct(u32) {
                ///  DFSDM enable
                DFEN: u1,
                ///  Start a conversion of the injected group of channels
                JSWSTART: u1,
                reserved3: u1,
                ///  Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
                JSYNC: u1,
                ///  Scanning conversion mode for injected conversions
                JSCAN: u1,
                ///  DMA channel enabled to read data for the injected channel group
                JDMAEN: u1,
                reserved8: u2,
                ///  Trigger signal selection for launching injected conversions
                JEXTSEL: u5,
                ///  Trigger enable and trigger edge selection for injected conversions
                JEXTEN: u2,
                reserved17: u2,
                ///  Software start of a conversion on the regular channel
                RSWSTART: u1,
                ///  Continuous mode selection for regular conversions
                RCONT: u1,
                ///  Launch regular conversion synchronously with DFSDM0
                RSYNC: u1,
                reserved21: u1,
                ///  DMA channel enabled to read data for the regular conversion
                RDMAEN: u1,
                reserved24: u2,
                ///  Regular channel selection
                RCH: u3,
                reserved29: u2,
                ///  Fast conversion mode selection for regular conversions
                FAST: u1,
                ///  Analog watchdog fast mode select
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM control register 1
            DFSDM1_CR1: mmio.Mmio(packed struct(u32) {
                ///  DFSDM enable
                DFEN: u1,
                ///  Start a conversion of the injected group of channels
                JSWSTART: u1,
                reserved3: u1,
                ///  Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
                JSYNC: u1,
                ///  Scanning conversion mode for injected conversions
                JSCAN: u1,
                ///  DMA channel enabled to read data for the injected channel group
                JDMAEN: u1,
                reserved8: u2,
                ///  Trigger signal selection for launching injected conversions
                JEXTSEL: u5,
                ///  Trigger enable and trigger edge selection for injected conversions
                JEXTEN: u2,
                reserved17: u2,
                ///  Software start of a conversion on the regular channel
                RSWSTART: u1,
                ///  Continuous mode selection for regular conversions
                RCONT: u1,
                ///  Launch regular conversion synchronously with DFSDM0
                RSYNC: u1,
                reserved21: u1,
                ///  DMA channel enabled to read data for the regular conversion
                RDMAEN: u1,
                reserved24: u2,
                ///  Regular channel selection
                RCH: u3,
                reserved29: u2,
                ///  Fast conversion mode selection for regular conversions
                FAST: u1,
                ///  Analog watchdog fast mode select
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM control register 1
            DFSDM2_CR1: mmio.Mmio(packed struct(u32) {
                ///  DFSDM enable
                DFEN: u1,
                ///  Start a conversion of the injected group of channels
                JSWSTART: u1,
                reserved3: u1,
                ///  Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
                JSYNC: u1,
                ///  Scanning conversion mode for injected conversions
                JSCAN: u1,
                ///  DMA channel enabled to read data for the injected channel group
                JDMAEN: u1,
                reserved8: u2,
                ///  Trigger signal selection for launching injected conversions
                JEXTSEL: u5,
                ///  Trigger enable and trigger edge selection for injected conversions
                JEXTEN: u2,
                reserved17: u2,
                ///  Software start of a conversion on the regular channel
                RSWSTART: u1,
                ///  Continuous mode selection for regular conversions
                RCONT: u1,
                ///  Launch regular conversion synchronously with DFSDM0
                RSYNC: u1,
                reserved21: u1,
                ///  DMA channel enabled to read data for the regular conversion
                RDMAEN: u1,
                reserved24: u2,
                ///  Regular channel selection
                RCH: u3,
                reserved29: u2,
                ///  Fast conversion mode selection for regular conversions
                FAST: u1,
                ///  Analog watchdog fast mode select
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM control register 1
            DFSDM3_CR1: mmio.Mmio(packed struct(u32) {
                ///  DFSDM enable
                DFEN: u1,
                ///  Start a conversion of the injected group of channels
                JSWSTART: u1,
                reserved3: u1,
                ///  Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
                JSYNC: u1,
                ///  Scanning conversion mode for injected conversions
                JSCAN: u1,
                ///  DMA channel enabled to read data for the injected channel group
                JDMAEN: u1,
                reserved8: u2,
                ///  Trigger signal selection for launching injected conversions
                JEXTSEL: u5,
                ///  Trigger enable and trigger edge selection for injected conversions
                JEXTEN: u2,
                reserved17: u2,
                ///  Software start of a conversion on the regular channel
                RSWSTART: u1,
                ///  Continuous mode selection for regular conversions
                RCONT: u1,
                ///  Launch regular conversion synchronously with DFSDM0
                RSYNC: u1,
                reserved21: u1,
                ///  DMA channel enabled to read data for the regular conversion
                RDMAEN: u1,
                reserved24: u2,
                ///  Regular channel selection
                RCH: u3,
                reserved29: u2,
                ///  Fast conversion mode selection for regular conversions
                FAST: u1,
                ///  Analog watchdog fast mode select
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM control register 2
            DFSDM0_CR2: mmio.Mmio(packed struct(u32) {
                ///  Injected end of conversion interrupt enable
                JEOCIE: u1,
                ///  Regular end of conversion interrupt enable
                REOCIE: u1,
                ///  Injected data overrun interrupt enable
                JOVRIE: u1,
                ///  Regular data overrun interrupt enable
                ROVRIE: u1,
                ///  Analog watchdog interrupt enable
                AWDIE: u1,
                ///  Short-circuit detector interrupt enable
                SCDIE: u1,
                ///  Clock absence interrupt enable
                CKABIE: u1,
                reserved8: u1,
                ///  Extremes detector channel selection
                EXCH: u8,
                ///  Analog watchdog channel selection
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM control register 2
            DFSDM1_CR2: mmio.Mmio(packed struct(u32) {
                ///  Injected end of conversion interrupt enable
                JEOCIE: u1,
                ///  Regular end of conversion interrupt enable
                REOCIE: u1,
                ///  Injected data overrun interrupt enable
                JOVRIE: u1,
                ///  Regular data overrun interrupt enable
                ROVRIE: u1,
                ///  Analog watchdog interrupt enable
                AWDIE: u1,
                ///  Short-circuit detector interrupt enable
                SCDIE: u1,
                ///  Clock absence interrupt enable
                CKABIE: u1,
                reserved8: u1,
                ///  Extremes detector channel selection
                EXCH: u8,
                ///  Analog watchdog channel selection
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM control register 2
            DFSDM2_CR2: mmio.Mmio(packed struct(u32) {
                ///  Injected end of conversion interrupt enable
                JEOCIE: u1,
                ///  Regular end of conversion interrupt enable
                REOCIE: u1,
                ///  Injected data overrun interrupt enable
                JOVRIE: u1,
                ///  Regular data overrun interrupt enable
                ROVRIE: u1,
                ///  Analog watchdog interrupt enable
                AWDIE: u1,
                ///  Short-circuit detector interrupt enable
                SCDIE: u1,
                ///  Clock absence interrupt enable
                CKABIE: u1,
                reserved8: u1,
                ///  Extremes detector channel selection
                EXCH: u8,
                ///  Analog watchdog channel selection
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM control register 2
            DFSDM3_CR2: mmio.Mmio(packed struct(u32) {
                ///  Injected end of conversion interrupt enable
                JEOCIE: u1,
                ///  Regular end of conversion interrupt enable
                REOCIE: u1,
                ///  Injected data overrun interrupt enable
                JOVRIE: u1,
                ///  Regular data overrun interrupt enable
                ROVRIE: u1,
                ///  Analog watchdog interrupt enable
                AWDIE: u1,
                ///  Short-circuit detector interrupt enable
                SCDIE: u1,
                ///  Clock absence interrupt enable
                CKABIE: u1,
                reserved8: u1,
                ///  Extremes detector channel selection
                EXCH: u8,
                ///  Analog watchdog channel selection
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM interrupt and status register
            DFSDM0_ISR: mmio.Mmio(packed struct(u32) {
                ///  End of injected conversion flag
                JEOCF: u1,
                ///  End of regular conversion flag
                REOCF: u1,
                ///  Injected conversion overrun flag
                JOVRF: u1,
                ///  Regular conversion overrun flag
                ROVRF: u1,
                ///  Analog watchdog
                AWDF: u1,
                reserved13: u8,
                ///  Injected conversion in progress status
                JCIP: u1,
                ///  Regular conversion in progress status
                RCIP: u1,
                reserved16: u1,
                ///  Clock absence flag
                CKABF: u8,
                ///  short-circuit detector flag
                SCDF: u8,
            }),
            ///  DFSDM interrupt and status register
            DFSDM1_ISR: mmio.Mmio(packed struct(u32) {
                ///  End of injected conversion flag
                JEOCF: u1,
                ///  End of regular conversion flag
                REOCF: u1,
                ///  Injected conversion overrun flag
                JOVRF: u1,
                ///  Regular conversion overrun flag
                ROVRF: u1,
                ///  Analog watchdog
                AWDF: u1,
                reserved13: u8,
                ///  Injected conversion in progress status
                JCIP: u1,
                ///  Regular conversion in progress status
                RCIP: u1,
                reserved16: u1,
                ///  Clock absence flag
                CKABF: u8,
                ///  short-circuit detector flag
                SCDF: u8,
            }),
            ///  DFSDM interrupt and status register
            DFSDM2_ISR: mmio.Mmio(packed struct(u32) {
                ///  End of injected conversion flag
                JEOCF: u1,
                ///  End of regular conversion flag
                REOCF: u1,
                ///  Injected conversion overrun flag
                JOVRF: u1,
                ///  Regular conversion overrun flag
                ROVRF: u1,
                ///  Analog watchdog
                AWDF: u1,
                reserved13: u8,
                ///  Injected conversion in progress status
                JCIP: u1,
                ///  Regular conversion in progress status
                RCIP: u1,
                reserved16: u1,
                ///  Clock absence flag
                CKABF: u8,
                ///  short-circuit detector flag
                SCDF: u8,
            }),
            ///  DFSDM interrupt and status register
            DFSDM3_ISR: mmio.Mmio(packed struct(u32) {
                ///  End of injected conversion flag
                JEOCF: u1,
                ///  End of regular conversion flag
                REOCF: u1,
                ///  Injected conversion overrun flag
                JOVRF: u1,
                ///  Regular conversion overrun flag
                ROVRF: u1,
                ///  Analog watchdog
                AWDF: u1,
                reserved13: u8,
                ///  Injected conversion in progress status
                JCIP: u1,
                ///  Regular conversion in progress status
                RCIP: u1,
                reserved16: u1,
                ///  Clock absence flag
                CKABF: u8,
                ///  short-circuit detector flag
                SCDF: u8,
            }),
            ///  DFSDM interrupt flag clear register
            DFSDM0_ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Clear the injected conversion overrun flag
                CLRJOVRF: u1,
                ///  Clear the regular conversion overrun flag
                CLRROVRF: u1,
                reserved16: u12,
                ///  Clear the clock absence flag
                CLRCKABF: u8,
                ///  Clear the short-circuit detector flag
                CLRSCDF: u8,
            }),
            ///  DFSDM interrupt flag clear register
            DFSDM1_ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Clear the injected conversion overrun flag
                CLRJOVRF: u1,
                ///  Clear the regular conversion overrun flag
                CLRROVRF: u1,
                reserved16: u12,
                ///  Clear the clock absence flag
                CLRCKABF: u8,
                ///  Clear the short-circuit detector flag
                CLRSCDF: u8,
            }),
            ///  DFSDM interrupt flag clear register
            DFSDM2_ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Clear the injected conversion overrun flag
                CLRJOVRF: u1,
                ///  Clear the regular conversion overrun flag
                CLRROVRF: u1,
                reserved16: u12,
                ///  Clear the clock absence flag
                CLRCKABF: u8,
                ///  Clear the short-circuit detector flag
                CLRSCDF: u8,
            }),
            ///  DFSDM interrupt flag clear register
            DFSDM3_ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Clear the injected conversion overrun flag
                CLRJOVRF: u1,
                ///  Clear the regular conversion overrun flag
                CLRROVRF: u1,
                reserved16: u12,
                ///  Clear the clock absence flag
                CLRCKABF: u8,
                ///  Clear the short-circuit detector flag
                CLRSCDF: u8,
            }),
            ///  DFSDM injected channel group selection register
            DFSDM0_JCHGR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel group selection
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM injected channel group selection register
            DFSDM1_JCHGR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel group selection
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM injected channel group selection register
            DFSDM2_JCHGR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel group selection
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM injected channel group selection register
            DFSDM3_JCHGR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel group selection
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter control register
            DFSDM0_FCR: mmio.Mmio(packed struct(u32) {
                ///  Integrator oversampling ratio (averaging length)
                IOSR: u8,
                reserved16: u8,
                ///  Sinc filter oversampling ratio (decimation rate)
                FOSR: u10,
                reserved29: u3,
                ///  Sinc filter order
                FORD: u3,
            }),
            ///  DFSDM filter control register
            DFSDM1_FCR: mmio.Mmio(packed struct(u32) {
                ///  Integrator oversampling ratio (averaging length)
                IOSR: u8,
                reserved16: u8,
                ///  Sinc filter oversampling ratio (decimation rate)
                FOSR: u10,
                reserved29: u3,
                ///  Sinc filter order
                FORD: u3,
            }),
            ///  DFSDM filter control register
            DFSDM2_FCR: mmio.Mmio(packed struct(u32) {
                ///  Integrator oversampling ratio (averaging length)
                IOSR: u8,
                reserved16: u8,
                ///  Sinc filter oversampling ratio (decimation rate)
                FOSR: u10,
                reserved29: u3,
                ///  Sinc filter order
                FORD: u3,
            }),
            ///  DFSDM filter control register
            DFSDM3_FCR: mmio.Mmio(packed struct(u32) {
                ///  Integrator oversampling ratio (averaging length)
                IOSR: u8,
                reserved16: u8,
                ///  Sinc filter oversampling ratio (decimation rate)
                FOSR: u10,
                reserved29: u3,
                ///  Sinc filter order
                FORD: u3,
            }),
            ///  DFSDM data register for injected group
            DFSDM0_JDATAR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel most recently converted
                JDATACH: u3,
                reserved8: u5,
                ///  Injected group conversion data
                JDATA: u24,
            }),
            ///  DFSDM data register for injected group
            DFSDM1_JDATAR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel most recently converted
                JDATACH: u3,
                reserved8: u5,
                ///  Injected group conversion data
                JDATA: u24,
            }),
            ///  DFSDM data register for injected group
            DFSDM2_JDATAR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel most recently converted
                JDATACH: u3,
                reserved8: u5,
                ///  Injected group conversion data
                JDATA: u24,
            }),
            ///  DFSDM data register for injected group
            DFSDM3_JDATAR: mmio.Mmio(packed struct(u32) {
                ///  Injected channel most recently converted
                JDATACH: u3,
                reserved8: u5,
                ///  Injected group conversion data
                JDATA: u24,
            }),
            ///  DFSDM data register for the regular channel
            DFSDM0_RDATAR: mmio.Mmio(packed struct(u32) {
                ///  Regular channel most recently converted
                RDATACH: u3,
                reserved4: u1,
                ///  Regular channel pending data
                RPEND: u1,
                reserved8: u3,
                ///  Regular channel conversion data
                RDATA: u24,
            }),
            ///  DFSDM data register for the regular channel
            DFSDM1_RDATAR: mmio.Mmio(packed struct(u32) {
                ///  Regular channel most recently converted
                RDATACH: u3,
                reserved4: u1,
                ///  Regular channel pending data
                RPEND: u1,
                reserved8: u3,
                ///  Regular channel conversion data
                RDATA: u24,
            }),
            ///  DFSDM data register for the regular channel
            DFSDM2_RDATAR: mmio.Mmio(packed struct(u32) {
                ///  Regular channel most recently converted
                RDATACH: u3,
                reserved4: u1,
                ///  Regular channel pending data
                RPEND: u1,
                reserved8: u3,
                ///  Regular channel conversion data
                RDATA: u24,
            }),
            ///  DFSDM data register for the regular channel
            DFSDM3_RDATAR: mmio.Mmio(packed struct(u32) {
                ///  Regular channel most recently converted
                RDATACH: u3,
                reserved4: u1,
                ///  Regular channel pending data
                RPEND: u1,
                reserved8: u3,
                ///  Regular channel conversion data
                RDATA: u24,
            }),
            ///  DFSDM analog watchdog high threshold register
            DFSDM0_AWHTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog high threshold event
                BKAWH: u4,
                reserved8: u4,
                ///  Analog watchdog high threshold
                AWHT: u24,
            }),
            ///  DFSDM analog watchdog high threshold register
            DFSDM1_AWHTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog high threshold event
                BKAWH: u4,
                reserved8: u4,
                ///  Analog watchdog high threshold
                AWHT: u24,
            }),
            ///  DFSDM analog watchdog high threshold register
            DFSDM2_AWHTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog high threshold event
                BKAWH: u4,
                reserved8: u4,
                ///  Analog watchdog high threshold
                AWHT: u24,
            }),
            ///  DFSDM analog watchdog high threshold register
            DFSDM3_AWHTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog high threshold event
                BKAWH: u4,
                reserved8: u4,
                ///  Analog watchdog high threshold
                AWHT: u24,
            }),
            ///  DFSDM analog watchdog low threshold register
            DFSDM0_AWLTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog low threshold event
                BKAWL: u4,
                reserved8: u4,
                ///  Analog watchdog low threshold
                AWLT: u24,
            }),
            ///  DFSDM analog watchdog low threshold register
            DFSDM1_AWLTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog low threshold event
                BKAWL: u4,
                reserved8: u4,
                ///  Analog watchdog low threshold
                AWLT: u24,
            }),
            ///  DFSDM analog watchdog low threshold register
            DFSDM2_AWLTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog low threshold event
                BKAWL: u4,
                reserved8: u4,
                ///  Analog watchdog low threshold
                AWLT: u24,
            }),
            ///  DFSDM analog watchdog low threshold register
            DFSDM3_AWLTR: mmio.Mmio(packed struct(u32) {
                ///  Break signal assignment to analog watchdog low threshold event
                BKAWL: u4,
                reserved8: u4,
                ///  Analog watchdog low threshold
                AWLT: u24,
            }),
            ///  DFSDM analog watchdog status register
            DFSDM0_AWSR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog low threshold flag
                AWLTF: u8,
                ///  Analog watchdog high threshold flag
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog status register
            DFSDM1_AWSR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog low threshold flag
                AWLTF: u8,
                ///  Analog watchdog high threshold flag
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog status register
            DFSDM2_AWSR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog low threshold flag
                AWLTF: u8,
                ///  Analog watchdog high threshold flag
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog status register
            DFSDM3_AWSR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog low threshold flag
                AWLTF: u8,
                ///  Analog watchdog high threshold flag
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog clear flag register
            DFSDM0_AWCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the analog watchdog low threshold flag
                CLRAWLTF: u8,
                ///  Clear the analog watchdog high threshold flag
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog clear flag register
            DFSDM1_AWCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the analog watchdog low threshold flag
                CLRAWLTF: u8,
                ///  Clear the analog watchdog high threshold flag
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog clear flag register
            DFSDM2_AWCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the analog watchdog low threshold flag
                CLRAWLTF: u8,
                ///  Clear the analog watchdog high threshold flag
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM analog watchdog clear flag register
            DFSDM3_AWCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear the analog watchdog low threshold flag
                CLRAWLTF: u8,
                ///  Clear the analog watchdog high threshold flag
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM Extremes detector maximum register
            DFSDM0_EXMAX: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector maximum data channel
                EXMAXCH: u3,
                reserved8: u5,
                ///  Extremes detector maximum value
                EXMAX: u24,
            }),
            ///  DFSDM Extremes detector maximum register
            DFSDM1_EXMAX: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector maximum data channel
                EXMAXCH: u3,
                reserved8: u5,
                ///  Extremes detector maximum value
                EXMAX: u24,
            }),
            ///  DFSDM Extremes detector maximum register
            DFSDM2_EXMAX: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector maximum data channel
                EXMAXCH: u3,
                reserved8: u5,
                ///  Extremes detector maximum value
                EXMAX: u24,
            }),
            ///  DFSDM Extremes detector maximum register
            DFSDM3_EXMAX: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector maximum data channel
                EXMAXCH: u3,
                reserved8: u5,
                ///  Extremes detector maximum value
                EXMAX: u24,
            }),
            ///  DFSDM Extremes detector minimum register
            DFSDM0_EXMIN: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector minimum data channel
                EXMINCH: u3,
                reserved8: u5,
                ///  Extremes detector minimum value
                EXMIN: u24,
            }),
            ///  DFSDM Extremes detector minimum register
            DFSDM1_EXMIN: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector minimum data channel
                EXMINCH: u3,
                reserved8: u5,
                ///  Extremes detector minimum value
                EXMIN: u24,
            }),
            ///  DFSDM Extremes detector minimum register
            DFSDM2_EXMIN: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector minimum data channel
                EXMINCH: u3,
                reserved8: u5,
                ///  Extremes detector minimum value
                EXMIN: u24,
            }),
            ///  DFSDM Extremes detector minimum register
            DFSDM3_EXMIN: mmio.Mmio(packed struct(u32) {
                ///  Extremes detector minimum data channel
                EXMINCH: u3,
                reserved8: u5,
                ///  Extremes detector minimum value
                EXMIN: u24,
            }),
            ///  DFSDM conversion timer register
            DFSDM0_CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  28-bit timer counting conversion time
                CNVCNT: u28,
            }),
            ///  DFSDM conversion timer register
            DFSDM1_CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  28-bit timer counting conversion time
                CNVCNT: u28,
            }),
            ///  DFSDM conversion timer register
            DFSDM2_CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  28-bit timer counting conversion time
                CNVCNT: u28,
            }),
            ///  DFSDM conversion timer register
            DFSDM3_CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  28-bit timer counting conversion time
                CNVCNT: u28,
            }),
        };

        ///  USB 1 on the go high speed
        pub const OTG1_HS_HOST = extern struct {
            ///  OTG_HS host configuration register
            OTG_HS_HCFG: mmio.Mmio(packed struct(u32) {
                ///  FS/LS PHY clock select
                FSLSPCS: u2,
                ///  FS- and LS-only support
                FSLSS: u1,
                padding: u29,
            }),
            ///  OTG_HS Host frame interval register
            OTG_HS_HFIR: mmio.Mmio(packed struct(u32) {
                ///  Frame interval
                FRIVL: u16,
                padding: u16,
            }),
            ///  OTG_HS host frame number/frame time remaining register
            OTG_HS_HFNUM: mmio.Mmio(packed struct(u32) {
                ///  Frame number
                FRNUM: u16,
                ///  Frame time remaining
                FTREM: u16,
            }),
            reserved16: [4]u8,
            ///  OTG_HS_Host periodic transmit FIFO/queue status register
            OTG_HS_HPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  Periodic transmit data FIFO space available
                PTXFSAVL: u16,
                ///  Periodic transmit request queue space available
                PTXQSAV: u8,
                ///  Top of the periodic transmit request queue
                PTXQTOP: u8,
            }),
            ///  OTG_HS Host all channels interrupt register
            OTG_HS_HAINT: mmio.Mmio(packed struct(u32) {
                ///  Channel interrupts
                HAINT: u16,
                padding: u16,
            }),
            ///  OTG_HS host all channels interrupt mask register
            OTG_HS_HAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  Channel interrupt mask
                HAINTM: u16,
                padding: u16,
            }),
            reserved64: [36]u8,
            ///  OTG_HS host port control and status register
            OTG_HS_HPRT: mmio.Mmio(packed struct(u32) {
                ///  Port connect status
                PCSTS: u1,
                ///  Port connect detected
                PCDET: u1,
                ///  Port enable
                PENA: u1,
                ///  Port enable/disable change
                PENCHNG: u1,
                ///  Port overcurrent active
                POCA: u1,
                ///  Port overcurrent change
                POCCHNG: u1,
                ///  Port resume
                PRES: u1,
                ///  Port suspend
                PSUSP: u1,
                ///  Port reset
                PRST: u1,
                reserved10: u1,
                ///  Port line status
                PLSTS: u2,
                ///  Port power
                PPWR: u1,
                ///  Port test control
                PTCTL: u4,
                ///  Port speed
                PSPD: u2,
                padding: u13,
            }),
            reserved256: [188]u8,
            ///  OTG_HS host channel-0 characteristics register
            OTG_HS_HCCHAR0: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-0 split control register
            OTG_HS_HCSPLT0: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-11 interrupt register
            OTG_HS_HCINT0: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-11 interrupt mask register
            OTG_HS_HCINTMSK0: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-11 transfer size register
            OTG_HS_HCTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-0 DMA address register
            OTG_HS_HCDMA0: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved288: [8]u8,
            ///  OTG_HS host channel-1 characteristics register
            OTG_HS_HCCHAR1: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-1 split control register
            OTG_HS_HCSPLT1: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-1 interrupt register
            OTG_HS_HCINT1: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-1 interrupt mask register
            OTG_HS_HCINTMSK1: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-1 transfer size register
            OTG_HS_HCTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-1 DMA address register
            OTG_HS_HCDMA1: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved320: [8]u8,
            ///  OTG_HS host channel-2 characteristics register
            OTG_HS_HCCHAR2: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-2 split control register
            OTG_HS_HCSPLT2: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-2 interrupt register
            OTG_HS_HCINT2: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-2 interrupt mask register
            OTG_HS_HCINTMSK2: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-2 transfer size register
            OTG_HS_HCTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-2 DMA address register
            OTG_HS_HCDMA2: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved352: [8]u8,
            ///  OTG_HS host channel-3 characteristics register
            OTG_HS_HCCHAR3: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-3 split control register
            OTG_HS_HCSPLT3: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-3 interrupt register
            OTG_HS_HCINT3: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-3 interrupt mask register
            OTG_HS_HCINTMSK3: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-3 transfer size register
            OTG_HS_HCTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-3 DMA address register
            OTG_HS_HCDMA3: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved384: [8]u8,
            ///  OTG_HS host channel-4 characteristics register
            OTG_HS_HCCHAR4: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-4 split control register
            OTG_HS_HCSPLT4: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-4 interrupt register
            OTG_HS_HCINT4: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-4 interrupt mask register
            OTG_HS_HCINTMSK4: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-4 transfer size register
            OTG_HS_HCTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-4 DMA address register
            OTG_HS_HCDMA4: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved416: [8]u8,
            ///  OTG_HS host channel-5 characteristics register
            OTG_HS_HCCHAR5: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-5 split control register
            OTG_HS_HCSPLT5: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-5 interrupt register
            OTG_HS_HCINT5: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-5 interrupt mask register
            OTG_HS_HCINTMSK5: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-5 transfer size register
            OTG_HS_HCTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-5 DMA address register
            OTG_HS_HCDMA5: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved448: [8]u8,
            ///  OTG_HS host channel-6 characteristics register
            OTG_HS_HCCHAR6: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-6 split control register
            OTG_HS_HCSPLT6: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-6 interrupt register
            OTG_HS_HCINT6: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-6 interrupt mask register
            OTG_HS_HCINTMSK6: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-6 transfer size register
            OTG_HS_HCTSIZ6: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-6 DMA address register
            OTG_HS_HCDMA6: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved480: [8]u8,
            ///  OTG_HS host channel-7 characteristics register
            OTG_HS_HCCHAR7: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-7 split control register
            OTG_HS_HCSPLT7: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-7 interrupt register
            OTG_HS_HCINT7: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-7 interrupt mask register
            OTG_HS_HCINTMSK7: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-7 transfer size register
            OTG_HS_HCTSIZ7: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-7 DMA address register
            OTG_HS_HCDMA7: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved512: [8]u8,
            ///  OTG_HS host channel-8 characteristics register
            OTG_HS_HCCHAR8: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-8 split control register
            OTG_HS_HCSPLT8: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-8 interrupt register
            OTG_HS_HCINT8: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-8 interrupt mask register
            OTG_HS_HCINTMSK8: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-8 transfer size register
            OTG_HS_HCTSIZ8: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-8 DMA address register
            OTG_HS_HCDMA8: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved544: [8]u8,
            ///  OTG_HS host channel-9 characteristics register
            OTG_HS_HCCHAR9: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-9 split control register
            OTG_HS_HCSPLT9: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-9 interrupt register
            OTG_HS_HCINT9: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-9 interrupt mask register
            OTG_HS_HCINTMSK9: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-9 transfer size register
            OTG_HS_HCTSIZ9: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-9 DMA address register
            OTG_HS_HCDMA9: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved576: [8]u8,
            ///  OTG_HS host channel-10 characteristics register
            OTG_HS_HCCHAR10: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-10 split control register
            OTG_HS_HCSPLT10: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-10 interrupt register
            OTG_HS_HCINT10: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-10 interrupt mask register
            OTG_HS_HCINTMSK10: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-10 transfer size register
            OTG_HS_HCTSIZ10: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-10 DMA address register
            OTG_HS_HCDMA10: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            reserved608: [8]u8,
            ///  OTG_HS host channel-11 characteristics register
            OTG_HS_HCCHAR11: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-11 split control register
            OTG_HS_HCSPLT11: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-11 interrupt register
            OTG_HS_HCINT11: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-11 interrupt mask register
            OTG_HS_HCINTMSK11: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  response received interrupt mask
                NYET: u1,
                ///  Transaction error mask
                TXERRM: u1,
                ///  Babble error mask
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-11 transfer size register
            OTG_HS_HCTSIZ11: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-11 DMA address register
            OTG_HS_HCDMA11: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS host channel-12 characteristics register
            OTG_HS_HCCHAR12: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-12 split control register
            OTG_HS_HCSPLT12: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-12 interrupt register
            OTG_HS_HCINT12: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-12 interrupt mask register
            OTG_HS_HCINTMSK12: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERRM: u1,
                ///  Babble error
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-12 transfer size register
            OTG_HS_HCTSIZ12: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-12 DMA address register
            OTG_HS_HCDMA12: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS host channel-13 characteristics register
            OTG_HS_HCCHAR13: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-13 split control register
            OTG_HS_HCSPLT13: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-13 interrupt register
            OTG_HS_HCINT13: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-13 interrupt mask register
            OTG_HS_HCINTMSK13: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALLM response received interrupt mask
                STALLM: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERRM: u1,
                ///  Babble error
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-13 transfer size register
            OTG_HS_HCTSIZ13: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-13 DMA address register
            OTG_HS_HCDMA13: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS host channel-14 characteristics register
            OTG_HS_HCCHAR14: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-14 split control register
            OTG_HS_HCSPLT14: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-14 interrupt register
            OTG_HS_HCINT14: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-14 interrupt mask register
            OTG_HS_HCINTMSK14: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALLM: u1,
                ///  NAKM response received interrupt mask
                NAKM: u1,
                ///  ACKM response received/transmitted interrupt mask
                ACKM: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERRM: u1,
                ///  Babble error
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-14 transfer size register
            OTG_HS_HCTSIZ14: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-14 DMA address register
            OTG_HS_HCDMA14: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS host channel-15 characteristics register
            OTG_HS_HCCHAR15: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                ///  Endpoint number
                EPNUM: u4,
                ///  Endpoint direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-speed device
                LSDEV: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Multi Count (MC) / Error Count (EC)
                MC: u2,
                ///  Device address
                DAD: u7,
                ///  Odd frame
                ODDFRM: u1,
                ///  Channel disable
                CHDIS: u1,
                ///  Channel enable
                CHENA: u1,
            }),
            ///  OTG_HS host channel-15 split control register
            OTG_HS_HCSPLT15: mmio.Mmio(packed struct(u32) {
                ///  Port address
                PRTADDR: u7,
                ///  Hub address
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  Do complete split
                COMPLSPLT: u1,
                reserved31: u14,
                ///  Split enable
                SPLITEN: u1,
            }),
            ///  OTG_HS host channel-15 interrupt register
            OTG_HS_HCINT15: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed
                XFRC: u1,
                ///  Channel halted
                CHH: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt
                STALL: u1,
                ///  NAK response received interrupt
                NAK: u1,
                ///  ACK response received/transmitted interrupt
                ACK: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERR: u1,
                ///  Babble error
                BBERR: u1,
                ///  Frame overrun
                FRMOR: u1,
                ///  Data toggle error
                DTERR: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-15 interrupt mask register
            OTG_HS_HCINTMSK15: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed mask
                XFRCM: u1,
                ///  Channel halted mask
                CHHM: u1,
                ///  AHB error
                AHBERR: u1,
                ///  STALL response received interrupt mask
                STALL: u1,
                ///  NAK response received interrupt mask
                NAKM: u1,
                ///  ACK response received/transmitted interrupt mask
                ACKM: u1,
                ///  Response received interrupt
                NYET: u1,
                ///  Transaction error
                TXERRM: u1,
                ///  Babble error
                BBERRM: u1,
                ///  Frame overrun mask
                FRMORM: u1,
                ///  Data toggle error mask
                DTERRM: u1,
                padding: u21,
            }),
            ///  OTG_HS host channel-15 transfer size register
            OTG_HS_HCTSIZ15: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Data PID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG_HS host channel-15 DMA address register
            OTG_HS_HCDMA15: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
        };

        ///  General-purpose-timers
        pub const TIM16 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: u1,
                ///  Clock division
                CKD: u2,
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare preloaded control
                CCPC: u1,
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: u1,
                ///  Capture/compare DMA selection
                CCDS: u1,
                reserved8: u4,
                ///  Output Idle state 1
                OIS1: u1,
                ///  Output Idle state 1
                OIS1N: u1,
                padding: u22,
            }),
            reserved12: [4]u8,
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                ///  Capture/Compare 1 interrupt enable
                CC1IE: u1,
                reserved5: u3,
                ///  COM interrupt enable
                COMIE: u1,
                reserved7: u1,
                ///  Break interrupt enable
                BIE: u1,
                ///  Update DMA request enable
                UDE: u1,
                ///  Capture/Compare 1 DMA request enable
                CC1DE: u1,
                reserved13: u3,
                ///  COM DMA request enable
                COMDE: u1,
                padding: u18,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                ///  Capture/compare 1 interrupt flag
                CC1IF: u1,
                reserved5: u3,
                ///  COM interrupt flag
                COMIF: u1,
                reserved7: u1,
                ///  Break interrupt flag
                BIF: u1,
                reserved9: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: u1,
                padding: u22,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                reserved5: u3,
                ///  Capture/Compare control update generation
                COMG: u1,
                reserved7: u1,
                ///  Break generation
                BG: u1,
                padding: u24,
            }),
            ///  capture/compare mode register (output mode)
            CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: u2,
                ///  Output Compare 1 fast enable
                OC1FE: u1,
                ///  Output Compare 1 preload enable
                OC1PE: u1,
                ///  Output Compare 1 mode
                OC1M: u3,
                reserved16: u9,
                ///  Output Compare 1 mode
                OC1M_3: u1,
                padding: u15,
            }),
            reserved32: [4]u8,
            ///  capture/compare enable register
            CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable
                CC1E: u1,
                ///  Capture/Compare 1 output Polarity
                CC1P: u1,
                ///  Capture/Compare 1 complementary output enable
                CC1NE: u1,
                ///  Capture/Compare 1 output Polarity
                CC1NP: u1,
                padding: u28,
            }),
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy
                UIFCPY: u1,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto-reload value
                ARR: u16,
                padding: u16,
            }),
            ///  repetition counter register
            RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition counter value
                REP: u8,
                padding: u24,
            }),
            ///  capture/compare register 1
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 value
                CCR1: u16,
                padding: u16,
            }),
            reserved68: [12]u8,
            ///  break and dead-time register
            BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: u2,
                ///  Off-state selection for Idle mode
                OSSI: u1,
                ///  Off-state selection for Run mode
                OSSR: u1,
                ///  Break enable
                BKE: u1,
                ///  Break polarity
                BKP: u1,
                ///  Automatic output enable
                AOE: u1,
                ///  Main output enable
                MOE: u1,
                ///  Break filter
                BKF: u4,
                padding: u12,
            }),
            ///  DMA control register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  DMA base address
                DBA: u5,
                reserved8: u3,
                ///  DMA burst length
                DBL: u5,
                padding: u19,
            }),
            ///  DMA address for full transfer
            DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses
                DMAB: u16,
                padding: u16,
            }),
            reserved96: [16]u8,
            ///  TIM16 alternate function register 1
            TIM16_AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: u1,
                ///  BRK COMP1 enable
                BKCMP1E: u1,
                ///  BRK COMP2 enable
                BKCMP2E: u1,
                reserved8: u5,
                ///  BRK dfsdm1_break[1] enable
                BKDFBK1E: u1,
                ///  BRK BKIN input polarity
                BKINP: u1,
                ///  BRK COMP1 input polarity
                BKCMP1P: u1,
                ///  BRK COMP2 input polarity
                BKCMP2P: u1,
                padding: u20,
            }),
            reserved104: [4]u8,
            ///  TIM16 input selection register
            TIM16_TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: u4,
                padding: u28,
            }),
        };

        ///  USB 1 on the go high speed
        pub const OTG1_HS_DEVICE = extern struct {
            ///  OTG_HS device configuration register
            OTG_HS_DCFG: mmio.Mmio(packed struct(u32) {
                ///  Device speed
                DSPD: u2,
                ///  Nonzero-length status OUT handshake
                NZLSOHSK: u1,
                reserved4: u1,
                ///  Device address
                DAD: u7,
                ///  Periodic (micro)frame interval
                PFIVL: u2,
                reserved24: u11,
                ///  Periodic scheduling interval
                PERSCHIVL: u2,
                padding: u6,
            }),
            ///  OTG_HS device control register
            OTG_HS_DCTL: mmio.Mmio(packed struct(u32) {
                ///  Remote wakeup signaling
                RWUSIG: u1,
                ///  Soft disconnect
                SDIS: u1,
                ///  Global IN NAK status
                GINSTS: u1,
                ///  Global OUT NAK status
                GONSTS: u1,
                ///  Test control
                TCTL: u3,
                ///  Set global IN NAK
                SGINAK: u1,
                ///  Clear global IN NAK
                CGINAK: u1,
                ///  Set global OUT NAK
                SGONAK: u1,
                ///  Clear global OUT NAK
                CGONAK: u1,
                ///  Power-on programming done
                POPRGDNE: u1,
                padding: u20,
            }),
            ///  OTG_HS device status register
            OTG_HS_DSTS: mmio.Mmio(packed struct(u32) {
                ///  Suspend status
                SUSPSTS: u1,
                ///  Enumerated speed
                ENUMSPD: u2,
                ///  Erratic error
                EERR: u1,
                reserved8: u4,
                ///  Frame number of the received SOF
                FNSOF: u14,
                padding: u10,
            }),
            reserved16: [4]u8,
            ///  OTG_HS device IN endpoint common interrupt mask register
            OTG_HS_DIEPMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt mask
                XFRCM: u1,
                ///  Endpoint disabled interrupt mask
                EPDM: u1,
                reserved3: u1,
                ///  Timeout condition mask (nonisochronous endpoints)
                TOM: u1,
                ///  IN token received when TxFIFO empty mask
                ITTXFEMSK: u1,
                ///  IN token received with EP mismatch mask
                INEPNMM: u1,
                ///  IN endpoint NAK effective mask
                INEPNEM: u1,
                reserved8: u1,
                ///  FIFO underrun mask
                TXFURM: u1,
                ///  BNA interrupt mask
                BIM: u1,
                padding: u22,
            }),
            ///  OTG_HS device OUT endpoint common interrupt mask register
            OTG_HS_DOEPMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt mask
                XFRCM: u1,
                ///  Endpoint disabled interrupt mask
                EPDM: u1,
                reserved3: u1,
                ///  SETUP phase done mask
                STUPM: u1,
                ///  OUT token received when endpoint disabled mask
                OTEPDM: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received mask
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUT packet error mask
                OPEM: u1,
                ///  BNA interrupt mask
                BOIM: u1,
                padding: u22,
            }),
            ///  OTG_HS device all endpoints interrupt register
            OTG_HS_DAINT: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint interrupt bits
                IEPINT: u16,
                ///  OUT endpoint interrupt bits
                OEPINT: u16,
            }),
            ///  OTG_HS all endpoints interrupt mask register
            OTG_HS_DAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  IN EP interrupt mask bits
                IEPM: u16,
                ///  OUT EP interrupt mask bits
                OEPM: u16,
            }),
            reserved40: [8]u8,
            ///  OTG_HS device VBUS discharge time register
            OTG_HS_DVBUSDIS: mmio.Mmio(packed struct(u32) {
                ///  Device VBUS discharge time
                VBUSDT: u16,
                padding: u16,
            }),
            ///  OTG_HS device VBUS pulsing time register
            OTG_HS_DVBUSPULSE: mmio.Mmio(packed struct(u32) {
                ///  Device VBUS pulsing time
                DVBUSP: u12,
                padding: u20,
            }),
            ///  OTG_HS Device threshold control register
            OTG_HS_DTHRCTL: mmio.Mmio(packed struct(u32) {
                ///  Nonisochronous IN endpoints threshold enable
                NONISOTHREN: u1,
                ///  ISO IN endpoint threshold enable
                ISOTHREN: u1,
                ///  Transmit threshold length
                TXTHRLEN: u9,
                reserved16: u5,
                ///  Receive threshold enable
                RXTHREN: u1,
                ///  Receive threshold length
                RXTHRLEN: u9,
                reserved27: u1,
                ///  Arbiter parking enable
                ARPEN: u1,
                padding: u4,
            }),
            ///  OTG_HS device IN endpoint FIFO empty interrupt mask register
            OTG_HS_DIEPEMPMSK: mmio.Mmio(packed struct(u32) {
                ///  IN EP Tx FIFO empty interrupt mask bits
                INEPTXFEM: u16,
                padding: u16,
            }),
            ///  OTG_HS device each endpoint interrupt register
            OTG_HS_DEACHINT: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  IN endpoint 1interrupt bit
                IEP1INT: u1,
                reserved17: u15,
                ///  OUT endpoint 1 interrupt bit
                OEP1INT: u1,
                padding: u14,
            }),
            ///  OTG_HS device each endpoint interrupt register mask
            OTG_HS_DEACHINTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  IN Endpoint 1 interrupt mask bit
                IEP1INTM: u1,
                reserved17: u15,
                ///  OUT Endpoint 1 interrupt mask bit
                OEP1INTM: u1,
                padding: u14,
            }),
            reserved256: [192]u8,
            ///  OTG device endpoint-0 control register
            OTG_HS_DIEPCTL0: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved264: [4]u8,
            ///  OTG device endpoint-0 interrupt register
            OTG_HS_DIEPINT0: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved272: [4]u8,
            ///  OTG_HS device IN endpoint 0 transfer size register
            OTG_HS_DIEPTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u7,
                reserved19: u12,
                ///  Packet count
                PKTCNT: u2,
                padding: u11,
            }),
            ///  OTG_HS device endpoint-1 DMA address register
            OTG_HS_DIEPDMA1: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS0: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved288: [4]u8,
            ///  OTG device endpoint-1 control register
            OTG_HS_DIEPCTL1: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved296: [4]u8,
            ///  OTG device endpoint-1 interrupt register
            OTG_HS_DIEPINT1: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved304: [4]u8,
            ///  OTG_HS device endpoint transfer size register
            OTG_HS_DIEPTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Multi count
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG_HS device endpoint-2 DMA address register
            OTG_HS_DIEPDMA2: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS1: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved320: [4]u8,
            ///  OTG device endpoint-2 control register
            OTG_HS_DIEPCTL2: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved328: [4]u8,
            ///  OTG device endpoint-2 interrupt register
            OTG_HS_DIEPINT2: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved336: [4]u8,
            ///  OTG_HS device endpoint transfer size register
            OTG_HS_DIEPTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Multi count
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG_HS device endpoint-3 DMA address register
            OTG_HS_DIEPDMA3: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS2: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved352: [4]u8,
            ///  OTG device endpoint-3 control register
            OTG_HS_DIEPCTL3: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved360: [4]u8,
            ///  OTG device endpoint-3 interrupt register
            OTG_HS_DIEPINT3: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved368: [4]u8,
            ///  OTG_HS device endpoint transfer size register
            OTG_HS_DIEPTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Multi count
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG_HS device endpoint-4 DMA address register
            OTG_HS_DIEPDMA4: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS3: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved384: [4]u8,
            ///  OTG device endpoint-4 control register
            OTG_HS_DIEPCTL4: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved392: [4]u8,
            ///  OTG device endpoint-4 interrupt register
            OTG_HS_DIEPINT4: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved400: [4]u8,
            ///  OTG_HS device endpoint transfer size register
            OTG_HS_DIEPTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Multi count
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG_HS device endpoint-5 DMA address register
            OTG_HS_DIEPDMA5: mmio.Mmio(packed struct(u32) {
                ///  DMA address
                DMAADDR: u32,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS4: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved416: [4]u8,
            ///  OTG device endpoint-5 control register
            OTG_HS_DIEPCTL5: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS6: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            ///  OTG device endpoint-5 interrupt register
            OTG_HS_DIEPINT5: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS7: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            ///  OTG_HS device endpoint transfer size register
            OTG_HS_DIEPTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Multi count
                MCNT: u2,
                padding: u1,
            }),
            reserved440: [4]u8,
            ///  OTG_HS device IN endpoint transmit FIFO status register
            OTG_HS_DTXFSTS5: mmio.Mmio(packed struct(u32) {
                ///  IN endpoint TxFIFO space avail
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved448: [4]u8,
            ///  OTG device endpoint-6 control register
            OTG_HS_DIEPCTL6: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved456: [4]u8,
            ///  OTG device endpoint-6 interrupt register
            OTG_HS_DIEPINT6: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved480: [20]u8,
            ///  OTG device endpoint-7 control register
            OTG_HS_DIEPCTL7: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even/odd frame
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                reserved21: u1,
                ///  STALL handshake
                Stall: u1,
                ///  TxFIFO number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved488: [4]u8,
            ///  OTG device endpoint-7 interrupt register
            OTG_HS_DIEPINT7: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  Timeout condition
                TOC: u1,
                ///  IN token received when TxFIFO is empty
                ITTXFE: u1,
                reserved6: u1,
                ///  IN endpoint NAK effective
                INEPNE: u1,
                ///  Transmit FIFO empty
                TXFE: u1,
                ///  Transmit Fifo Underrun
                TXFIFOUDRN: u1,
                ///  Buffer not available interrupt
                BNA: u1,
                reserved11: u1,
                ///  Packet dropped status
                PKTDRPSTS: u1,
                ///  Babble error interrupt
                BERR: u1,
                ///  NAK interrupt
                NAK: u1,
                padding: u18,
            }),
            reserved768: [276]u8,
            ///  OTG_HS device control OUT endpoint 0 control register
            OTG_HS_DOEPCTL0: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u2,
                reserved15: u13,
                ///  USB active endpoint
                USBAEP: u1,
                reserved17: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                reserved30: u2,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved776: [4]u8,
            ///  OTG_HS device endpoint-0 interrupt register
            OTG_HS_DOEPINT0: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved784: [4]u8,
            ///  OTG_HS device endpoint-0 transfer size register
            OTG_HS_DOEPTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u7,
                reserved19: u12,
                ///  Packet count
                PKTCNT: u1,
                reserved29: u9,
                ///  SETUP packet count
                STUPCNT: u2,
                padding: u1,
            }),
            reserved800: [12]u8,
            ///  OTG device endpoint-1 control register
            OTG_HS_DOEPCTL1: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved808: [4]u8,
            ///  OTG_HS device endpoint-1 interrupt register
            OTG_HS_DOEPINT1: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved816: [4]u8,
            ///  OTG_HS device endpoint-1 transfer size register
            OTG_HS_DOEPTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved832: [12]u8,
            ///  OTG device endpoint-2 control register
            OTG_HS_DOEPCTL2: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved840: [4]u8,
            ///  OTG_HS device endpoint-2 interrupt register
            OTG_HS_DOEPINT2: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved848: [4]u8,
            ///  OTG_HS device endpoint-2 transfer size register
            OTG_HS_DOEPTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved864: [12]u8,
            ///  OTG device endpoint-3 control register
            OTG_HS_DOEPCTL3: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved872: [4]u8,
            ///  OTG_HS device endpoint-3 interrupt register
            OTG_HS_DOEPINT3: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved880: [4]u8,
            ///  OTG_HS device endpoint-3 transfer size register
            OTG_HS_DOEPTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved896: [12]u8,
            ///  OTG device endpoint-4 control register
            OTG_HS_DOEPCTL4: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved904: [4]u8,
            ///  OTG_HS device endpoint-4 interrupt register
            OTG_HS_DOEPINT4: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved912: [4]u8,
            ///  OTG_HS device endpoint-4 transfer size register
            OTG_HS_DOEPTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved928: [12]u8,
            ///  OTG device endpoint-5 control register
            OTG_HS_DOEPCTL5: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved936: [4]u8,
            ///  OTG_HS device endpoint-5 interrupt register
            OTG_HS_DOEPINT5: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved944: [4]u8,
            ///  OTG_HS device endpoint-5 transfer size register
            OTG_HS_DOEPTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved960: [12]u8,
            ///  OTG device endpoint-6 control register
            OTG_HS_DOEPCTL6: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved968: [4]u8,
            ///  OTG_HS device endpoint-6 interrupt register
            OTG_HS_DOEPINT6: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved976: [4]u8,
            ///  OTG_HS device endpoint-6 transfer size register
            OTG_HS_DOEPTSIZ6: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            reserved992: [12]u8,
            ///  OTG device endpoint-7 control register
            OTG_HS_DOEPCTL7: mmio.Mmio(packed struct(u32) {
                ///  Maximum packet size
                MPSIZ: u11,
                reserved15: u4,
                ///  USB active endpoint
                USBAEP: u1,
                ///  Even odd frame/Endpoint data PID
                EONUM_DPID: u1,
                ///  NAK status
                NAKSTS: u1,
                ///  Endpoint type
                EPTYP: u2,
                ///  Snoop mode
                SNPM: u1,
                ///  STALL handshake
                Stall: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID/Set even frame
                SD0PID_SEVNFRM: u1,
                ///  Set odd frame
                SODDFRM: u1,
                ///  Endpoint disable
                EPDIS: u1,
                ///  Endpoint enable
                EPENA: u1,
            }),
            reserved1000: [4]u8,
            ///  OTG_HS device endpoint-7 interrupt register
            OTG_HS_DOEPINT7: mmio.Mmio(packed struct(u32) {
                ///  Transfer completed interrupt
                XFRC: u1,
                ///  Endpoint disabled interrupt
                EPDISD: u1,
                reserved3: u1,
                ///  SETUP phase done
                STUP: u1,
                ///  OUT token received when endpoint disabled
                OTEPDIS: u1,
                reserved6: u1,
                ///  Back-to-back SETUP packets received
                B2BSTUP: u1,
                reserved14: u7,
                ///  NYET interrupt
                NYET: u1,
                padding: u17,
            }),
            reserved1008: [4]u8,
            ///  OTG_HS device endpoint-7 transfer size register
            OTG_HS_DOEPTSIZ7: mmio.Mmio(packed struct(u32) {
                ///  Transfer size
                XFRSIZ: u19,
                ///  Packet count
                PKTCNT: u10,
                ///  Received data PID/SETUP packet count
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
        };

        ///  General-purpose-timers
        pub const TIM17 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: u1,
                ///  Clock division
                CKD: u2,
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare preloaded control
                CCPC: u1,
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: u1,
                ///  Capture/compare DMA selection
                CCDS: u1,
                reserved8: u4,
                ///  Output Idle state 1
                OIS1: u1,
                ///  Output Idle state 1
                OIS1N: u1,
                padding: u22,
            }),
            reserved12: [4]u8,
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                ///  Capture/Compare 1 interrupt enable
                CC1IE: u1,
                reserved5: u3,
                ///  COM interrupt enable
                COMIE: u1,
                reserved7: u1,
                ///  Break interrupt enable
                BIE: u1,
                ///  Update DMA request enable
                UDE: u1,
                ///  Capture/Compare 1 DMA request enable
                CC1DE: u1,
                reserved13: u3,
                ///  COM DMA request enable
                COMDE: u1,
                padding: u18,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                ///  Capture/compare 1 interrupt flag
                CC1IF: u1,
                reserved5: u3,
                ///  COM interrupt flag
                COMIF: u1,
                reserved7: u1,
                ///  Break interrupt flag
                BIF: u1,
                reserved9: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: u1,
                padding: u22,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                reserved5: u3,
                ///  Capture/Compare control update generation
                COMG: u1,
                reserved7: u1,
                ///  Break generation
                BG: u1,
                padding: u24,
            }),
            ///  capture/compare mode register (output mode)
            CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: u2,
                ///  Output Compare 1 fast enable
                OC1FE: u1,
                ///  Output Compare 1 preload enable
                OC1PE: u1,
                ///  Output Compare 1 mode
                OC1M: u3,
                reserved16: u9,
                ///  Output Compare 1 mode
                OC1M_3: u1,
                padding: u15,
            }),
            reserved32: [4]u8,
            ///  capture/compare enable register
            CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable
                CC1E: u1,
                ///  Capture/Compare 1 output Polarity
                CC1P: u1,
                ///  Capture/Compare 1 complementary output enable
                CC1NE: u1,
                ///  Capture/Compare 1 output Polarity
                CC1NP: u1,
                padding: u28,
            }),
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy
                UIFCPY: u1,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto-reload value
                ARR: u16,
                padding: u16,
            }),
            ///  repetition counter register
            RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition counter value
                REP: u8,
                padding: u24,
            }),
            ///  capture/compare register 1
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 value
                CCR1: u16,
                padding: u16,
            }),
            reserved68: [12]u8,
            ///  break and dead-time register
            BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: u2,
                ///  Off-state selection for Idle mode
                OSSI: u1,
                ///  Off-state selection for Run mode
                OSSR: u1,
                ///  Break enable
                BKE: u1,
                ///  Break polarity
                BKP: u1,
                ///  Automatic output enable
                AOE: u1,
                ///  Main output enable
                MOE: u1,
                ///  Break filter
                BKF: u4,
                padding: u12,
            }),
            ///  DMA control register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  DMA base address
                DBA: u5,
                reserved8: u3,
                ///  DMA burst length
                DBL: u5,
                padding: u19,
            }),
            ///  DMA address for full transfer
            DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses
                DMAB: u16,
                padding: u16,
            }),
            reserved96: [16]u8,
            ///  TIM17 alternate function register 1
            TIM17_AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: u1,
                ///  BRK COMP1 enable
                BKCMP1E: u1,
                ///  BRK COMP2 enable
                BKCMP2E: u1,
                reserved8: u5,
                ///  BRK dfsdm1_break[1] enable
                BKDFBK1E: u1,
                ///  BRK BKIN input polarity
                BKINP: u1,
                ///  BRK COMP1 input polarity
                BKCMP1P: u1,
                ///  BRK COMP2 input polarity
                BKCMP2P: u1,
                padding: u20,
            }),
            reserved104: [4]u8,
            ///  TIM17 input selection register
            TIM17_TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: u4,
                padding: u28,
            }),
        };

        ///  USB 1 on the go high speed
        pub const OTG1_HS_PWRCLK = extern struct {
            ///  Power and clock gating control register
            OTG_HS_PCGCR: mmio.Mmio(packed struct(u32) {
                ///  Stop PHY clock
                STPPCLK: u1,
                ///  Gate HCLK
                GATEHCLK: u1,
                reserved4: u2,
                ///  PHY suspended
                PHYSUSP: u1,
                padding: u27,
            }),
        };

        ///  General purpose timers
        pub const TIM15 = extern struct {
            ///  control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  Counter enable
                CEN: u1,
                ///  Update disable
                UDIS: u1,
                ///  Update request source
                URS: u1,
                ///  One-pulse mode
                OPM: u1,
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: u1,
                ///  Clock division
                CKD: u2,
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: u1,
                padding: u20,
            }),
            ///  control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare preloaded control
                CCPC: u1,
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: u1,
                ///  Capture/compare DMA selection
                CCDS: u1,
                ///  Master mode selection
                MMS: u3,
                ///  TI1 selection
                TI1S: u1,
                ///  Output Idle state 1
                OIS1: u1,
                ///  Output Idle state 1
                OIS1N: u1,
                ///  Output Idle state 2
                OIS2: u1,
                padding: u21,
            }),
            ///  slave mode control register
            SMCR: mmio.Mmio(packed struct(u32) {
                ///  Slave mode selection
                SMS: u3,
                reserved4: u1,
                ///  Trigger selection
                TS_2_0: u3,
                ///  Master/Slave mode
                MSM: u1,
                reserved16: u8,
                ///  Slave mode selection bit 3
                SMS_3: u1,
                reserved20: u3,
                ///  Trigger selection - bit 4:3
                TS_4_3: u2,
                padding: u10,
            }),
            ///  DMA/Interrupt enable register
            DIER: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt enable
                UIE: u1,
                ///  Capture/Compare 1 interrupt enable
                CC1IE: u1,
                ///  Capture/Compare 2 interrupt enable
                CC2IE: u1,
                reserved5: u2,
                ///  COM interrupt enable
                COMIE: u1,
                ///  Trigger interrupt enable
                TIE: u1,
                ///  Break interrupt enable
                BIE: u1,
                ///  Update DMA request enable
                UDE: u1,
                ///  Capture/Compare 1 DMA request enable
                CC1DE: u1,
                ///  Capture/Compare 2 DMA request enable
                CC2DE: u1,
                reserved13: u2,
                ///  COM DMA request enable
                COMDE: u1,
                ///  Trigger DMA request enable
                TDE: u1,
                padding: u17,
            }),
            ///  status register
            SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag
                UIF: u1,
                ///  Capture/compare 1 interrupt flag
                CC1IF: u1,
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                reserved5: u2,
                ///  COM interrupt flag
                COMIF: u1,
                ///  Trigger interrupt flag
                TIF: u1,
                ///  Break interrupt flag
                BIF: u1,
                reserved9: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: u1,
                ///  Capture/compare 2 overcapture flag
                CC2OF: u1,
                padding: u21,
            }),
            ///  event generation register
            EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                ///  Capture/compare 2 generation
                CC2G: u1,
                reserved5: u2,
                ///  Capture/Compare control update generation
                COMG: u1,
                ///  Trigger generation
                TG: u1,
                ///  Break generation
                BG: u1,
                padding: u24,
            }),
            ///  capture/compare mode register (output mode)
            CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: u2,
                ///  Output Compare 1 fast enable
                OC1FE: u1,
                ///  Output Compare 1 preload enable
                OC1PE: u1,
                ///  Output Compare 1 mode
                OC1M: u3,
                reserved8: u1,
                ///  Capture/Compare 2 selection
                CC2S: u2,
                ///  Output Compare 2 fast enable
                OC2FE: u1,
                ///  Output Compare 2 preload enable
                OC2PE: u1,
                ///  Output Compare 2 mode
                OC2M: u3,
                reserved16: u1,
                ///  Output Compare 1 mode bit 3
                OC1M_3: u1,
                reserved24: u7,
                ///  Output Compare 2 mode bit 3
                OC2M_3: u1,
                padding: u7,
            }),
            reserved32: [4]u8,
            ///  capture/compare enable register
            CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable
                CC1E: u1,
                ///  Capture/Compare 1 output Polarity
                CC1P: u1,
                ///  Capture/Compare 1 complementary output enable
                CC1NE: u1,
                ///  Capture/Compare 1 output Polarity
                CC1NP: u1,
                ///  Capture/Compare 2 output enable
                CC2E: u1,
                ///  Capture/Compare 2 output Polarity
                CC2P: u1,
                reserved7: u1,
                ///  Capture/Compare 2 output Polarity
                CC2NP: u1,
                padding: u24,
            }),
            ///  counter
            CNT: mmio.Mmio(packed struct(u32) {
                ///  counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF copy
                UIFCPY: u1,
            }),
            ///  prescaler
            PSC: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u16,
                padding: u16,
            }),
            ///  auto-reload register
            ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto-reload value
                ARR: u16,
                padding: u16,
            }),
            ///  repetition counter register
            RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition counter value
                REP: u8,
                padding: u24,
            }),
            ///  capture/compare register 1
            CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 value
                CCR1: u16,
                padding: u16,
            }),
            ///  capture/compare register 2
            CCR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 2 value
                CCR2: u16,
                padding: u16,
            }),
            reserved68: [8]u8,
            ///  break and dead-time register
            BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: u2,
                ///  Off-state selection for Idle mode
                OSSI: u1,
                ///  Off-state selection for Run mode
                OSSR: u1,
                ///  Break enable
                BKE: u1,
                ///  Break polarity
                BKP: u1,
                ///  Automatic output enable
                AOE: u1,
                ///  Main output enable
                MOE: u1,
                ///  Break filter
                BKF: u4,
                padding: u12,
            }),
            ///  DMA control register
            DCR: mmio.Mmio(packed struct(u32) {
                ///  DMA base address
                DBA: u5,
                reserved8: u3,
                ///  DMA burst length
                DBL: u5,
                padding: u19,
            }),
            ///  DMA address for full transfer
            DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses
                DMAB: u16,
                padding: u16,
            }),
            reserved96: [16]u8,
            ///  TIM15 alternate fdfsdm1_breakon register 1
            AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: u1,
                ///  BRK COMP1 enable
                BKCMP1E: u1,
                ///  BRK COMP2 enable
                BKCMP2E: u1,
                reserved8: u5,
                ///  BRK dfsdm1_break[0] enable
                BKDF1BK0E: u1,
                ///  BRK BKIN input polarity
                BKINP: u1,
                ///  BRK COMP1 input polarity
                BKCMP1P: u1,
                ///  BRK COMP2 input polarity
                BKCMP2P: u1,
                padding: u20,
            }),
            reserved104: [4]u8,
            ///  TIM15 input selection register
            TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: u4,
                reserved8: u4,
                ///  selects TI2[0] to TI2[15] input
                TI2SEL: u4,
                padding: u20,
            }),
        };
    };
};
